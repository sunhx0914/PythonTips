## PythonTips:

### 0 介绍

**计算机不能直接理解任何除机器语言以外的语言**，所以必须要把程序员所写的程序语言翻译成机器语言，计算机才能执行程序。**将其他语言翻译成机器语言的工具，被称为编译器**

编译器翻译的方式有两种：一个是**编译**，另外一个是**解释**。两种方式之间的区别在于**翻译时间点的不同**。当编译器**以解释方式运行的时候**，也称之为**解释器**

![53453453543](https://user-images.githubusercontent.com/51505633/78670200-fb8ccb00-790f-11ea-8ef8-4654895ddb11.jpg)

* **编译型语言**：程序在执行之前需要一个专门的编译过程，把程序编译成为机器语言的文件，运行时不需要重新翻译，直接使用编译的结果就行了。程序执行效率高，依赖编译器，跨平台性差些。如 C、C++
* **解释型语言**：解释型语言编写的程序不进行预先编译，以文本方式存储程序代码，会将代码一句一句直接运行。在发布程序时，看起来省了道编译工序，但是在运行程序的时候，必须先解释再运行

##### 编译型语言和解释型语言对比

* **速度** —— 编译型语言比解释型语言执行速度快
* **跨平台性** —— 解释型语言比编译型语言跨平台性好

Python 解释器内运行 import this

##### Python 特点

* Python 是**完全面向对象的语言**
  * **函数**、**模块**、**数字**、**字符串**都是对象，**在 Python 中一切皆对象**
  * 完全支持继承、重载、多重继承
  * 支持重载运算符，也支持泛型设计
* Python **拥有一个强大的标准库**，Python 语言的核心只包含 **数字**、**字符串**、**列表**、**字典**、**文件** 等常见类型和函数，而由 Python 标准库提供了 **系统管理**、**网络通信**、**文本处理**、**数据库接口**、**图形系统**、**XML 处理** 等额外的功能
* Python 社区提供了**大量的第三方模块**，使用方式与标准库类似。它们的功能覆盖 **科学计算**、**人工智能**、**机器学习**、**Web 开发**、**数据库接口**、**图形系统** 多个领域

##### 交互式运行 Python 程序

##### IPython 是一个 python 的 **交互式 shell**，比默认的 `python shell` 好用得多

#####  Python 程序执行原理

1.  **CPU** 把 **代码、Python 解释器的程序** 复制到 **内存** 中
2. **Python 解释器** 根据语法规则，**从上向下** 让 **CPU** 翻译 **Python 程序中的代码**
3. **CPU** 负责执行翻译完成的代码

### 1 运算符

//  取整除  返回除法的整数部分（商） 9 // 2 输出结果 4

**  幂  又称次方、乘方，2 ** 3 = 8

在 Python 中 `*` 运算符还可以用于字符串，计算结果就是字符串重复指定次数的结果，eg："-" * 50

### 2 变量、判断、循环

真True  非 0数 —— **非零即真**

如果变量是 bool 型，在计算时True 对应的数字是 1

* 如果希望输出文字信息的同时，**一起输出** **数据**，就需要使用到 **格式化操作符**
* `%` 被称为 **格式化操作符**，专门用于处理字符串中的格式
  * 包含 `%` 的字符串，被称为 **格式化字符串**
  * `%` 和不同的 **字符** 连用，**不同类型的数据** 需要使用 **不同的格式化字符**

| 格式化字符 | 含义                                                         |
| ---------- | ------------------------------------------------------------ |
| %s         | 字符串                                                       |
| %d         | 有符号十进制整数，`%06d` 表示输出的整数显示位数，不足的地方使用 `0` 补全 |
| %f         | 浮点数，`%.2f` 表示小数点后只显示两位                        |
| %%         | 输出 `%`                                                     |

* 语法格式如下：

```python
print("格式化字符串" % 变量1)
print("格式化字符串" % (变量1, 变量2...))
scale = 0.8
print("数据比例是 %.2f%%" % (scale * 100))
# 数据比例是 80.00%
```

标示符可以由 **字母**、**下划线** 和 **数字** 组成，**不能以数字开头**，**不能与关键字重名**

**关键字** 就是在 `Python` 内部已经使用的标识符

通过以下命令可以查看 `Python` 中的关键字

```python
import keyword
print(keyword.kwlist)
```

##### 变量命名

在 `Python` 中，如果 **变量名** 需要由 **二个** 或 **多个单词** 组成时，可以按照以下方式命名

1. 每个单词都使用小写字母、单词与单词之间使用 **`_`下划线** 连接，例如：`first_name`、`last_name`、`qq_number`、`qq_password`

2. 驼峰命名法

   **小驼峰式命名法**，第一个单词以小写字母开始，后续单词的首字母大写例如：`firstName`、`lastName`

   **大驼峰式命名法**，每一个单词的首字母都采用大写字母，例如：`FirstName`、`LastName`、`CamelCase` 

##### 判断

**elif** 的应用场景是：**同时** 判断 **多个条件**，所有的条件是 **平级** 的

**if 的嵌套** 的应用场景就是：**在之前条件满足的前提下，再增加额外的判断**

##### 循环

在使用 continue 之前，同样应该修改计数器

print 参数 `end=""` 表示向控制台输出内容结束之后，不会换行

### 3 函数

在开发中，如果希望给函数添加注释，应该在 **定义函数** 的下方，使用 **连续的三对引号**，在其之间编写对函数的说明文字。在 **函数调用** 位置，使用快捷键 `CTRL + Q` 可以查看函数的说明信息

* **形参**：**定义** 函数时的参数，是用来接收参数用的，在函数内部 **作为变量使用**
* **实参**：**调用** 函数时的参数，是用来把数据传递到 **函数内部** 用的

* **模块** 就好比是 **工具包**，要想使用这个工具包中的工具，就需要 **导入 import** 这个模块
* 每一个以扩展名 `py` 结尾的 `Python` 源代码文件都是一个 **模块**
* 在模块中定义的 **全局变量** 、 **函数** 都是模块能够提供给外界直接使用的工具

注意：如果在给 Python 文件起名时，**以数字开头** 是无法在 `PyCharm` 中通过导入这个模块的

##### pyc 文件

`.pyc` 文件是由 Python 解释器将 **模块的源码** 转换为 **字节码**，作为一种启动 **速度的优化**

* `Python` 在解释源程序时是分成两个步骤的
  1. 首先处理源代码，**编译** 生成一个二进制 **字节码**
  2. 再对 **字节码** 进行处理，才会生成 CPU 能够识别的 **机器码**

* 有了模块的字节码文件之后，下一次运行程序时，如果在 **上次保存字节码之后** 没有修改过源代码，Python 将会加载 .pyc 文件并跳过编译这个步骤
* 当 `Python` 重编译时，它会自动检查源文件和字节码文件的时间戳
* 如果你又修改了源代码，下次程序运行时，字节码将自动重新创建

### 4 高级变量类型

Python 中数据类型可以分为 **数字型** 和 **非数字型**

数字型：整型、浮点型、布尔型、复数型

非数字型：字符串、列表、元组、字典

##### 列表

![list](https://user-images.githubusercontent.com/51505633/78681308-27fc1380-791f-11ea-80c0-56a589c689df.jpg)

clear() 方法可以清空列表

**方法** 和函数类似，需要通过 **对象** 来调用，表示针对这个 **对象** 要做的操作

##### 元组

![tuple](https://user-images.githubusercontent.com/51505633/78682826-13207f80-7921-11ea-8e2d-76873d05a63c.jpg)

元组中 **只包含一个元素** 时，需要 **在元素后面添加逗号**

格式化字符串后面的 `()` 本质上就是一个元组

```python
info = ("zhangsan", 18)
print("%s 的年龄是 %d" % info)
```

元组和列表之间的转换：list(元组)、tuple(列表)

##### 字典

![dict](https://user-images.githubusercontent.com/51505633/78683626-1cf6b280-7922-11ea-86ec-3bff1b7b64ed.jpg)

* 使用 **键值对** 存储数据，键值对之间使用 `,` 分隔
* **键** `key` 是索引
* **值** `value` 是数据
* **键** 和 **值** 之间使用 `:` 分隔
* **键必须是唯一的**
* **值** 可以取任何数据类型，但 **键** 只能使用 **字符串**、**数字**或 **元组**
* 被合并的字典中包含已经存在的键值对，会覆盖原有的键值对

在开发中，更多的应用场景是：

* 使用 **多个键值对**，存储 **描述一个 `物体` 的相关信息** —— 描述更复杂的数据信息
* 将 **多个字典** 放在 **一个列表** 中，再进行遍历，在循环体内部针对每一个字典进行 **相同的处理**

##### 字符串

![str](https://user-images.githubusercontent.com/51505633/78683936-765ee180-7922-11ea-99e4-2bee08857911.jpg)

1) 判断类型 - 9

| 方法               | 说明                                                         |
| ------------------ | ------------------------------------------------------------ |
| string.isspace()   | 如果 string 中只包含空格，则返回 True                        |
| string.isalnum()   | 如果 string 至少有一个字符并且所有字符都是字母或数字则返回 True |
| string.isalpha()   | 如果 string 至少有一个字符并且所有字符都是字母则返回 True    |
| string.isdecimal() | 如果 string 只包含数字则返回 True，`全角数字`                |
| string.isdigit()   | 如果 string 只包含数字则返回 True，`全角数字`、`⑴`、`\u00b2` |
| string.isnumeric() | 如果 string 只包含数字则返回 True，`全角数字`，`汉字数字`    |
| string.istitle()   | 如果 string 是标题化的(每个单词的首字母大写)则返回 True      |
| string.islower()   | 如果 string 中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是小写，则返回 True |
| string.isupper()   | 如果 string 中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是大写，则返回 True |

2) 查找和替换 - 7

| 方法                                                    | 说明                                                         |
| ------------------------------------------------------- | ------------------------------------------------------------ |
| string.startswith(str)                                  | 检查字符串是否是以 str 开头，是则返回 True                   |
| string.endswith(str)                                    | 检查字符串是否是以 str 结束，是则返回 True                   |
| string.find(str, start=0, end=len(string))              | 检测 str 是否包含在 string 中，如果 start 和 end 指定范围，则检查是否包含在指定范围内，如果是返回开始的索引值，否则返回 `-1` |
| string.rfind(str, start=0, end=len(string))             | 类似于 find()，不过是从右边开始查找                          |
| string.index(str, start=0, end=len(string))             | 跟 find() 方法类似，不过如果 str 不在 string 会报错          |
| string.rindex(str, start=0, end=len(string))            | 类似于 index()，不过是从右边开始                             |
| string.replace(old_str, new_str, num=string.count(old)) | 把 string 中的 old_str 替换成 new_str，如果 num 指定，则替换不超过 num 次 |

3) 大小写转换 - 5

| 方法                | 说明                             |
| ------------------- | -------------------------------- |
| string.capitalize() | 把字符串的第一个字符大写         |
| string.title()      | 把字符串的每个单词首字母大写     |
| string.lower()      | 转换 string 中所有大写字符为小写 |
| string.upper()      | 转换 string 中的小写字母为大写   |
| string.swapcase()   | 翻转 string 中的大小写           |

4) 文本对齐 - 3

| 方法                 | 说明                                                         |
| -------------------- | ------------------------------------------------------------ |
| string.ljust(width)  | 返回一个原字符串左对齐，并使用空格填充至长度 width 的新字符串 |
| string.rjust(width)  | 返回一个原字符串右对齐，并使用空格填充至长度 width 的新字符串 |
| string.center(width) | 返回一个原字符串居中，并使用空格填充至长度 width 的新字符串  |

5) 去除空白字符 - 3

| 方法            | 说明                               |
| --------------- | ---------------------------------- |
| string.lstrip() | 截掉 string 左边（开始）的空白字符 |
| string.rstrip() | 截掉 string 右边（末尾）的空白字符 |
| string.strip()  | 截掉 string 左右两边的空白字符     |

6) 拆分和连接 - 5

| 方法                      | 说明                                                         |
| ------------------------- | ------------------------------------------------------------ |
| string.partition(str)     | 把字符串 string 分成一个 3 元素的元组 (str前面, str, str后面) |
| string.rpartition(str)    | 类似于 partition() 方法，不过是从右边开始查找                |
| string.split(str="", num) | 以 str 为分隔符拆分 string，如果 num 有指定值，则仅分隔 num + 1 个子字符串，str 默认包含 '\r', '\t', '\n' 和空格 |
| string.splitlines()       | 按照行('\r', '\n', '\r\n')分隔，返回一个包含各行作为元素的列表 |
| string.join(seq)          | 以 string 作为分隔符，将 seq 中所有的元素（的字符串表示）合并为一个新的字符串 |

##### 切片

切片：适用于 **字符串**、**列表**、**元组**

**列表** 和 **元组** 都是 **有序** 的集合，都能够 **通过索引值** 获取到对应的数据：`字符串[开始索引:结束索引:步长]`

1. 指定的区间属于 **左闭右开** 型 `[开始索引,  结束索引)`
2. 从头开始，**开始索引** **数字可以省略，冒号不能省略**
3. 到末尾结束，**结束索引** **数字可以省略，冒号不能省略**
4. 步长默认为 `1`，如果连续切片，**数字和冒号都可以省略**

##### 字符串的逆序（面试题）

实现方法：`print(num_str[::-1])`

##### 内置函数

Python 包含了以下内置函数：

| 函数      | 描述                 | 备注                                |
| --------- | -------------------- | ----------------------------------- |
| len(item) | 计算容器中元素个数   |                                     |
| del(item) | 删除变量             | del 有两种方式  关键字方式 函数方式 |
| max(item) | 返回容器中元素最大值 | 如果是字典，只针对 key 比较         |
| min(item) | 返回容器中元素最小值 | 如果是字典，只针对 key 比较         |

##### 运算符

|    运算符    | Python 表达式         | 结果                         | 描述           | 支持的数据类型           |
| :----------: | --------------------- | ---------------------------- | -------------- | ------------------------ |
|      +       | [1, 2] + [3, 4]       | [1, 2, 3, 4]                 | 合并           | 字符串、列表、元组       |
|      *       | ["Hi!"] * 4           | ['Hi!', 'Hi!', 'Hi!', 'Hi!'] | 重复           | 字符串、列表、元组       |
|      in      | 3 in (1, 2, 3)        | True                         | 元素是否存在   | 字符串、列表、元组、字典 |
|    not in    | 4 not in (1, 2, 3)    | True                         | 元素是否不存在 | 字符串、列表、元组、字典 |
| > >= == < <= | (1, 2, 3) < (2, 2, 3) | True                         | 元素比较       | 字符串、列表、元组       |

**注意：**

* `in` 在对 **字典** 操作时，判断的是 **字典的键**
* `in` 和 `not in` 被称为 **成员运算符**

TODO 注释：在 `#` 后跟上 `TODO`，用于标记需要去做的工作

```python
# TODO(作者/邮件) 显示系统菜单
```

**在 `return` 后没有跟任何内容，只是表示该函数执行到此就不再执行后续的代码**

### 5 变量进阶

##### 引用

变量 和 数据 都是保存在 **内存** 中的。

在 `Python` 中 **函数 的 参数传递** 以及 **返回值** 都是靠 **引用** 传递的。

* **变量** 和 **数据** 是分开存储的，**数据** 保存在内存中的一个位置，**变量** 中保存着数据在内存中的地址
* **变量** 中 **记录数据的地址**，就叫做 **引用**
* 使用 `id()` 函数可以查看变量中保存数据所在的 **内存地址**

> 注意：如果变量已经被定义，当给一个变量赋值的时候，本质上是 **修改了数据的引用**，变量 **不再** 对之前的数据引用，变量 **改为** 对新赋值的数据引用。

```python
a = 2
b = a
```

将变量 `a` 的值赋值给 `b`，`a` 和 `b` 都指向了 2

```python
def test(num):
    print("-" * 50)
    print("%d 在函数内的内存地址是 %x" % (num, id(num)))
    result = 100
    print("返回值 %d 在内存中的地址是 %x" % (result, id(result)))
    print("-" * 50)
    # 将字符串变量返回，返回的是数据的引用，而不是数据本身
    return  result

a = 10
print("调用函数前 内存地址是 %x" % id(a))
# 调用 test 函数，本质上传递的是实参保存数据的引用，而不是实参保存的数据！
r = test(a)
print("调用函数后 实参内存地址是 %x" % id(a))
print("调用函数后 返回值内存地址是 %x" % id(r))
```

##### 可变和不可变类型：

* **不可变类型**，内存中的数据不允许被修改：数字类型 `int`, `bool`, `float`, `complex`；字符串 `str`；元组 `tuple`
* **可变类型**，内存中的数据可以被修改：列表 `list`；字典 `dict`

> 1. 字典的 `key` **只能使用不可变类型的数据**
> 2. **可变类型**的数据变化，是通过 **方法** 来实现的
> 3. 如果给一个可变类型的变量，赋值了一个新的数据，**引用会修改**

##### 哈希 `(hash)`

* `Python` 中内置有一个名字叫做 `hash(o)` 的函数，接收一个 **不可变类型** 的数据作为 **参数**，**返回** 结果是一个 **整数**。

* `哈希` 是一种 **算法**，其作用就是提取数据的 **特征码（指纹）**，**相同的内容** 得到 **相同的结果**，**不同的内容** 得到 **不同的结果**。

* 在 `Python` 中，设置字典的 **键值对** 时，会首先对 `key` 进行 `hash` 已决定如何在内存中保存字典的数据，以方便 **后续** 对字典的操作：**增、删、改、查**。

  `key` 必须是不可变类型数据，`value` 可以是任意类型的数据。

##### 局部变量和全局变量

* **局部变量** 是在 **函数内部** 定义的变量，**只能在函数内部使用**，用于**临时** 保存 **函数内部需要使用的数据**。局部变量在 **函数执行时** 才会被创建，**函数执行结束后** 局部变量 **被系统回收**
* **全局变量** 是在 **函数外部定义** 的变量（没有定义在某一个函数内），**所有函数** 内部 **都可以使用这个变量**。

> 注意：
>
> 同名局部变量会优先使用，若无才使用全局变量
>
> 函数不能直接修改 `全局变量的引用`：想要在函数中赋值修改时，相当于定义同名局部变量。
>
> 在函数中需要修改全局变量，需要使用 `global` 进行声明：`global num`
>
> 应 **将全局变量定义在其他函数的上方**，全局变量名前应该增加 `g_` 或者 `gl_` 的前缀

### 6 函数进阶

函数根据 **有没有参数** 以及 **有没有返回值**，可以 **相互组合**，一共有 **4 种** 组合形式。

1. 如果函数 **内部处理的数据不确定**，就需要将外界的数据以参数传递到函数内部
2. 如果一个函数 **执行完成后，需要向外界汇报执行结果**，就需要增加函数的返回值

函数返回的类型是元组，小括号可以省略

在 `Python` 中，可以 **将一个元组** 使用 **赋值语句** 同时赋值给 **多个变量**

##### 面试题 —— 交换两个数字

```python
# 要求：两个整数变量 a = 6, b = 100 的值
# 解法 1 - 使用临时变量
c = b
b = a
a = c
# 解法 2 - 不使用临时变量
a = a + b
b = a - b
a = a - b
# 解法 3 - Python 专有，利用元组
a, b = b, a
```

- 在函数内部，针对参数使用 **赋值语句**，不会影响调用函数时传递的 **实参变量**。
- 如果传递的参数是 **可变类型**，在函数内部，使用 **方法** 修改了数据的内容，**同样会影响到外部的数据**。

##### 面试题 —— +=

* 在 `python` 中，列表变量调用 `+=` 本质上是在执行列表变量的 `extend` 方法，不会修改变量的引用

```python
def demo(num, num_list):
    print("函数内部代码")
    num += num
    num_list += num_list
    # 本质上是：num_list.extend(num_list) 由于是调用方法，所以不会修改变量的引用
    # 函数执行结束后，外部数据同样会发生变化
    print(num)  # 18
    print(num_list)  # [1, 2, 3, 1, 2, 3]
    print("函数代码完成")

gl_num = 9
gl_list = [1, 2, 3]
demo(gl_num, gl_list)
print(gl_num)  # 9
print(gl_list)  # [1, 2, 3, 1, 2, 3]
```

##### 函数参数

1. 位置参数： 位置参数要求调用时传入函数的参数必须和定义时的位置和个数一致，即一一对应，不可缺省 

2. 缺省参数（默认参数）：

   - 定义函数时，可以给 **某个参数** 指定一个**默认值**，具有默认值的参数就叫做 **缺省参数**

   - 调用函数时，如果没有传入 **缺省参数** 的值，则在函数内部使用定义函数时指定的 **参数默认值**

   - 函数的缺省参数，**将常见的值设置为参数的缺省值**，从而 **简化函数的调用**
   
     **提示：**
   
     - 缺省参数，需要使用 **最常见的值** 作为默认值！如果一个参数的值不能确定，则不应该设置默认值，具体的数值在调用函数时，由外界传递！
     - **必须保证** **带有默认值的缺省参数** **在参数列表末尾**。
     - 在 **调用函数时**，如果有 **多个缺省参数**，**需要指定参数名**
   
3. 多值参数（可变参数、关键字参数）：

   一般在给多值参数命名时，**习惯**使用以下两个名字：

   - `*args` -- 可变参数，存放 **元组** 参数，`args` 是 `arguments` 的缩写，有变量的含义
   - `**kwargs` -- 关键字参数，存放 **字典** 参数，`kw` 是 `keyword` 的缩写，`kwargs` 可以记忆 **键值对参数**

**参数位置排列顺序：位置参数，默认参数，可变参数，关键字参数**

##### 元组和字典的拆包

* 在调用带有多值参数的函数时，如果希望：
  * 将一个 **元组变量**，直接传递给 `args`
  * 将一个 **字典变量**，直接传递给 `kwargs`
* 就可以使用 **拆包**，简化参数的传递，**拆包** 的方式是：
  * 在 **元组变量前**，增加 **一个** `*`
  * 在 **字典变量前**，增加 **两个** `*`

```python
def demo(*args, **kwargs):
    print(args)
    print(kwargs)

# 需要将一个元组变量/字典变量传递给函数对应的参数
gl_nums = (1, 2, 3)
gl_xiaoming = {"name": "小明", "age": 18}

demo(gl_nums, gl_dict)
'''输出
((1, 2, 3), {'name': '小明', 'age': 18})
{}'''
# 拆包语法，简化元组变量/字典变量的传递
demo(*gl_nums, **gl_dict)
'''输出
(1, 2, 3)
{'name': '小明', 'age': 18}'''
demo(1, 2, 3, name="小明", age=18)
'''输出
(1, 2, 3)
{'name': '小明', 'age': 18}'''
```

##### 递归

**特点**：**一个函数** **内部** **调用自己**

**代码特点**：

1. 函数内部的 **代码** 是相同的，只是针对 **参数** 不同，**处理的结果不同**
2. 当 **参数满足一个条件** 时，函数不再执行（**这个非常重要**，通常被称为递归的出口，否则 **会出现死循环**！）

示例：

```python
def sum_numbers(num):
    print(num)
    # 递归的出口很重要，否则会出现死循环
    if num == 1:
        return
    sum_numbers(num - 1)

sum_numbers(3)
```

递归案例 —— 计算数字累加：

```python
# 需求
# 1. 定义一个函数 sum_numbers
# 2. 能够接收一个 num 的整数参数
# 3. 计算 1 + 2 + ... num 的结果
def sum_numbers(num):
    if num == 1:
        return 1
    # 假设 sum_numbers 能够完成 num - 1 的累加
    temp = sum_numbers(num - 1)
    # 函数内部的核心算法就是 两个数字的相加
    return num + temp

print(sum_numbers(2))
```

![RecursiveFunction](https://user-images.githubusercontent.com/51505633/78697315-36542a80-7933-11ea-91bc-a04c907e5b64.jpg)

> 提示：递归是一个 **编程技巧**，初次接触递归会感觉有些吃力！在处理 **不确定的循环条件时**，格外的有用，例如：**遍历整个文件目录的结构**

### 7 面向对象

**面向对象编程** —— `Object Oriented Programming` 简写 `OOP` 

**面向过程** —— **怎么做**？

1. 把完成某一个需求的 `所有步骤` `从头到尾` 逐步实现
2. 根据开发需求，将某些 **功能独立** 的代码 **封装** 成一个又一个 **函数**
3. 最后完成的代码，就是顺序地调用 **不同的函数**

**面向对象** —— **谁来做**？

> 相比较函数，**面向对象** 是 **更大** 的 **封装**，根据 **职责** 在 **一个对象中 封装 多个方法**

1. 在完成某一个需求前，首先确定 **职责** —— **要做的事情（方法）**
2. 根据 **职责** 确定不同的 **对象**，在 **对象** 内部封装不同的 **方法**（多个）
3. 最后完成的代码，就是顺序地让 **不同的对象** 调用 **不同的方法**

##### 类和对象

**类** 和 **对象** 是 **面向对象编程的 两个 核心概念** 

- **类** 是对一群具有 **相同 特征(属性)** 或者 **行为(方法)**** 的事物的一个统称，是抽象的，**不能直接使用** 
- **对象** 是 **由类创建出来的一个具体存在**，可以直接使用

类和对象的关系：

- **类是模板**，**对象** 是根据 **类** 这个模板创建出来的，应该 **先有类，再有对象**
- 类只有一个，而对象可以有很多个
  - **不同的对象** 之间 **属性** 可能会各不相同
- **类** 中定义了什么 **属性和方法**，**对象** 中就有什么属性和方法，**不可能多，也不可能少**

设计一个类，通常需要满足一下三个要素：

1. **类名** 这类事物的名字（名词），**满足大驼峰命名法（首字母大写，无下划线）**
2. **属性** 这类事物具有什么样的特征
3. **方法** 这类事物具有什么样的行为（动词）

>  *提示：需求中没有涉及的属性或者方法在设计类时，不需要考虑* 

##### dir 内置函数

 Python 一切皆对象。 

使用内置函数 `dir` 传入 **标识符** / **数据**，可以查看对象内的 **所有属性及方法**

`__方法名__` 格式的方法是 `Python` 提供的 **内置方法 / 属性** 

类中 **方法** 的第一个参数必须是 `self`

##### 引用概念的强调

- 在 `Python` 中使用类 **创建对象之后**，`tom` 变量中 仍然记录的是 **对象在内存中的地址**
- 也就是 `tom` 变量 **引用** 了 **新建的对象**
- 使用 `print` 输出 **对象变量**，默认情况下，是能够输出这个变量 **引用的对象** 是 **由哪一个类创建的对象**，以及 **在内存中的地址**（**十六进制表示**）(结果同id()）

- `%d` 可以以 **10 进制** 输出数字
- `%x` 可以以 **16 进制** 输出数字

##### self

>  *由* **哪一个对象** *调用的方法，方法内的* `self` *就是* **哪一个对象的引用** 

- 在类封装的方法内部，`self` 就表示 **当前调用方法的对象自己**
- **调用方法时**，程序员不需要传递 `self` 参数
- 在方法内部
  - 可以通过 `self.` **访问对象的属性**
  - 也可以通过 `self.` **调用对象的其他方法**

##### 初始化方法

当使用 类名()创建对象时，会自动执行以下操作：

1. 为对象在内存中 **分配空间** —— 创建对象
2. 为对象的属性 **设置初始值** —— 初始化方法(`init`)

- 这个 **初始化方法** 就是 `__init__` 方法，`__init__` 是对象的**内置方法**

> `__init__` 方法是 **专门** 用来定义一个类 **具有哪些属性的方法**！

- 在 `__init__` 方法内部使用 `self.属性名 = 属性的初始值` 就可以 **定义属性**
- 定义属性之后，再使用类创建的对象，都会拥有该属性

可以通过 `对象.属性名 = 值` 在类外添加属性，但是不推荐!

##### `__del__ ` 和 `__str__`

当使用 `类名()` 创建对象时，为对象 **分配完空间**后，**自动** 调用 `__init__` 方法

当一个 **对象被从内存中销毁** 前，会 **自动** 调用 `__del__` 方法

如果希望在对象被销毁前，再做一些事情，可以考虑一下 `__del__`方法

一个对象从调用 `类名()` 创建，生命周期开始，`__del__` 方法一旦被调用，生命周期结束

`del tom  # del 关键字可以删除一个对象`

`__str__`方法，返回对象的描述信息（必须为字符串），print 函数打印对象时自定义输出使用

#### 封装

1. 面向对象编程的 **第一步** —— 将 **属性** 和 **方法** **封装** 到一个抽象的 **类** 中
2. **外界** 使用 **类** 创建 **对象**，然后 **让对象调用方法**
3. **对象方法的细节** 都被 **封装** 在 **类的内部**

**同一个类** 创建的 **多个对象** 之间，**属性** 互不干扰！

**被使用的类**，通常应该先开发 

`return ` 后面为空 可不执行后续代码返回 

一个对象的 **属性** *可以是* **另外一个类创建的对象** 。

> 如：需求1中
>
> 1. **士兵** **许三多** 有一把 **AK47**
> 2. **士兵** 可以 **开火**
> 3. **枪** 能够 **发射** 子弹
> 4. **枪** 装填 **装填子弹** —— **增加子弹数量**

 假设：每一个新兵 都 **没有枪** 

在定义属性时，如果 **不知道设置什么初始值**，可以设置为 `None`

- `None` **关键字** 表示 **什么都没有**
- 表示一个 **空对象**，**没有方法和属性，是一个特殊的常量**
- 可以将 `None` 赋值给任何一个变量

在实例化类后可以复制给属性 `xusanduo.gun = ak47`

在 **封装的** 方法内部，还可以让 **自己的** **使用其他类创建的对象属性** 调用已经 **封装好的方法**

##### 身份运算符

身份运算符用于 **比较** 两个对象的 **内存地址** 是否一致 —— **是否是对同一个对象的引用**

- 在 `Python` 中针对 `None` 比较时，建议使用 `is` 判断

| 运算符 | 描述                                      | 实例                            |
| :----- | :---------------------------------------- | :------------------------------ |
| is     | is 是判断两个标识符是不是引用同一个对象   | x is y，类似 id(x) == id(y)     |
| is not | is not 是判断两个标识符是不是引用不同对象 | x is not y，类似 id(a) != id(b) |

is 与 == 区别：`is` 用于判断 **两个变量 引用对象是否为同一个** ；`==` 用于判断 **引用变量的值** 是否相等。

##### 私有属性和私有方法

**对象** 的 **某些属性或方法** 可能只希望 **在对象的内部被使用**，而 **不希望在外部被访问到**，**私有属性** 就是 **对象** 不希望公开的 **属性**，**私有方法** 就是 **对象** 不希望公开的 **方法**

在 **定义属性或方法时**，在 **属性名或者方法名前** 增加 **两个下划线**，定义的就是 **私有** 属性或方法

- 在对象的方法内部，是可以访问对象的私有属性的
- 私有属性，私有方法，在外界不能够被直接访问

##### 伪私有属性和私有方法

> 提示：在日常开发中，**不要使用这种方式**，**访问对象的 私有属性 或 私有方法**

`Python` 中，并没有 **真正意义** 的 **私有**

- 在给 **属性**、**方法** 命名时，实际是对 **名称** 做了一些特殊处理，使得外界无法访问到
- **处理方式**：在 **名称** 前面加上 `_类名` => `_类名__名称`

#### 继承（单、多）

##### **面向对象三大特性**

1. **封装** 根据 **职责** 将 **属性** 和 **方法** **封装** 到一个抽象的 **类** 中
2. **继承** **实现代码的重用**，相同的代码不需要重复的编写
3. **多态** 不同的对象调用相同的方法，产生不同的执行结果，**增加代码的灵活度**

- **子类** 继承自 **父类**，可以直接 **使用** 父类中已经封装好的方法，不需要再次开发
- **子类** 中应该根据 **职责**，封装 **子类特有的** **属性和方法**

专业术语：

- `Dog` 类是 `Animal` 类的**子类**，`Animal` 类是 `Dog` 类的**父类**，`Dog` 类从 `Animal` 类**继承**
- `Dog` 类是 `Animal` 类的**派生类**，`Animal` 类是 `Dog` 类的**基类**，`Dog` 类从 `Animal` 类**派生**

**继承具有传递性**

##### 重写

当 **父类** 的方法实现不能满足子类需求时，可以对方法进行 **重写(override)**

##### **重写**父类方法的两种情况

1. **覆盖** 父类的方法

   如果在开发中，**父类的方法实现** 和 **子类的方法实现**，**完全不同**就可以使用 **覆盖** 的方式，**在子类中** **重新编写** 父类的方法实现

   具体的**实现方式**：相当于在 **子类中** 定义了一个 **和父类同名的方法并且实现**

   重写之后，在运行时，**只会调用** 子类中重写的方法，而不再会调用 **父类封装的方法**

2. 对父类方法进行 **扩展**

   如果在开发中，**子类的方法实现** 中 **包含** **父类的方法实现** （**父类原本封装的方法实现** 是 **子类方法的一部分**），就可以使用 **扩展** 的方式，实现方式：

   1. **在子类中** **重写** 父类的方法（定义 **和父类同名的方法 **）
   2. 在需要的位置使用 `super().父类方法()` 来调用父类方法的执行
   3. 代码其他的位置针对子类的需求，编写 **子类特有的代码实现**

   > 在 `Python 2.x` 时，如果需要调用父类的方法，还可以使用以下方式：`父类名.方法(self)` ，不推荐使用


##### 关于 `super`

- 在 `Python` 中 `super` 是一个 **特殊的类**
- `super()` 就是使用 `super` 类创建出来的对象
- **最常** 使用的场景就是在 **重写父类方法时**，调用 **在父类中封装的方法实现**

##### 父类的 私有属性 和 私有方法

1. **子类对象** **不能** 在自己的方法内部，**直接** 访问 父类的 **私有属性** 或 **私有方法**
2. **子类对象** 可以通过 **父类** 的 **公有方法** **间接** 访问到 **私有属性** 或 **私有方法**

> **私有属性、方法** 是对象的隐私，不对外公开，**外界** 以及 **子类** 都不能直接访问

##### 多继承

**子类** 可以拥有 **多个父类**，并且具有 **所有父类** 的 **属性** 和 **方法**

如果 **不同的父类** 中存在 **同名的方法**，**子类对象** 在调用方法时，会调用 **哪一个父类中**的方法呢？

> 提示：**开发时，应该尽量避免这种容易产生混淆的情况！** —— 如果 **父类之间** 存在 **同名的属性或者方法**，应该 **尽量避免** 使用多继承

##### MRO —— 方法搜索顺序

`Python` 中针对 **类** 提供了一个 **内置属性** `__mro__` 可以查看 **方法** 搜索顺序，返回一个元组。MRO 是 `method resolution order`，主要用于 **在多继承时判断 方法、属性 的调用 路径**

- 在搜索方法时，是按照 `__mro__` 的输出结果 **从左至右** 的顺序查找的
- 如果在当前类中 **找到方法，就直接执行，不再搜索**
- 如果 **没有找到，就查找下一个类** 中是否有对应的方法，**如果找到，就直接执行，不再搜索**
- 如果找到最后一个类，还没有找到方法，程序报错

##### 新式类与旧式（经典）类

> `object` 是 `Python` 为所有对象提供的 **基类**，提供有一些内置的属性和方法，可以使用 `dir` 函数查看

- **新式类**：以 `object` 为基类的类，**推荐使用**
- **经典类**：不以 `object` 为基类的类，**不推荐使用**
- 在 `Python 3.x` 中定义类时，如果没有指定父类，会 **默认使用** `object` 作为该类的 **基类** —— `Python 3.x` 中定义的类都是 **新式类**
- 在 `Python 2.x` 中定义类时，如果没有指定父类，则不会以 `object` 作为 **基类**

为了保证编写的代码能够同时在 `Python 2.x` 和 `Python 3.x` 运行！
今后在定义类时，**如果没有父类，建议统一继承自 `object`**：`class 类名(object):`

#### 多态

##### **面向对象三大特性**

1. **封装** 根据 **职责** 将 **属性** 和 **方法** **封装** 到一个抽象的 **类** 中 
   - 定义类的准则
2.  **继承** **实现代码的重用**，相同的代码不需要重复的编写 
   - 设计类的技巧
   - 子类针对自己特有的需求，编写特定的代码
3. **多态** 不同的 **子类对象** 调用相同的 **父类方法**，产生不同的执行结果
   - **多态** 可以 **增加代码的灵活度**
   - 以 **继承** 和 **重写父类方法** 为前提
   - 是调用方法的技巧，**不会影响到类的内部设计**

案例：1)在 `Dog` 类中封装方法 `game`，普通狗只是简单的玩耍 2) 定义 `XiaoTianDog` 继承自 `Dog`，并且重写 `game` 方法，哮天犬需要在天上玩耍 3) 定义 `Person` 类，并且封装一个 **和狗玩** 的方法，在方法内部，直接让 **狗对象** 调用 `game `方法

```python
class Dog(object):
    def __init__(self, name):
        self.name = name
    def game(self):
        print("%s 蹦蹦跳跳的玩耍..." % self.name)
class XiaoTianDog(Dog):
    def game(self):
        print("%s 飞到天上去玩耍..." % self.name)
class Person(object):
    def __init__(self, name):
        self.name = name
    def game_with_dog(self, dog):
        print("%s 和 %s 快乐的玩耍..." % (self.name, dog.name))
        dog.game()  # 让狗玩耍	体现多态
# 1. 创建一个狗对象
# wangcai = Dog("旺财") 这两个语句换着注释，代码基本不变，但是输出不同
wangcai = XiaoTianDog("飞天旺财")
# 2. 创建一个小明对象
xiaoming = Person("小明")
# 3. 让小明调用和狗玩的方法
xiaoming.game_with_dog(wangcai)
```

小结：`Person` 类中只需要让 **狗对象** 调用 `game` 方法，而不关心具体是 **什么狗** ，`game` 方法是在 `Dog` 父类中定义的

#### 类的结构

1. 使用面相对象开发，**第 1 步** 是设计 **类**
2. 使用**类名()**创建对象，**创建对象**的动作有两步：
   - 1) 在内存中为对象 **分配空间**
   - 2) 调用初始化方法 `__init__` 为 **对象初始化**
3. 对象创建后，**内存** 中就有了一个对象的 **实实在在** 的存在 —— **实例**

在 `__init__`中定义实例属性，初始化时调用；用 `def` 和 `self` 参数定义实例方法，`对象名.方法名()`调用

通常也会把：

1. 创建出来的 **对象** 叫做 **类** 的 **实例**
2. 创建对象的 **动作** 叫做 **实例化**
3. **对象的属性** 叫做 **实例属性**
4. **对象调用的方法** 叫做 **实例方法**

执行时可以通过 `self. `访问自己的属性/调用自己的方法

- **每一个对象** 都有自己 **独立的内存空间**，**保存各自不同的属性**
- **多个对象的方法**，**在内存中只有一份**，在调用方法时，**需要把对象的引用** 传递到方法内部

##### 类是一个特殊的对象

> `Python` 中 **一切皆对象**：
>
> - `class AAA:` 定义的类属于 **类对象**
> - `obj1 = AAA()` 属于 **实例对象**

- 在程序运行时，**类** 同样 **会被加载到内存**
- 在 `Python` 中，**类** 是一个特殊的对象 —— **类对象**
- 在程序运行时，**类对象** 在内存中 **只有一份**，使用 **一个类** 可以创建出 **很多个对象实例**
- 除了封装 **实例** 的 **属性** 和 **方法**外，**类对象** 还可以拥有自己的 **属性** 和 **方法** (类属性、类方法)
- 通过 **类名.** 的方式可以 **访问类的属性** 或者 **调用类的方法**

##### 类属性

- **类属性** 就是给 **类对象** 中定义的 **属性**
- 通常用来记录 **与这个类相关** 的特征
- **类属性** **不会用于**记录 **具体对象的特征**

**示例**：定义一个 **工具类**，每件工具都有自己的 `name`，**需求** -- 知道使用这个类，创建了多少个工具对象？

```python
class Tool(object):
    count = 0  # 使用赋值语句，定义类属性，记录创建工具对象的总数
    def __init__(self, name):
        self.name = name
        Tool.count += 1  # 针对类属性做一个计数+1
# 创建工具对象
tool1 = Tool("斧头")
tool2 = Tool("榔头")
tool3 = Tool("铁锹")
# 知道使用 Tool 类到底创建了多少个对象?
print("现在创建了 %d 个工具" % Tool.count)  # 也可以通过 工具对象.count 输出
```

##### 属性的获取机制

- 在 `Python` 中 **属性的获取** 存在一个 **向上查找机制**：
  1. 首先在对象内部查询对象属性
  2. 没有找到就会向上寻找类属性

要访问类属性有两种方式：

1. **类名.类属性**
2. **对象.类属性** （不推荐）

> **注意**：如果使用 `对象.类属性 = 值` 赋值语句，只会 **给对象添加一个属性**，而不会影响到 **类属性的值**

##### 类方法

-  **类属性** 就是针对 **类对象** 定义的属性 
  - 使用 **赋值语句** 在 `class` 关键字下方可以定义 **类属性**
  - **类属性** 用于记录 **与这个类相关** 的特征
-  **类方法** 就是针对 **类对象** 定义的方法 
  - 在 **类方法** 内部可以直接访问 **类属性** 或者调用其他的 **类方法**

**语法如下：**

```python
@classmethod
def 类方法名(cls):
    pass
```

- 类方法需要用 **修饰器** `@classmethod` 来标识，**告诉解释器这是一个类方法**
-  类方法的 **第一个参数** 应该是 `cls` 
  - 由 **哪一个类** 调用的方法，方法内的 `cls` 就是 **哪一个类的引用**
  - 这个参数和 **实例方法** 的第一个参数是 `self` 类似(**提示** 使用其他名称也可以，习惯使用 `cls`)
- 通过 **类名.** 调用 **类方法**，**调用方法时**，不需要传递 `cls` 参数
- 在方法内部
  - 可以通过 `cls.` **访问类的属性**
  - 也可以通过 `cls.` **调用其他的类方法**

**示例**：定义一个 **工具类**，每件工具都有自己的 `name`，**需求** --  在 **类** 封装一个 `show_tool_count` 的类方法，输出使用当前这个类，创建的对象个数 

```python
@classmethod
def show_tool_count(cls):
    """显示工具对象的总数"""
    print("工具对象的总数 %d" % cls.count)
```

##### 静态方法

- 在开发时，如果需要在 **类** 中封装一个方法，这个方法：
  - 既 **不需要** 访问 **实例属性** 或者调用 **实例方法**
  - 也 **不需要** 访问 **类属性** 或者调用 **类方法**
- 这个时候，可以把这个方法封装成一个 **静态方法** (不需要self参数)

```python
@staticmethod
def 静态方法名():
    pass
```

- **静态方法** 需要用 **修饰器** `@staticmethod` 来标识，**告诉解释器这是一个静态方法**
- 通过 **类名.** 调用 **静态方法**，不需要创建对象，不会隐式传递self 

案例：`Game_class_static.py` 文件

1. **实例方法**  —— 方法内部需要访问 **实例属性/方法**
   - **实例方法** 内部可以使用 **类名.** 访问类属性
2. **类方法** —— 方法内部 **只** 需要访问 **类属性/方法**
3. **静态方法** —— 方法内部，不需要访问 **实例属性/方法** 和 **类属性/方法**

#### 单例

- 设计模式
  - **设计模式** 是 **前人工作的总结和提炼**，通常，被人们广泛流传的设计模式都是针对 **某一特定问题** 的成熟的解决方案
  - 使用 **设计模式** 是为了可重用代码、让代码更容易被他人理解、保证代码可靠性
- 单例设计模式
  - **目的** —— 让 **类** 创建的对象，在系统中 **只有** **唯一的一个实例**
  - 每一次执行 `类名()` 返回的对象，**内存地址是相同的**

单例设计模式的应用场景：**音乐播放** 对象、**回收站** 对象、**打印机** 对象

##### `__new__` 方法

- 使用 **类名()** 创建对象时，`Python` 的解释器 **首先** 会 调用 `__new__` 方法为对象 **分配空间**
-  `__new__` 是一个 由 `object` 基类提供的 **内置的静态方法**( 无需使用 staticmethod 装饰器修饰 )，主要作用有两个： 
  - 1) 在内存中为对象 **分配空间**
  - 2) **返回** 对象的引用 （内存的地址）
- `Python` 的解释器获得对象的 **引用** 后，将引用作为 **第一个参数**，传递给 `__init__` 方法

> 重写 `__new__` 方法 的代码非常固定！

- 重写 `__new__` 方法 **一定要** `return super().__new__(cls)`，否则 Python 的解释器 **得不到** 分配了空间的 **对象引用**，**就不会调用对象的初始化方法**
- 注意：`__new__` 是一个静态方法，在调用时需要 **主动传递** `cls` 参数

学习 `__new__` 方法是为了改造分配空间的方法，目的是使用类名创建对象时，只会创建一个对象，实现单例设计模型。

```python
class MusicPlayer(object):
    def __new__(cls, *args, **kwargs):
        # 1. 创建对象时，new方法会被自动调用
        print("创建对象，分配空间")
        # 2. 为对象分配空间, 返回对象的引用
        return super().__new__(cls)
    def __init__(self):
        print("播放器初始化")
# 创建播放器对象
player = MusicPlayer()
print(player)
```

##### Python 中的单例

1. 定义一个 **类属性**，初始值是 `None`，用于记录 **单例对象的引用**
2. 重写 `__new__` 方法
3. 如果 **类属性** `is None`，调用父类方法分配空间，并在类属性中记录结果
4. 返回 **类属性** 中记录的 **对象引用**

实现：`singleton_pattern.py`

存在问题：对 `__new__` 方法改造之后，每次都会得到 **第一次被创建对象的引用** ， 但是**初始化方法还会被再次调用** 

改进：让 **初始化动作** 只被 **执行一次**

**解决办法：**

1. 定义一个类属性 `init_flag` 标记是否 **执行过初始化动作**，初始值为 `False`
2. 在 `__init__` 方法中，判断 `init_flag`，如果为 `False` 就执行初始化动作
3. 然后将 `init_flag` 设置为 `True`
4. 这样，再次 **自动** 调用 `__init__` 方法时，**初始化动作就不会被再次执行** 了

```python
class MusicPlayer(object):
    instance = None  # 记录第一个被创建对象的引用
    init_flag = False  # 记录是否执行过初始化动作
    def __new__(cls, *args, **kwargs):
        if cls.instance is None:  # 1. 判断类属性是否是空对象
            cls.instance = super().__new__(cls)  # 2. 调用父类的方法，为第一个对象分配空间
        return cls.instance  # 3. 返回类属性保存的对象引用
    def __init__(self):
        if MusicPlayer.init_flag:  # 1. 判断是否执行过初始化动作
            return
        print("初始化播放器")  # 2. 如果没有执行过，在执行初始化动作
        MusicPlayer.init_flag = True  # 3. 修改类属性的标记
# 创建多个对象
player1 = MusicPlayer()
print(player1)
player2 = MusicPlayer()
print(player2)
```

#### 异常

- 程序在运行时，如果 `Python 解释器` **遇到** 到一个错误，**会停止程序的执行，并且提示一些错误信息**，这就是 **异常**
- **程序停止执行并且提示错误信息** 这个动作，我们通常称之为：**抛出(raise)异常**

>  *程序开发时，很难将* **所有的特殊情况** *都处理的面面俱到，通过* **异常捕获** 可以针对突发事件做集中的处理，从而保证程序的 **稳定性和健壮性** 

##### 捕获异常

1. 简单的捕获异常语法

   在程序开发中，如果 **对某些代码的执行不能确定是否正确**，可以增加 `try(尝试)` 来 **捕获异常**

   ```python
   try:
       尝试执行的代码 # num = int(input("请输入数字："))
   except:
       出现错误的处理 # print("请输入正确的数字")
   print("-" * 50)
   ```

   - `try`：下方编写要尝试代码，不确定是否能够正常执行的代码
   - `except`：下方编写尝试失败的代码，错误的处理代码
   - 无论是否出错，后续代码会正常执行

2. 错误类型捕获，及捕获未知错误

   在程序执行时，可能会遇到 **不同类型的异常**，并且需要 **针对不同类型的异常，做出不同的响应**，这个时候，就需要捕获错误类型了

   ```python
   try:
       尝试执行的代码
       # num = int(input("请输入整数："))
       # result = 8 / num
   except 错误类型1: # ValueError
       针对错误类型1，对应的代码处理
       # print("请输入正确的整数")
   except (错误类型2, 错误类型3): # ZeroDivisionError
       针对错误类型2 和 3，对应的代码处理
       # print("除 0 错误")
   except Exception as result:
       打印错误信息
       # print("未知错误 %s" % result)
   ```

   - 当 `Python` 解释器 **抛出异常** 时，**最后一行错误信息的第一个单词，就是错误类型**
   - 在开发时，**要预判到所有可能出现的错误**，还是有一定难度的。如果希望程序 **无论出现任何错误**，都不会因为 `Python` 解释器 **抛出异常而被终止**，可以再增加一个 `except`

3. 异常捕获完整语法

   ```python
   try:
       尝试执行的代码
   except 错误类型1:
       针对错误类型1，对应的代码处理
   except 错误类型2:
       针对错误类型2，对应的代码处理
   except (错误类型3, 错误类型4):
       针对错误类型3 和 4，对应的代码处理
   except Exception as result:
       打印错误信息
   else:
       没有异常才会执行的代码
       # print("正常执行")
   finally:
       无论是否有异常，都会执行的代码
       # print("执行完成，但是不保证正确")
   ```

   - `else` 只有在没有异常时才会执行的代码
   - `finally` 无论是否有异常，都会执行的代码

##### 异常的传递性

- **异常的传递** —— 当 **函数/方法** 执行 **出现异常**，会 **将异常传递** 给 函数/方法 的 **调用一方**
- 如果 **传递到主程序**，仍然 **没有异常处理**，程序才会被终止

> 提示：
>
> - 在开发中，可以在主函数中增加 **异常捕获**
> - 而在主函数中调用的其他函数，只要出现异常，都会传递到主函数的 **异常捕获** 中
> - 这样就不需要在代码中，增加大量的 **异常捕获**，能够保证代码的整洁

```python
def demo1():
    return int(input("请输入一个整数："))
def demo2():
    return demo1()
# 利用异常的传递性，在主程序中捕获异常
try:
    print(demo2())
except ValueError:
    print("请输入正确的整数")
except Exception as result:
    print("未知错误 %s" % result)
```

##### 抛出 raise 异常

- 在开发中，除了 **代码执行出错** `Python` 解释器会 **抛出** 异常之外
- 还可以根据 **应用程序** **特有的业务需求** **主动抛出异常**

`Python` 中提供了一个 `Exception` **异常类**，在开发时，如果满足 **特定业务需求时**，希望 **抛出异常**，可以：

1. **创建** 一个 `Exception` 的 **对象**
2. 使用 `raise` **关键字** 抛出 **异常对象**

```python
# 定义 input_password 函数，提示用户输入密码
# 如果用户输入长度 < 8，抛出异常
# 如果用户输入长度 >=8，返回输入的密码
def input_password():
    # 1. 提示用户输入密码
    pwd = input("请输入密码：")
    # 2. 判断密码长度，如果长度 >= 8，返回用户输入的密码
    if len(pwd) >= 8:
        return pwd
    # 3. 密码长度不够，需要抛出异常
    # 1> 创建异常对象 - 使用异常的错误信息字符串作为参数
    ex = Exception("密码长度不够")
    # 2> 抛出异常对象
    raise ex

try:
    user_pwd = input_password()
    print(user_pwd)
except Exception as result:
    print("发现错误：%s" % result)
```

#### 模块

> **模块是 Python 程序架构的一个核心概念**

- 每一个以扩展名 `py` 结尾的 `Python` 源代码文件都是一个 **模块**
- **模块名** 同样也是一个 **标识符**，需要符合标识符的命名规则
- 在模块中定义的 **全局变量** 、**函数**、**类** 都是提供给外界直接使用的 **工具**

导入之后，通过 `模块名.` 使用 **模块提供的工具** —— **全局变量、函数、类**

> 如果 **两个模块**，存在 **同名的函数**，那么 **后导入模块的函数**，会 **覆盖掉先导入的函数**

- 开发时 `import` 代码应该统一写在 **代码的顶部**，更容易及时发现冲突
- 一旦发现冲突，可以使用 `as` 关键字 **给其中一个工具起一个别名**，模块别名 应该符合 **大驼峰命名法**

##### 模块的搜索顺序

`Python` 的解释器在 **导入模块** 时，会：

1. 搜索 **当前目录** 指定模块名的文件，**如果有就直接导入**
2. 如果没有，再搜索 **系统目录**

> 在开发时，给文件起名，不要和 **系统的模块文件** **重名**

`Python` 中每一个模块都有一个内置属性 `__file__` 可以 **查看模块** 的 **完整路径**

##### 原则： 每一个文件都应是可被导入的

- 一个 **独立的 `Python` 文件** 就是一个 **模块**
- 在导入文件时，文件中 **所有没有任何缩进的代码** 都会被执行一遍！
- 在实际开发中，每一个模块都是独立开发的，大多都有专人负责，开发人员通常会在模块下方增加一些测试代码
  - 仅在模块内使用，而被导入到其他文件中不需要执行

##### `__name__`属性

> `__name__` 属性可以做到，测试模块的代码 **只在测试情况下被运行**，而在 **被导入时不会被执行**！

- `__name__` 是 `Python` 的一个内置属性，记录着一个 **字符串**
- 如果 **是被其他文件导入的**，`__name__` 就是 **模块名**
- 如果 **是当前执行的程序** `__name__` 是 **`__main__`** (固定值)

```python
# 导入模块
# 定义全局变量
# 定义类
# 定义函数

# 在代码的最下方
def main():
    # ...
    pass

# 根据 __name__ 判断是否执行下方代码
if __name__ == "__main__":
    main()
```

#### 包（Package）

- **包** 是一个 **包含多个模块** 的 **特殊目录**
- 目录下有一个 **特殊的文件** `__init__.py`
- 包名的 **命名方式** 和变量名一致

**好处**：使用 `import 包名` 可以一次性导入 **包** 中 **所有的模块**

`__init__.py`：要在外界使用 **包** 中的模块，需要在 `__init__.py` 中指定 **对外界提供的模块列表**

```python
# 从 当前目录 导入 模块列表
from . import send_message
from . import receive_message
```

##### 发布模块

具体内容在 `发布模块.md`

#### 文件

- 计算机的 **文件**，就是存储在某种 **长期储存设备** 上的一段 **数据**
- 在计算机中，文件是以 **二进制** 的方式保存在磁盘上的

操作文件的套路非常固定，一共包含**三个步骤**：

1. 打开文件
2. 读、写文件
   - **读** 将文件内容读入内存
   - **写** 将内存内容写入文件
3. 关闭文件

在 `Python` 中要操作文件需要记住 1 个函数和 3 个方法

| 序号 | 函数/方法 | 说明                           |
| :--- | :-------- | :----------------------------- |
| 01   | open      | 打开文件，并且返回文件操作对象 |
| 02   | read      | 将文件内容读取到内存           |
| 03   | write     | 将指定内容写入文件             |
| 04   | close     | 关闭文件                       |

- `open` 函数负责打开文件，并且返回文件对象
- `read`/`write`/`close` 三个方法都需要通过 **文件对象** 来调用

##### read 方法 —— 读取文件

- `open` 函数的第一个参数是要打开的文件名（文件名区分大小写）

  - 如果文件 **存在**，返回 **文件操作对象**
  - 如果文件 **不存在**，会 **抛出异常**
- `read` 方法可以一次性 **读入** 并 **返回** 文件的 **所有内容**
- `close` 方法负责关闭文件

  - 如果 **忘记关闭文件**，**会造成系统资源消耗，而且会影响到后续对文件的访问**
- **注意**：`read` 方法执行后，会把 **文件指针** 移动到 **文件的末尾**

```python
# 1. 打开 - 文件名需要注意大小写
file = open("README")
# 2. 读取
text = file.read()
print(text)
# 3. 关闭
file.close()
```

##### 文件指针

- **文件指针** 标记 **从哪个位置开始读取数据**
- **第一次打开** 文件时，通常 **文件指针会指向文件的开始位置**
-  当执行了 `read` 方法后，**文件指针** 会移动到 **读取内容的末尾** 
  - 默认情况下会移动到 **文件末尾**

如果执行了一次 `read` 方法，读取了所有内容，那么再次调用 `read` 方法，不能获得内容。

##### 打开文件的方式

- `open` 函数默认以 **只读方式** 打开文件，并且返回文件对象

语法如下：

```python
f = open("文件名", "访问方式")
```

| 访问方式 | 说明                                                         |
| :------: | :----------------------------------------------------------- |
|    r     | 以**只读**方式打开文件。文件的指针将会放在文件的开头，这是**默认模式**。如果文件不存在，抛出异常 |
|    w     | 以**只写**方式打开文件。如果文件存在会被覆盖。如果文件不存在，创建新文件 |
|    a     | 以**追加**方式打开文件。如果该文件已存在，文件指针将会放在文件的结尾。如果文件不存在，创建新文件进行写入 |
|    r+    | 以**读写**方式打开文件。文件的指针将会放在文件的开头。如果文件不存在，抛出异常 |
|    w+    | 以**读写**方式打开文件。如果文件存在会被覆盖。如果文件不存在，创建新文件 |
|    a+    | 以**读写**方式打开文件。如果该文件已存在，文件指针将会放在文件的结尾。如果文件不存在，创建新文件进行写入 |

**提示**

- 频繁的移动文件指针，**会影响文件的读写效率**，开发中更多的时候会以 **只读**、**只写** 的方式来操作文件

**写入文件示例**

```python
# 打开文件
f = open("README", "w")
f.write("hello python！\n")
f.write("今天天气真好")
# 关闭文件
f.close()
```

##### 按行读取文件内容

- `read` 方法默认会把文件的 **所有内容** **一次性读取到内存**，如果文件太大，对内存的占用会非常严重

- `readline` 方法可以一次读取一行内容，方法执行后，会把 **文件指针** 移动到下一行，准备再次读取

##### 读取大文件的正确姿势

```python
# 打开文件
file = open("README")
while True:
    # 读取一行内容
    text = file.readline()
    # 判断是否读到内容
    if not text:
        break
    # 每读取一行的末尾已经有了一个 `\n`
    print(text, end="")
# 关闭文件
file.close()
```

##### os 模块

文件/目录的常用管理操作 -- 导入 `os` 模块

文件操作

| 序号 | 方法名 | 说明       | 示例                              |
| :--- | :----- | :--------- | :-------------------------------- |
| 01   | rename | 重命名文件 | `os.rename(源文件名, 目标文件名)` |
| 02   | remove | 删除文件   | `os.remove(文件名)`               |

目录操作

| 序号 | 方法名     | 说明           | 示例                      |
| :--- | :--------- | :------------- | :------------------------ |
| 01   | listdir    | 目录列表       | `os.listdir(目录名)`      |
| 02   | mkdir      | 创建目录       | `os.mkdir(目录名)`        |
| 03   | rmdir      | 删除目录       | `os.rmdir(目录名)`        |
| 04   | getcwd     | 获取当前目录   | `os.getcwd()`             |
| 05   | chdir      | 修改工作目录   | `os.chdir(目标目录)`      |
| 06   | path.isdir | 判断是否是文件 | `os.path.isdir(文件路径)` |

> 提示：文件或者目录操作都支持 **相对路径** 和 **绝对路径**

##### 编码格式

文本文件存储的内容是基于 **字符编码** 的文件，常见的编码有 `ASCII` 编码，`UNICODE` 编码等

> Python 2.x 默认使用 `ASCII` 编码格式
> Python 3.x 默认使用 `UTF-8` 编码格式

`ASCII` 编码

- 计算机中只有 `256` 个 `ASCII` 字符
-  一个 `ASCII` 在内存中占用 **1 个字节** 的空间 ，`8` 个 `0/1` 的排列组合方式一共有 `256` 种，也就是 `2 ** 8`

`UTF-8` 编码格式

- 计算机中使用 **1~6 个字节** 来表示一个 `UTF-8` 字符，涵盖了 **地球上几乎所有地区的文字**
- 大多数汉字会使用 **3 个字节** 表示
- `UTF-8` 是 `UNICODE` 编码的一种编码格式

在 Python 2.x 文件的 **第一行** 增加以下代码，解释器会以 `utf-8` 编码来处理 python 文件

```python
# -*- coding:utf-8 -*-
```

在 `Python 2.x` 中，即使指定了文件使用 `UTF-8` 的编码格式，但是在遍历字符串时，仍然会 **以字节为单位遍历** 字符串

要能够 **正确的遍历字符串**，在定义字符串时，需要 **在字符串的引号前**，增加一个小写字母 `u`，告诉解释器这是一个 `unicode` 字符串（使用 `UTF-8` 编码格式的字符串）

```python
hello_str = u"hello世界"
```

#### `eval` 函数

`eval()` 函数十分强大 —— **将字符串** 当成 **有效的表达式** 来求值 并 **返回计算结果**

有效表达式是 将字符串的引号去掉，内容作为python代码

```python
# 基本的数学计算
In [1]: eval("1 + 1")
Out[1]: 2
# 字符串重复
In [2]: eval("'*' * 10")
Out[2]: '**********'
# 将字符串转换成列表
In [3]: type(eval("[1, 2, 3, 4, 5]"))
Out[3]: list
# 将字符串转换成字典
In [4]: type(eval("{'name': 'xiaoming', 'age': 18}"))
Out[4]: dict
# 计算器案例：提示用户输入一个 加减乘除混合运算，返回计算结果
input_str = input("请输入一个算术题：")
print(eval(input_str))
```

**不要滥用 `eval`**

> 在开发时千万不要使用 `eval` 直接转换 `input` 的结果

计算器输入  `__import__('os').system('ls') ` 可直接执行命令

`os.system("终端命令")`
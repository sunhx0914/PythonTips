Tips:

#### 0 介绍

**计算机不能直接理解任何除机器语言以外的语言**，所以必须要把程序员所写的程序语言翻译成机器语言，计算机才能执行程序。**将其他语言翻译成机器语言的工具，被称为编译器**

编译器翻译的方式有两种：一个是**编译**，另外一个是**解释**。两种方式之间的区别在于**翻译时间点的不同**。当编译器**以解释方式运行的时候**，也称之为**解释器**

![53453453543](https://user-images.githubusercontent.com/51505633/78670200-fb8ccb00-790f-11ea-8ef8-4654895ddb11.jpg)

* **编译型语言**：程序在执行之前需要一个专门的编译过程，把程序编译成为机器语言的文件，运行时不需要重新翻译，直接使用编译的结果就行了。程序执行效率高，依赖编译器，跨平台性差些。如 C、C++
* **解释型语言**：解释型语言编写的程序不进行预先编译，以文本方式存储程序代码，会将代码一句一句直接运行。在发布程序时，看起来省了道编译工序，但是在运行程序的时候，必须先解释再运行

1 编译型语言和解释型语言对比

* **速度** —— 编译型语言比解释型语言执行速度快
* **跨平台性** —— 解释型语言比编译型语言跨平台性好

Python 解释器内运行 import this

* Python 是**完全面向对象的语言**
  * **函数**、**模块**、**数字**、**字符串**都是对象，**在 Python 中一切皆对象**
  * 完全支持继承、重载、多重继承
  * 支持重载运算符，也支持泛型设计
* Python **拥有一个强大的标准库**，Python 语言的核心只包含 **数字**、**字符串**、**列表**、**字典**、**文件** 等常见类型和函数，而由 Python 标准库提供了 **系统管理**、**网络通信**、**文本处理**、**数据库接口**、**图形系统**、**XML 处理** 等额外的功能
* Python 社区提供了**大量的第三方模块**，使用方式与标准库类似。它们的功能覆盖 **科学计算**、**人工智能**、**机器学习**、**Web 开发**、**数据库接口**、**图形系统** 多个领域

交互式运行 Python 程序

IPython 是一个 python 的 **交互式 shell**，比默认的 `python shell` 好用得多

1.  **CPU** 把 **代码、Python 解释器的程序** 复制到 **内存** 中
2. **Python 解释器** 根据语法规则，**从上向下** 让 **CPU** 翻译 **Python 程序中的代码**
3. **CPU** 负责执行翻译完成的代码

#### 1 运算符

//  取整除  返回除法的整数部分（商） 9 // 2 输出结果 4

**  幂  又称次方、乘方，2 ** 3 = 8

在 Python 中 `*` 运算符还可以用于字符串，计算结果就是字符串重复指定次数的结果，eg："-" * 50

#### 2 变量、判断、循环

真True  非 0数 —— **非零即真**

如果变量是 bool 型，在计算时True 对应的数字是 1

* 如果希望输出文字信息的同时，**一起输出** **数据**，就需要使用到 **格式化操作符**
* `%` 被称为 **格式化操作符**，专门用于处理字符串中的格式
  * 包含 `%` 的字符串，被称为 **格式化字符串**
  * `%` 和不同的 **字符** 连用，**不同类型的数据** 需要使用 **不同的格式化字符**

| 格式化字符 | 含义                                                         |
| ---------- | ------------------------------------------------------------ |
| %s         | 字符串                                                       |
| %d         | 有符号十进制整数，`%06d` 表示输出的整数显示位数，不足的地方使用 `0` 补全 |
| %f         | 浮点数，`%.2f` 表示小数点后只显示两位                        |
| %%         | 输出 `%`                                                     |

* 语法格式如下：

```python
print("格式化字符串" % 变量1)

print("格式化字符串" % (变量1, 变量2...))

scale = 0.8
print("数据比例是 %.2f%%" % (scale * 100))
# 数据比例是 80.00%
```

标示符可以由 **字母**、**下划线** 和 **数字** 组成，**不能以数字开头**，**不能与关键字重名**

**关键字** 就是在 `Python` 内部已经使用的标识符

通过以下命令可以查看 `Python` 中的关键字

```python
import keyword
print(keyword.kwlist)
```

在 `Python` 中，如果 **变量名** 需要由 **二个** 或 **多个单词** 组成时，可以按照以下方式命名

1. 每个单词都使用小写字母、单词与单词之间使用 **`_`下划线** 连接，例如：`first_name`、`last_name`、`qq_number`、`qq_password`

2. 驼峰命名法

   **小驼峰式命名法**，第一个单词以小写字母开始，后续单词的首字母大写例如：`firstName`、`lastName`

   **大驼峰式命名法**，每一个单词的首字母都采用大写字母，例如：`FirstName`、`LastName`、`CamelCase` 

**elif** 的应用场景是：**同时** 判断 **多个条件**，所有的条件是 **平级** 的

**if 的嵌套** 的应用场景就是：**在之前条件满足的前提下，再增加额外的判断**

在使用 continue 之前，同样应该修改计数器

print 参数 `end=""` 表示向控制台输出内容结束之后，不会换行

#### 3 函数

在开发中，如果希望给函数添加注释，应该在 **定义函数** 的下方，使用 **连续的三对引号**，在其之间编写对函数的说明文字。在 **函数调用** 位置，使用快捷键 `CTRL + Q` 可以查看函数的说明信息

* **形参**：**定义** 函数时的参数，是用来接收参数用的，在函数内部 **作为变量使用**
* **实参**：**调用** 函数时的参数，是用来把数据传递到 **函数内部** 用的

* **模块** 就好比是 **工具包**，要想使用这个工具包中的工具，就需要 **导入 import** 这个模块
* 每一个以扩展名 `py` 结尾的 `Python` 源代码文件都是一个 **模块**
* 在模块中定义的 **全局变量** 、 **函数** 都是模块能够提供给外界直接使用的工具

注意：如果在给 Python 文件起名时，**以数字开头** 是无法在 `PyCharm` 中通过导入这个模块的

`.pyc` 文件是由 Python 解释器将 **模块的源码** 转换为 **字节码**，作为一种启动 **速度的优化**

* `Python` 在解释源程序时是分成两个步骤的
  1. 首先处理源代码，**编译** 生成一个二进制 **字节码**
  2. 再对 **字节码** 进行处理，才会生成 CPU 能够识别的 **机器码**

* 有了模块的字节码文件之后，下一次运行程序时，如果在 **上次保存字节码之后** 没有修改过源代码，Python 将会加载 .pyc 文件并跳过编译这个步骤
* 当 `Python` 重编译时，它会自动检查源文件和字节码文件的时间戳
* 如果你又修改了源代码，下次程序运行时，字节码将自动重新创建

#### 4 高级变量类型

Python 中数据类型可以分为 **数字型** 和 **非数字型**

数字型：整型、浮点型、布尔型、复数型

非数字型：字符串、列表、元组、字典

![list](https://user-images.githubusercontent.com/51505633/78681308-27fc1380-791f-11ea-80c0-56a589c689df.jpg)

clear() 方法可以清空列表

**方法** 和函数类似，需要通过 **对象** 来调用，表示针对这个 **对象** 要做的操作

![tuple](https://user-images.githubusercontent.com/51505633/78682826-13207f80-7921-11ea-8e2d-76873d05a63c.jpg)

元组中 **只包含一个元素** 时，需要 **在元素后面添加逗号**

格式化字符串后面的 `()` 本质上就是一个元组

```python
info = ("zhangsan", 18)
print("%s 的年龄是 %d" % info)
```

元组和列表之间的转换：list(元组)、tuple(列表)

![dict](https://user-images.githubusercontent.com/51505633/78683626-1cf6b280-7922-11ea-86ec-3bff1b7b64ed.jpg)

* 使用 **键值对** 存储数据，键值对之间使用 `,` 分隔
* **键** `key` 是索引
* **值** `value` 是数据
* **键** 和 **值** 之间使用 `:` 分隔
* **键必须是唯一的**
* **值** 可以取任何数据类型，但 **键** 只能使用 **字符串**、**数字**或 **元组**
* 被合并的字典中包含已经存在的键值对，会覆盖原有的键值对

在开发中，更多的应用场景是：

* 使用 **多个键值对**，存储 **描述一个 `物体` 的相关信息** —— 描述更复杂的数据信息
* 将 **多个字典** 放在 **一个列表** 中，再进行遍历，在循环体内部针对每一个字典进行 **相同的处理**

![str](https://user-images.githubusercontent.com/51505633/78683936-765ee180-7922-11ea-99e4-2bee08857911.jpg)

1) 判断类型 - 9

| 方法               | 说明                                                         |
| ------------------ | ------------------------------------------------------------ |
| string.isspace()   | 如果 string 中只包含空格，则返回 True                        |
| string.isalnum()   | 如果 string 至少有一个字符并且所有字符都是字母或数字则返回 True |
| string.isalpha()   | 如果 string 至少有一个字符并且所有字符都是字母则返回 True    |
| string.isdecimal() | 如果 string 只包含数字则返回 True，`全角数字`                |
| string.isdigit()   | 如果 string 只包含数字则返回 True，`全角数字`、`⑴`、`\u00b2` |
| string.isnumeric() | 如果 string 只包含数字则返回 True，`全角数字`，`汉字数字`    |
| string.istitle()   | 如果 string 是标题化的(每个单词的首字母大写)则返回 True      |
| string.islower()   | 如果 string 中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是小写，则返回 True |
| string.isupper()   | 如果 string 中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是大写，则返回 True |

2) 查找和替换 - 7

| 方法                                                    | 说明                                                         |
| ------------------------------------------------------- | ------------------------------------------------------------ |
| string.startswith(str)                                  | 检查字符串是否是以 str 开头，是则返回 True                   |
| string.endswith(str)                                    | 检查字符串是否是以 str 结束，是则返回 True                   |
| string.find(str, start=0, end=len(string))              | 检测 str 是否包含在 string 中，如果 start 和 end 指定范围，则检查是否包含在指定范围内，如果是返回开始的索引值，否则返回 `-1` |
| string.rfind(str, start=0, end=len(string))             | 类似于 find()，不过是从右边开始查找                          |
| string.index(str, start=0, end=len(string))             | 跟 find() 方法类似，不过如果 str 不在 string 会报错          |
| string.rindex(str, start=0, end=len(string))            | 类似于 index()，不过是从右边开始                             |
| string.replace(old_str, new_str, num=string.count(old)) | 把 string 中的 old_str 替换成 new_str，如果 num 指定，则替换不超过 num 次 |

3) 大小写转换 - 5

| 方法                | 说明                             |
| ------------------- | -------------------------------- |
| string.capitalize() | 把字符串的第一个字符大写         |
| string.title()      | 把字符串的每个单词首字母大写     |
| string.lower()      | 转换 string 中所有大写字符为小写 |
| string.upper()      | 转换 string 中的小写字母为大写   |
| string.swapcase()   | 翻转 string 中的大小写           |

4) 文本对齐 - 3

| 方法                 | 说明                                                         |
| -------------------- | ------------------------------------------------------------ |
| string.ljust(width)  | 返回一个原字符串左对齐，并使用空格填充至长度 width 的新字符串 |
| string.rjust(width)  | 返回一个原字符串右对齐，并使用空格填充至长度 width 的新字符串 |
| string.center(width) | 返回一个原字符串居中，并使用空格填充至长度 width 的新字符串  |

5) 去除空白字符 - 3

| 方法            | 说明                               |
| --------------- | ---------------------------------- |
| string.lstrip() | 截掉 string 左边（开始）的空白字符 |
| string.rstrip() | 截掉 string 右边（末尾）的空白字符 |
| string.strip()  | 截掉 string 左右两边的空白字符     |

6) 拆分和连接 - 5

| 方法                      | 说明                                                         |
| ------------------------- | ------------------------------------------------------------ |
| string.partition(str)     | 把字符串 string 分成一个 3 元素的元组 (str前面, str, str后面) |
| string.rpartition(str)    | 类似于 partition() 方法，不过是从右边开始查找                |
| string.split(str="", num) | 以 str 为分隔符拆分 string，如果 num 有指定值，则仅分隔 num + 1 个子字符串，str 默认包含 '\r', '\t', '\n' 和空格 |
| string.splitlines()       | 按照行('\r', '\n', '\r\n')分隔，返回一个包含各行作为元素的列表 |
| string.join(seq)          | 以 string 作为分隔符，将 seq 中所有的元素（的字符串表示）合并为一个新的字符串 |

切片：适用于 **字符串**、**列表**、**元组**

**列表** 和 **元组** 都是 **有序** 的集合，都能够 **通过索引值** 获取到对应的数据

`字符串[开始索引:结束索引:步长]`

1. 指定的区间属于 **左闭右开** 型 `[开始索引,  结束索引)`
2. 从头开始，**开始索引** **数字可以省略，冒号不能省略**
3. 到末尾结束，**结束索引** **数字可以省略，冒号不能省略**
4. 步长默认为 `1`，如果连续切片，**数字和冒号都可以省略**

字符串的逆序（面试题）：`print(num_str[::-1])`

Python 包含了以下内置函数：

| 函数      | 描述                 | 备注                                |
| --------- | -------------------- | ----------------------------------- |
| len(item) | 计算容器中元素个数   |                                     |
| del(item) | 删除变量             | del 有两种方式  关键字方式 函数方式 |
| max(item) | 返回容器中元素最大值 | 如果是字典，只针对 key 比较         |
| min(item) | 返回容器中元素最小值 | 如果是字典，只针对 key 比较         |

**注意**

|    运算符    | Python 表达式         | 结果                         | 描述           | 支持的数据类型           |
| :----------: | --------------------- | ---------------------------- | -------------- | ------------------------ |
|      +       | [1, 2] + [3, 4]       | [1, 2, 3, 4]                 | 合并           | 字符串、列表、元组       |
|      *       | ["Hi!"] * 4           | ['Hi!', 'Hi!', 'Hi!', 'Hi!'] | 重复           | 字符串、列表、元组       |
|      in      | 3 in (1, 2, 3)        | True                         | 元素是否存在   | 字符串、列表、元组、字典 |
|    not in    | 4 not in (1, 2, 3)    | True                         | 元素是否不存在 | 字符串、列表、元组、字典 |
| > >= == < <= | (1, 2, 3) < (2, 2, 3) | True                         | 元素比较       | 字符串、列表、元组       |

**注意：**

* `in` 在对 **字典** 操作时，判断的是 **字典的键**
* `in` 和 `not in` 被称为 **成员运算符**

TODO 注释：在 `#` 后跟上 `TODO`，用于标记需要去做的工作

```python
# TODO(作者/邮件) 显示系统菜单
```

在 `return` 后没有跟任何内容，只是表示该函数执行到此就不再执行后续的代码

#### 5 变量进阶

引用：

变量 和 数据 都是保存在 **内存** 中的。

在 `Python` 中 **函数 的 参数传递** 以及 **返回值** 都是靠 **引用** 传递的。

* **变量** 和 **数据** 是分开存储的，**数据** 保存在内存中的一个位置，**变量** 中保存着数据在内存中的地址
* **变量** 中 **记录数据的地址**，就叫做 **引用**
* 使用 `id()` 函数可以查看变量中保存数据所在的 **内存地址**

> 注意：如果变量已经被定义，当给一个变量赋值的时候，本质上是 **修改了数据的引用**，变量 **不再** 对之前的数据引用，变量 **改为** 对新赋值的数据引用。

```python
a = 2
b = a
```

将变量 `a` 的值赋值给 `b`，`a` 和 `b` 都指向了 2

```python
def test(num):
    print("-" * 50)
    print("%d 在函数内的内存地址是 %x" % (num, id(num)))
    result = 100
    print("返回值 %d 在内存中的地址是 %x" % (result, id(result)))
    print("-" * 50)
    # 将字符串变量返回，返回的是数据的引用，而不是数据本身
    return  result

a = 10
print("调用函数前 内存地址是 %x" % id(a))
# 调用 test 函数，本质上传递的是实参保存数据的引用，而不是实参保存的数据！
r = test(a)
print("调用函数后 实参内存地址是 %x" % id(a))
print("调用函数后 返回值内存地址是 %x" % id(r))
```

可变和不可变类型：

* **不可变类型**，内存中的数据不允许被修改：数字类型 `int`, `bool`, `float`, `complex`；字符串 `str`；元组 `tuple`
* **可变类型**，内存中的数据可以被修改：列表 `list`；字典 `dict`

> 1. 字典的 `key` **只能使用不可变类型的数据**
> 2. **可变类型**的数据变化，是通过 **方法** 来实现的
> 3. 如果给一个可变类型的变量，赋值了一个新的数据，**引用会修改**

哈希 `(hash)`：

* `Python` 中内置有一个名字叫做 `hash(o)` 的函数，接收一个 **不可变类型** 的数据作为 **参数**，**返回** 结果是一个 **整数**。

* `哈希` 是一种 **算法**，其作用就是提取数据的 **特征码（指纹）**，**相同的内容** 得到 **相同的结果**，**不同的内容** 得到 **不同的结果**。

* 在 `Python` 中，设置字典的 **键值对** 时，会首先对 `key` 进行 `hash` 已决定如何在内存中保存字典的数据，以方便 **后续** 对字典的操作：**增、删、改、查**。

  `key` 必须是不可变类型数据，`value` 可以是任意类型的数据。

局部变量和全局变量：

* **局部变量** 是在 **函数内部** 定义的变量，**只能在函数内部使用**，用于**临时** 保存 **函数内部需要使用的数据**。局部变量在 **函数执行时** 才会被创建，**函数执行结束后** 局部变量 **被系统回收**
* **全局变量** 是在 **函数外部定义** 的变量（没有定义在某一个函数内），**所有函数** 内部 **都可以使用这个变量**。

> 注意：
>
> 同名局部变量会优先使用，若无才使用全局变量
>
> 函数不能直接修改 `全局变量的引用`：想要在函数中赋值修改时，相当于定义同名局部变量。
>
> 在函数中需要修改全局变量，需要使用 `global` 进行声明：`global num`
>
> 应 **将全局变量定义在其他函数的上方**，全局变量名前应该增加 `g_` 或者 `gl_` 的前缀

#### 6 函数进阶

函数根据 **有没有参数** 以及 **有没有返回值**，可以 **相互组合**，一共有 **4 种** 组合形式。

1. 如果函数 **内部处理的数据不确定**，就需要将外界的数据以参数传递到函数内部
2. 如果一个函数 **执行完成后，需要向外界汇报执行结果**，就需要增加函数的返回值

函数返回的类型是元组，小括号可以省略

在 `Python` 中，可以 **将一个元组** 使用 **赋值语句** 同时赋值给 **多个变量**

##### 面试题 —— 交换两个数字

```python
# 要求：两个整数变量 a = 6, b = 100 的值
# 解法 1 - 使用临时变量
c = b
b = a
a = c
# 解法 2 - 不使用临时变量
a = a + b
b = a - b
a = a - b
# 解法 3 - Python 专有，利用元组
a, b = b, a
```

- 在函数内部，针对参数使用 **赋值语句**，不会影响调用函数时传递的 **实参变量**。
- 如果传递的参数是 **可变类型**，在函数内部，使用 **方法** 修改了数据的内容，**同样会影响到外部的数据**。

##### 面试题 —— +=

* 在 `python` 中，列表变量调用 `+=` 本质上是在执行列表变量的 `extend` 方法，不会修改变量的引用

```python
def demo(num, num_list):
    print("函数内部代码")
    num += num
    num_list += num_list
    # 本质上是：num_list.extend(num_list) 由于是调用方法，所以不会修改变量的引用
    # 函数执行结束后，外部数据同样会发生变化
    print(num)  # 18
    print(num_list)  # [1, 2, 3, 1, 2, 3]
    print("函数代码完成")

gl_num = 9
gl_list = [1, 2, 3]
demo(gl_num, gl_list)
print(gl_num)  # 9
print(gl_list)  # [1, 2, 3, 1, 2, 3]
```

函数参数：

位置参数： 位置参数要求调用时传入函数的参数必须和定义时的位置和个数一致，即一一对应，不可缺省 

缺省参数（默认参数）：

* 定义函数时，可以给 **某个参数** 指定一个**默认值**，具有默认值的参数就叫做 **缺省参数**
* 调用函数时，如果没有传入 **缺省参数** 的值，则在函数内部使用定义函数时指定的 **参数默认值**
* 函数的缺省参数，**将常见的值设置为参数的缺省值**，从而 **简化函数的调用**

**提示**

1. 缺省参数，需要使用 **最常见的值** 作为默认值！如果一个参数的值不能确定，则不应该设置默认值，具体的数值在调用函数时，由外界传递！
2. **必须保证** **带有默认值的缺省参数** **在参数列表末尾**。
3. 在 **调用函数时**，如果有 **多个缺省参数**，**需要指定参数名**

多值参数（可变参数、关键字参数）：

一般在给多值参数命名时，**习惯**使用以下两个名字：

* `*args` -- 可变参数，存放 **元组** 参数，`args` 是 `arguments` 的缩写，有变量的含义
* `**kwargs` -- 关键字参数，存放 **字典** 参数，`kw` 是 `keyword` 的缩写，`kwargs` 可以记忆 **键值对参数**

 **参数位置排列顺序：位置参数，默认参数，可变参数，关键字参数**

##### 元组和字典的拆包

* 在调用带有多值参数的函数时，如果希望：
  * 将一个 **元组变量**，直接传递给 `args`
  * 将一个 **字典变量**，直接传递给 `kwargs`
* 就可以使用 **拆包**，简化参数的传递，**拆包** 的方式是：
  * 在 **元组变量前**，增加 **一个** `*`
  * 在 **字典变量前**，增加 **两个** `*`

```python
def demo(*args, **kwargs):
    print(args)
    print(kwargs)

# 需要将一个元组变量/字典变量传递给函数对应的参数
gl_nums = (1, 2, 3)
gl_xiaoming = {"name": "小明", "age": 18}

demo(gl_nums, gl_dict)
'''输出
((1, 2, 3), {'name': '小明', 'age': 18})
{}'''
# 拆包语法，简化元组变量/字典变量的传递
demo(*gl_nums, **gl_dict)
'''输出
(1, 2, 3)
{'name': '小明', 'age': 18}'''
demo(1, 2, 3, name="小明", age=18)
'''输出
(1, 2, 3)
{'name': '小明', 'age': 18}'''
```

##### 递归

**特点**：**一个函数** **内部** **调用自己**

**代码特点**：

1. 函数内部的 **代码** 是相同的，只是针对 **参数** 不同，**处理的结果不同**
2. 当 **参数满足一个条件** 时，函数不再执行（**这个非常重要**，通常被称为递归的出口，否则 **会出现死循环**！）

示例：

```python
def sum_numbers(num):
    print(num)
    # 递归的出口很重要，否则会出现死循环
    if num == 1:
        return
    sum_numbers(num - 1)

sum_numbers(3)
```

递归案例 —— 计算数字累加：

```python
# 需求
# 1. 定义一个函数 sum_numbers
# 2. 能够接收一个 num 的整数参数
# 3. 计算 1 + 2 + ... num 的结果
def sum_numbers(num):
    if num == 1:
        return 1
    # 假设 sum_numbers 能够完成 num - 1 的累加
    temp = sum_numbers(num - 1)
    # 函数内部的核心算法就是 两个数字的相加
    return num + temp

print(sum_numbers(2))
```

![RecursiveFunction](https://user-images.githubusercontent.com/51505633/78697315-36542a80-7933-11ea-91bc-a04c907e5b64.jpg)

> 提示：递归是一个 **编程技巧**，初次接触递归会感觉有些吃力！在处理 **不确定的循环条件时**，格外的有用，例如：**遍历整个文件目录的结构**

#### 7 面向对象

**面向对象编程** —— `Object Oriented Programming` 简写 `OOP` 

**面相过程** —— **怎么做**？

1. 把完成某一个需求的 `所有步骤` `从头到尾` 逐步实现
2. 根据开发需求，将某些 **功能独立** 的代码 **封装** 成一个又一个 **函数**
3. 最后完成的代码，就是顺序地调用 **不同的函数**

**面向对象** —— **谁来做**？

> 相比较函数，**面向对象** 是 **更大** 的 **封装**，根据 **职责** 在 **一个对象中 封装 多个方法**

1. 在完成某一个需求前，首先确定 **职责** —— **要做的事情（方法）**
2. 根据 **职责** 确定不同的 **对象**，在 **对象** 内部封装不同的 **方法**（多个）
3. 最后完成的代码，就是顺序地让 **不同的对象** 调用 **不同的方法**

**类** 和 **对象** 是 **面向对象编程的 两个 核心概念** 

**类** 是对一群具有 **相同 特征(属性)** 或者 **行为(方法)**** 的事物的一个统称，是抽象的，**不能直接使用** 

**对象** 是 **由类创建出来的一个具体存在**，可以直接使用

类和对象的关系：

- **类是模板**，**对象** 是根据 **类** 这个模板创建出来的，应该 **先有类，再有对象**
- 类只有一个，而对象可以有很多个
  - **不同的对象** 之间 **属性** 可能会各不相同
- **类** 中定义了什么 **属性和方法**，**对象** 中就有什么属性和方法，**不可能多，也不可能少**

设计一个类，通常需要满足一下三个要素：

1. **类名** 这类事物的名字（名词），**满足大驼峰命名法（首字母大写，无下划线）**
2. **属性** 这类事物具有什么样的特征
3. **方法** 这类事物具有什么样的行为（动词）

>  *提示：需求中没有涉及的属性或者方法在设计类时，不需要考虑* 

##### dir 内置函数

 Python 一切皆对象。 

使用内置函数 `dir` 传入 **标识符** / **数据**，可以查看对象内的 **所有属性及方法**

`__方法名__` 格式的方法是 `Python` 提供的 **内置方法 / 属性** 

类：

**方法** 的第一个参数必须是 `self`

##### 引用概念的强调

- 在 `Python` 中使用类 **创建对象之后**，`tom` 变量中 仍然记录的是 **对象在内存中的地址**
- 也就是 `tom` 变量 **引用** 了 **新建的对象**
- 使用 `print` 输出 **对象变量**，默认情况下，是能够输出这个变量 **引用的对象** 是 **由哪一个类创建的对象**，以及 **在内存中的地址**（**十六进制表示**）(结果同id()）

- `%d` 可以以 **10 进制** 输出数字
- `%x` 可以以 **16 进制** 输出数字

##### self

>  *由* **哪一个对象** *调用的方法，方法内的* `self` *就是* **哪一个对象的引用** 

- 在类封装的方法内部，`self` 就表示 **当前调用方法的对象自己**
- **调用方法时**，程序员不需要传递 `self` 参数
- 在方法内部
  - 可以通过 `self.` **访问对象的属性**
  - 也可以通过 `self.` **调用对象的其他方法**

##### 初始化方法

当使用 类名()创建对象时，会自动执行以下操作：

1. 为对象在内存中 **分配空间** —— 创建对象
2. 为对象的属性 **设置初始值** —— 初始化方法(`init`)

- 这个 **初始化方法** 就是 `__init__` 方法，`__init__` 是对象的**内置方法**

> `__init__` 方法是 **专门** 用来定义一个类 **具有哪些属性的方法**！

- 在 `__init__` 方法内部使用 `self.属性名 = 属性的初始值` 就可以 **定义属性**
- 定义属性之后，再使用类创建的对象，都会拥有该属性

##### `__del__ ` 和 `__str__`

当使用 `类名()` 创建对象时，为对象 **分配完空间**后，**自动** 调用 `__init__` 方法

当一个 **对象被从内存中销毁** 前，会 **自动** 调用 `__del__` 方法

如果希望在对象被销毁前，再做一些事情，可以考虑一下 `__del__`方法

一个对象从调用 `类名()` 创建，生命周期开始，`__del__` 方法一旦被调用，生命周期结束

`del tom  # del 关键字可以删除一个对象`

`__str__`方法，返回对象的描述信息（必须为字符串），print 函数自定义输出使用

##### 封装

1. 面向对象编程的 **第一步** —— 将 **属性** 和 **方法** **封装** 到一个抽象的 **类** 中
2. **外界** 使用 **类** 创建 **对象**，然后 **让对象调用方法**
3. **对象方法的细节** 都被 **封装** 在 **类的内部**

**同一个类** 创建的 **多个对象** 之间，**属性** 互不干扰！

**被使用的类**，通常应该先开发 

`return ` 后面为空 可不执行后续代码返回 

#####  一个对象的 **属性** *可以是* **另外一个类创建的对象** 。

> 如：需求1中
>
> 1. **士兵** **许三多** 有一把 **AK47**
> 2. **士兵** 可以 **开火**
> 3. **枪** 能够 **发射** 子弹
> 4. **枪** 装填 **装填子弹** —— **增加子弹数量**

 假设：每一个新兵 都 **没有枪** 

在定义属性时，如果 **不知道设置什么初始值**，可以设置为 `None`

- `None` **关键字** 表示 **什么都没有**
- 表示一个 **空对象**，**没有方法和属性，是一个特殊的常量**
- 可以将 `None` 赋值给任何一个变量

在实例化类后可以复制给属性 `xusanduo.gun = ak47`

1. 在定义属性时，如果 **不知道设置什么初始值**，可以设置为 `None`
2. 在 **封装的** 方法内部，还可以让 **自己的** **使用其他类创建的对象属性** 调用已经 **封装好的方法**

##### 身份运算符

身份运算符用于 **比较** 两个对象的 **内存地址** 是否一致 —— **是否是对同一个对象的引用**

- 在 `Python` 中针对 `None` 比较时，建议使用 `is` 判断

| 运算符 | 描述                                      | 实例                            |
| :----- | :---------------------------------------- | :------------------------------ |
| is     | is 是判断两个标识符是不是引用同一个对象   | x is y，类似 id(x) == id(y)     |
| is not | is not 是判断两个标识符是不是引用不同对象 | x is not y，类似 id(a) != id(b) |

is 与 == 区别：`is` 用于判断 **两个变量 引用对象是否为同一个** ；`==` 用于判断 **引用变量的值** 是否相等。

##### 私有属性和私有方法

**对象** 的 **某些属性或方法** 可能只希望 **在对象的内部被使用**，而 **不希望在外部被访问到**，**私有属性** 就是 **对象** 不希望公开的 **属性**，**私有方法** 就是 **对象** 不希望公开的 **方法**

在 **定义属性或方法时**，在 **属性名或者方法名前** 增加 **两个下划线**，定义的就是 **私有** 属性或方法

- 在对象的方法内部，是可以访问对象的私有属性的
- 私有属性，私有方法，在外界不能够被直接访问

##### 伪私有属性和私有方法

> 提示：在日常开发中，**不要使用这种方式**，**访问对象的 私有属性 或 私有方法**

`Python` 中，并没有 **真正意义** 的 **私有**

- 在给 **属性**、**方法** 命名时，实际是对 **名称** 做了一些特殊处理，使得外界无法访问到
- **处理方式**：在 **名称** 前面加上 `_类名` => `_类名__名称`

##### 继承


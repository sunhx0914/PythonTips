### 就业班

#### 0 网络编程

所谓的网络编程就是，让在不同的电脑上的软件能够进行数据传递，即进程之间的通信

##### ip地址

ip地址：用来在网络中标记一台电脑，比如192.168.1.1；在本地局域网上是唯一的。

##### 端口

端口是通过端口号来标记的，端口号只有整数，范围是从0到65535 

端口号不是随意使用的，而是按照一定的规定进行分配。这里不做详细讲解，只介绍一下知名端口和动态端口。

知名端口是众所周知的端口号，范围从0到1023，80端口分配给HTTP服务，21端口分配给FTP服务

动态端口的范围是从1024到65535，动态分配是指当一个系统程序或应用程序程序需要网络通信时，它向主机申请一个端口，主机从可用的端口号中分配一个供它使用。当这个程序关闭时，同时也就释放了所占用的端口号

> 端口有什么用呢 ？ 我们知道，一台拥有IP地址的主机可以提供许多服务，比如HTTP（万维网服务）、FTP（文件传输）、SMTP（电子邮件）等，这些服务完全可以通过1个IP地址来实现。那么，主机是怎样区分不同的网络服务呢？显然不能只靠IP地址，因为IP地址与网络服务的关系是一对多的关系。实际上是**通过“IP地址+端口号”来区分不同的服务的**。 需要注意的是，**端口并不是一一对应的**。比如你的电脑作为客户机访问一台WWW服务器时，WWW服务器使用“80”端口与你的电脑通信，但你的电脑则可能使用“3457”这样的端口。 
>
> ip用于区分主机，端口用于区分服务

##### socket

不同电脑上的进程之间如何通信：首要解决的问题是如何唯一标识一个进程。

TCP/IP协议族解决了这个问题，网络层的 **ip地址** 可以唯一标识网络中的主机，而传输层的 **协议+端口** 可以唯一标识主机中的应用进程（进程）。

socket(简称 `套接字`) 是进程间通信的一种方式，它与其他进程间通信的一个主要不同是：它能实现不同主机间的进程间通信，我们网络上各种各样的服务大多都是基于 Socket 来完成通信的。

创建socket

在 Python 中 使用socket 模块的函数 socket 就可以完成：

**??? 函数 还是 类**

```python
import socket
socket.socket(AddressFamily, Type)
```

函数 socket.socket 创建一个 socket，该函数带有两个参数：

- Address Family：可以选择 AF_INET（用于 Internet 进程间通信） 或者 AF_UNIX（用于同一台机器进程间通信）,实际工作中常用AF_INET
- Type：套接字类型，可以是 SOCK_STREAM（流式套接字，主要用于 TCP 协议）或者 SOCK_DGRAM（数据报套接字，主要用于 UDP 协议）

创建一个tcp socket（tcp套接字）

```python
import socket
# 创建tcp的套接字
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
# ...这里是使用套接字的功能（省略）...
# 不用的时候，关闭套接字
s.close()
```

创建一个udp socket（udp套接字）

```python
import socket
# 创建udp的套接字
s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
# ...这里是使用套接字的功能（省略）...
# 不用的时候，关闭套接字
s.close()
```

套接字使用流程 与 文件的使用流程很类似：创建套接字 --> 使用套接字收/发数据 --> 关闭套接字

##### udp网络程序-发送数据

```python
from socket import *

# 1. 创建udp套接字
udp_socket = socket(AF_INET, SOCK_DGRAM)
# 2. 准备接收方的地址
# '192.168.1.103'表示目的ip地址   8080表示目的端口
dest_addr = ('192.168.1.103', 8080)  # 注意 是元组，ip是字符串，端口是数字
# 3. 从键盘获取数据
send_data = input("请输入要发送的数据:")
# 4. 发送数据到指定的电脑上的指定程序中
udp_socket.sendto(send_data.encode('utf-8'), dest_addr)  
# 数据需要为字节 字符串时可直接 b"..."
# 5. 关闭套接字
udp_socket.close()
```

一般情况下，在一台电脑上运行的网络程序有很多，为了不与其他的网络程序占用同一个端口号，往往在编程中， **udp的端口号一般不绑定** 。但是如果需要做成一个 **服务器端的程序** 的话，是需要绑定的。

##### udp网络程序-发送、接收数据

```python
from socket import *

# 1. 创建udp套接字
udp_socket = socket(AF_INET, SOCK_DGRAM)

# 2. 绑定本地的相关信息，如果一个网络程序不绑定，则系统会随机分配
local_addr = ('', 7788)  # ip地址和端口号，ip一般不用写，表示本机的任何一个ip
udp_socket.bind(local_addr)  # 必须绑定自己电脑的 ip 和 port

# 3. 准备接收方的地址
dest_addr = ('192.168.0.105', 4567)

# 4. 从键盘获取数据
send_data = input("请输入要发送的数据:")

# 5. 发送数据到指定的电脑上
udp_socket.sendto(send_data.encode('utf-8'), dest_addr)  # 编码

# 6. 等待接收对方发送的数据
recv_data = udp_socket.recvfrom(1024)  # 1024表示本次接收的最大字节数

# 6. 显示对方发送的数据
print(recv_data)
# 接收到的数据recv_data是一个元组
# 第1个元素是对方发送的数据
# 第2个元素是对方的ip和端口
# recv_data这个变量中存储的是一个元组(接收到的数据，(发送方的ip, port))
recv_msg = recv_data[0]  # 存储接收的数据
send_addr = recv_data[1]  # 存储发送方的地址信息
print(recv_msg.decode('gbk'))  # 解码 window 默认 GBK
print(send_addr)
print("%s:%s" % (str(send_addr), recv_msg.decode("gbk")))

# 7. 关闭套接字
udp_socket.close()
```

自己电脑多个端口试验时，ip 可为 127.0.0.1

recvfrom() 在没有收到数据时 堵塞

没调用recvfrom()  时收到的数据 操作系统暂存，调用时再读

套接字可同时收发 —— 全双工

单工、半双工、全双工

##### python3编码转换

`str->bytes:encode编码 ; bytes->str:decode解码`

字符串通过编码成为字节码，字节码通过解码成为字符串。

其中decode()与encode()方法可以接受参数，其声明分别为:

```python
bytes.decode(encoding="utf-8", errors="strict")
str.encode(encoding="utf-8", errors="strict")
```

其中的encoding是指在解码编码过程中使用的编码(此处指“编码方案”是名词)，errors是指错误的处理方案。





- 所谓`进程`指的是：运行的程序以及运行时用到的资源这个整体称之为进程（在讲解多任务编程时进行详细讲解）
- 所谓`进程间通信`指的是：运行的程序之间的数据共享
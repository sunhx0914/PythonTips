### 0 网络编程

所谓的网络编程就是，让在不同的电脑上的软件能够进行数据传递，即进程之间的通信

ip 地址：用来在网络中标记一台电脑，比如192.168.1.1；在本地局域网上是唯一的。

##### 端口

**端口是通过端口号来标记**的，端口号只有整数，范围是从**0到65535**，不是随意使用的，而是按照一定的规定进行分配。

**知名端口**是众所周知的端口号，**范围从0到1023**，80端口分配给HTTP服务，21端口分配给FTP服务

**动态端口**的范围是从**1024到65535**，动态分配是指当一个系统程序或应用程序程序需要网络通信时，它向主机申请一个端口，主机**从可用的端口号中分配一个**供它使用。当这个程序**关闭时**，同时也就**释放**了所占用的端口号

> 端口有什么用呢 ？ 我们知道，一台拥有IP地址的主机可以提供许多服务，比如HTTP（万维网服务）、FTP（文件传输）、SMTP（电子邮件）等，这些服务完全可以通过1个IP地址来实现。那么，主机是怎样区分不同的网络服务呢？显然不能只靠IP地址，因为IP地址与网络服务的关系是一对多的关系。实际上是**通过“IP地址+端口号”来区分不同的服务的**。 需要注意的是，**端口并不是一一对应的**。比如你的电脑作为客户机访问一台WWW服务器时，WWW服务器使用“80”端口与你的电脑通信，但你的电脑则可能使用“3457”这样的端口。 
>
> **ip用于区分主机，端口用于区分服务**

#### Socket

不同电脑上的进程之间如何通信：首要解决的问题是如何唯一标识一个进程。

TCP/IP协议族解决了这个问题，网络层的 **ip地址** 可以唯一标识网络中的主机，而传输层的 **协议+端口** 可以唯一标识主机中的应用进程（进程）。( 由于TCP/IP传输层的两个协议TCP和UDP是完全独立的两个软件模块，因此各自的端口号也相互独立，如TCP有一个255号端口，UDP也可以有一个255号端口，二者并不冲突。 )

socket(简称 `套接字`) 是进程间通信的一种方式，它与其他进程间通信的一个主要不同是：它能实现不同主机间的进程间通信，我们网络上各种各样的服务大多都是基于 Socket 来完成通信的。

##### 创建socket

在 Python 中  使用 socket 模块的 socket 函数来创建一个 socket 对象：

```python
import socket
socket.socket(AddressFamily, Type)
```

函数 socket.socket 创建一个 socket，该函数带有两个参数：

- Address Family：可以选择 AF_INET（用于 Internet 进程间通信） 或者 AF_UNIX（用于同一台机器进程间通信）,实际工作中常用AF_INET
- Type：套接字类型，可以是 SOCK_STREAM（流式套接字，主要用于 TCP 协议）或者 SOCK_DGRAM（数据报套接字，主要用于 UDP 协议）

##### 创建一个tcp socket（tcp套接字）

```python
import socket
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)  # 创建tcp的套接字
# ...这里是使用套接字的功能（省略）...
s.close()  # 不用的时候，关闭套接字
```

##### 创建一个udp socket（udp套接字）

```python
import socket
s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)  # 创建udp的套接字
# ...这里是使用套接字的功能（省略）...
s.close()  # 不用的时候，关闭套接字
```

套接字使用流程 与 文件的使用流程很类似：创建套接字 --> 使用套接字收/发数据 --> 关闭套接字

#### UDP

<img src="https://user-images.githubusercontent.com/51505633/79089472-dc12f980-7d78-11ea-8f35-4bdf053ac735.jpg" alt="udp_new" style="zoom: 80%;" />

用户数据报协议（UDP，User Datagram Protocol）。UDP 为应用程序提供了一种无需建立连接就可以发送数据的方法。 

##### udp网络程序-发送数据

```python
from socket import *
# 1. 创建udp套接字
udp_socket = socket(AF_INET, SOCK_DGRAM)
# 2. 准备接收方的地址
# '192.168.1.103'表示目的ip地址   8080表示目的端口
dest_addr = ('192.168.1.103', 8080)  # 注意 是元组，ip是字符串，端口是数字
# 3. 从键盘获取数据
send_data = input("请输入要发送的数据:")
# 4. 发送数据到指定的电脑上的指定程序中
udp_socket.sendto(send_data.encode('utf-8'), dest_addr)  
# 数据需要为字节 字符串时可直接 b"..."
# 5. 关闭套接字
udp_socket.close()
```

一般情况下，在一台电脑上运行的网络程序有很多，为了不与其他的网络程序占用同一个端口号，往往在编程中， **udp的端口号一般不绑定** 。但是如果需要做成一个**服务器端的程序** 的话，是需要**绑定**的。

发送数据流程：创建套接字 —— 发送数据 ——关闭

接收数据流程：创建套接字 —— 绑定本地信息 —— 接收数据 ——关闭

##### udp网络程序-发送、接收数据

```python
from socket import *
udp_socket = socket(AF_INET, SOCK_DGRAM)
# 2. 绑定本地的相关信息，如果一个网络程序不绑定，则系统会随机分配
local_addr = ('', 7788)  # ip地址和端口号，ip一般不用写，表示本机的任何一个ip
udp_socket.bind(local_addr)  # 必须绑定自己电脑的 ip 和 port
dest_addr = ('192.168.0.105', 4567)
send_data = input("请输入要发送的数据:")
udp_socket.sendto(send_data.encode('utf-8'), dest_addr)  # 编码
# 6. 等待接收对方发送的数据
recv_data = udp_socket.recvfrom(1024)  # 1024表示本次接收的最大字节数
# 6. 显示对方发送的数据
print(recv_data)
# 接收到的数据recv_data是一个元组(接收到的数据，(发送方的ip, port))
# 第1个元素是对方发送的数据，第2个元素是对方的ip和端口
recv_msg = recv_data[0]  # 存储接收的数据
send_addr = recv_data[1]  # 存储发送方的地址信息
print("%s:%s" % (str(send_addr), recv_msg.decode("gbk")))  # 解码 window 默认 GBK
udp_socket.close()
```

自己电脑多个端口试验时，ip 可设为 127.0.0.1

recvfrom() 在没有收到数据时堵塞

没调用recvfrom() 时收到的数据，由操作系统暂存，调用时再读

套接字可同时收发 —— 全双工       (单工、半双工、全双工)

##### python3 编码转换

`str->bytes:encode编码 ; bytes->str:decode解码`

**字符串通过编码成为字节码，字节码通过解码成为字符串。**

其中decode()与encode()方法可以接受参数，其声明分别为:

```python
bytes.decode(encoding="utf-8", errors="strict")
str.encode(encoding="utf-8", errors="strict")
```

其中的encoding是指在解码编码过程中使用的编码(此处指“编码方案”是名词)，errors是指错误的处理方案。

#### TCP

**TCP协议，传输控制协议（Transmission Control Protocol，TCP）**是一种面向连接的、可靠的、基于字节流的传输层通信协议。

TCP通信需要经过**创建连接、数据传送、终止连接**三个步骤。TCP通信模型中，在通信开始之前，一定要先 **建立相关的链接**，才能发送数据 ，类似于生活中，"**打电话**"；而UDP通信模型中，在通信开始之前，不需要建立相关的连接，只需要发送数据即可，类似于生活中，"**写信**" 

<img src="https://user-images.githubusercontent.com/51505633/79089039-2c895780-7d77-11ea-849b-f0bc63202e62.jpg" alt="tcp" style="zoom: 80%;" />

##### TCP特点

1. 面向连接

   通信双方必须先建立连接才能进行数据的传输，双方都必须为该连接分配必要的系统内核资源，以管理连接的状态和连接上的传输。

   双方间的数据传输都可以通过这一个连接进行；完成数据交换后，双方必须断开此连接，以释放系统资源。这种连接是一对一的，因此 **TCP不适用于广播** 的应用程序，**基于广播**的应用程序请使用**UDP**协议。

2. 可靠传输

   - **TCP采用发送应答机制**：TCP发送的每个报文段都必须得到接收方的应答才认为这个TCP报文段传输成功

   - **超时重传**：发送端发出一个报文段之后就启动定时器，如果在定时时间内没有收到应答就重新发送这个报文段。

     TCP为了保证不发生丢包，就给每个包一个序号，同时序号也保证了传送到接收端实体的包的按序接收。然后接收端实体对已成功收到的包发回一个相应的确认（ACK）；如果发送端实体在合理的往返时延（RTT）内未收到确认，那么对应的数据包就被假设为已丢失将会被进行重传。

   - **错误校验**：TCP用一个校验和函数来检验数据是否有错误；在发送和接收时都要计算校验和。

   - **流量控制和阻塞管理**：流量控制用来避免主机发送得过快而使接收方来不及完全收下。

##### TCP与UDP的不同点

- 面向连接（确认有创建三方交握，连接已创建才作传输。）
- 有序数据传输
- 重发丢失的数据包
- 舍弃重复的数据包
- 无差错的数据传输
- 阻塞/流量控制

tcp 严格区分客户端解和服务器端，而 udp 不区分

所谓的 **服务器端** ：就是 **提供服务的一方** ，而 **客户端** ，就是需要 **被服务的一方** 

##### tcp客户端构建

示例代码：

```python
from socket
# 创建tcp socket
tcp_client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
# 目的信息
server_ip = input("请输入服务器ip:")
server_port = int(input("请输入服务器port:"))
# 链接服务器
tcp_client_socket.connect((server_ip, server_port))  # 元组
# 提示用户输入数据
send_data = input("请输入要发送的数据：")
tcp_client_socket.send(send_data.encode("gbk"))  # 因为已经链接 只需内容  send
# 接收对方发送过来的数据，最大接收1024个字节
recvData = tcp_client_socket.recv(1024)
print('接收到的数据为:', recvData.decode('gbk'))
# 关闭套接字
tcp_client_socket.close()
```

##### tcp服务器构建

想要完成一个tcp服务器的功能，需要的流程如下：

1. socket创建一个套接字
2. bind绑定ip和port
3. listen使套接字变为可以被动链接
4. accept等待客户端的链接
5. recv/send接收发送数据

```python
from socket
# 创建tcp socket
tcp_server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
# 本地信息
address = ('', 7788)
# 绑定
tcp_server_socket.bind(address)
# 使用socket创建的套接字默认的属性是主动的，使用listen将其变为被动的，这样就可以接收别人的链接了
tcp_server_socket.listen(128)
# 如果有新的客户端来链接服务器，那么就产生一个新的套接字专门为这个客户端服务
# client_socket用来为这个客户端服务
# tcp_server_socket就可以省下来专门等待其他新客户端的链接
client_socket, clientAddr = tcp_server_socket.accept()  # 返回元组 拆包
# 第一个接收 新的套接字，第二个接收 链接客户端的地址
# 新的套接字 负责客户端通信，tcp套接字 负责监听 等待新客户端链接
# 接收对方发送过来的数据
recv_data = client_socket.recv(1024)  # 接收1024个字节 返回只有数据
print('接收到的数据为:', recv_data.decode('gbk'))
# 发送一些数据到客户端
client_socket.send("thank you !".encode('gbk'))
# 关闭为这个客户端服务的套接字，只要关闭了，就不能再为这个客户端服务，如果还需要服务，只能再次重新连接
client_socket.close()
tcp_server_socket.close()
```

用 如果想让别人能更够打通咱们的电话获取相应服务 类比，需要做以下几件事情：

1. 买个手机  ——  创建套接字
2. 插上手机卡  ——  绑定ip和port
3. 设计手机为正常接听状态（即能够响铃）  ——  变为被动链接
4. 静静的等着别人拨打  ——  等待客户端链接

客户端调用 connect() 时 会 解 accept() 的堵塞

 recv解堵塞，有2种方式：客户端发送过来数据 / 客户端调用close

```python
# 循环为多个客户端服务并且多次服务一个客户端
import socket
# 1. 买个手机(创建套接字 socket)
tcp_server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
# 2. 插入手机卡(绑定本地信息 bind)
tcp_server_socket.bind(("", 7890))
# 3. 将手机设置为正常的 响铃模式(让默认的套接字由主动变为被动 listen)
tcp_server_socket.listen(128)
# 循环目的：调用多次accept,从而为多个客户端服务
while True:
    print("等待一个新的客户端的到来...")
    # 4. 等待别人的电话到来(等待客户端的链接 accept)
    new_client_socket, client_addr = tcp_server_socket.accept()
    print("一个新的客户端已经到来%s" % str(client_addr))
    # 循环目的: 为同一个客户端 服务多次
    while True:
        # 接收客户端发送过来的请求
        recv_data = new_client_socket.recv(1024)
        print("客户端福送过来的请求是:%s" % recv_data.decode("utf-8"))
        # 如果recv解堵塞，那么有2种方式：
        # 1. 客户端发送过来数据
        # 2. 客户端调用close导致了 这里 recv解堵塞
        # 客户端不能发送空的内容 因此，若recv_data 为空，则一定是 客户端调用close
        if recv_data:
            # 回送一部分数据给客户端
            new_client_socket.send("hahahghai-----ok-----".encode("utf-8"))
        else:
            break
    # 关闭套接字
    # 关闭accept返回的套接字 意味着 不会在为这个客户端服务
    new_client_socket.close()
    print("已经为这个客户端服务完毕。。。。")
# 如果将监听套接字 关闭了，那么会导致 不能再次等待新客户端的到来，即xxxx.accept就会失败
tcp_server_socket.close()
```

##### 案例：文件下载

见项目文件 `file_download_client.py` 和 `file_download_server.py`

with 打开文件时，可以在打得开的情况下，出现异常，调用close()；但如果打不开文件，则用with 也会报异常。写时没有关系，文件不存在等情况，会新建文件。读的时候，文件不一定存在，使用with  不合适。

#### 小结

**udp 用来收数据 需 bind，tcp client 一般不需要 bind**

> qq 不绑定端口时 可通过服务器转发。服务器可以获得所有请求的地址。 QQ既有UDP也有TCP 

**客户端**要绑定端口，可能会在多开或端口被占用时出错，因此，**一般不绑定**。

**tcp注意点**：

1. tcp服务器一般情况下都需要绑定，否则客户端找不到这个服务器
2. tcp客户端一般不绑定，因为是主动链接服务器，所以只要确定好服务器的ip、port等信息就好，本地客户端可以随机
3. tcp服务器中通过listen可以将socket创建出来的主动套接字变为被动的，这是做tcp服务器时必须要做的
4. 当客户端需要连接服务器时，就需要使用connect进行连接，udp是不需要链接的而是直接发送，但是tcp必须先连接，只有连接成功才能通信
5. 当一个tcp客户端连接服务器时，服务器端会有1个新的套接字，这个套接字用来标记这个客户端，单独为这个客户端服务
6. listen后的套接字是被动套接字，用来接收新的客户端的链接请求的，而accept返回的新套接字是标记这个新客户端的
7. 关闭listen后的套接字意味着被动套接字关闭了，会导致新的客户端不能够链接服务器，但是之前已经链接成功的客户端正常通信。
8. 关闭accept返回的套接字意味着这个客户端已经服务完毕
9. 当客户端的套接字调用close后，服务器端会recv解堵塞，并且返回的长度为0，因此服务器可以通过返回数据的长度来区别客户端是否已经下线

### 1 多任务

现在，多核CPU已经非常普及了，但是，即使过去的单核CPU，也可以执行多任务。由于CPU执行代码都是顺序执行的，那么，单核CPU是怎么执行多任务的呢？

答案就是操作系统轮流让各个任务交替执行，任务1执行0.01秒，切换到任务2，任务2执行0.01秒，再切换到任务3，执行0.01秒……这样反复执行下去。表面上看，每个任务都是交替执行的，但是，由于CPU的执行速度实在是太快了，我们感觉就像所有任务都在同时执行一样。（**时间片轮转**）

真正的并行执行多任务只能在多核CPU上实现，但是，由于任务数量远远多于CPU的核心数量，所以，操作系统也会自动把很多任务轮流调度到每个核心上执行。

##### 并发与并行

- 并发：指的是**任务数多余cpu核数**，通过操作系统的各种任务**调度算法**，实现用多个任务“一起”执行（实际上总有一些任务不在执行，因为切换任务的速度相当快，看上去一起执行而已）
- 并行：指的是**任务数小于等于cpu核数**，即任务真的是一起执行的

#### 线程

python的thread模块是比较底层的模块，python的 **threading模块**是对thread做了一些包装的，可以更加方便的被使用

单线程执行

```python
import time
def saySorry():
    print("我能吃饭了吗？")
    time.sleep(1)
if __name__ == "__main__":
    for i in range(5):
        saySorry()
```

多线程执行

```python
import threading
import time
def saySorry():
    print("我能吃饭了吗？")
    time.sleep(1)
if __name__ == "__main__":
    for i in range(5):
        t = threading.Thread(target=saySorry)  # 函数名
        t.start() #启动线程，即让线程开始执行
```

1. 可以明显看出使用了多线程并发的操作，花费时间要短很多
2. 当调用`start()`时，才会真正的创建线程，并且开始执行

##### 主线程等待所有的子线程结束

主线程执行到没有代码时，**会等待所有的子线程结束后才结束**，主线程结束后，整个程序结束

> 原来默认的执行顺序相当于主线程，创建的是子线程，从函数开始执行。

```python
import threading
from time import sleep,ctime
def sing():
    for i in range(3):
        print("正在唱歌...%d"%i)
        sleep(1)
def dance():
    for i in range(3):
        print("正在跳舞...%d"%i)
        sleep(1)
print('---开始---:%s'%ctime())
t1 = threading.Thread(target=sing)
t2 = threading.Thread(target=dance)
t1.start()
t2.start()
print(threading.enumerate())  # enumerate() 返回list，为 所有的线程
sleep(5)  # 注释此行代码，试试看，程序是否会立马结束？
# 注释后，主线程会将下面所有代码执行完后等待子进程结束
print('---结束---:%s'%ctime())
print(threading.enumerate())
```

##### 查看线程数量

```python
import threading
from time import sleep,ctime
def sing():
    for i in range(3):
        print("正在唱歌...%d"%i)
        sleep(1)
def dance():
    for i in range(3):
        print("正在跳舞...%d"%i)
        sleep(1)
print('---开始---:%s'%ctime())
t1 = threading.Thread(target=sing)
t2 = threading.Thread(target=dance)
t1.start()
t2.start()
while True:
    length = len(threading.enumerate())
    print('当前运行的线程数为：%d'%length)
    if length<=1:
        break
    sleep(0.5)
```

线程的运行没有先后顺序！多线程的执行顺序不确定，可通过适当延时，保证线程执行顺序

```python
import threading
import time
def test1():
    for i in range(5):
        print("-----test1---%d---" % i)
def test2():
    for i in range(5):
        print("-----test2---%d---" % i)
t1 = threading.Thread(target=test1)
t2 = threading.Thread(target=test2)
t1.start()
time.sleep(1)  # 先令t1线程执行完
print("---1---")
t2.start()
time.sleep(1)  # 再令t2线程执行完
print("---2---")
print(threading.enumerate())
```

如果创建Thread时执行的函数，运行结束，那么意味着 这个子线程结束了(示例程序中只需要看list长度)

```python
import threading
import time
def test1():
    for i in range(5):
        print("-----test1---%d---" % i)
        time.sleep(1)
    # 如果创建Thread时执行的函数，运行结束那么意味着 这个子线程结束了....
def test2():
    for i in range(10):
        print("-----test2---%d---" % i)
        time.sleep(1)
t1 = threading.Thread(target=test1)
t2 = threading.Thread(target=test2)
t1.start()
t2.start()
while True:
    print(threading.enumerate())
    if len(threading.enumerate())<=1:
        break
    time.sleep(1)
```

**子线程在调用Thread创建的实例对象的 start() 方法时才会 创建线程 并让线程开始运行，threading.Thread 不会创建线程**，只是一个对象

```python
# 验证什么时候创建线程，什么时候线程执行
# 创建线程：线程list 有两个值；线程执行：输出test1中的print语句
import threading
import time
def test1():
    for i in range(5):
        print("-----test1---%d---" % i)
        time.sleep(1)
print(threading.enumerate())  # 在调用Thread之前先打印当前线程信息
t1 = threading.Thread(target=test1)
print(threading.enumerate())  # 在调用Thread之后打印
t1.start()
time.sleep(2)
print(threading.enumerate())  # 在调用start之后打印
```

##### 创建线程方式

- 函数：Thread(target=saySorry)   —— 线程执行函数中代码
- 类：定义类 继承 Thread 。继承 Thread 时，必须定义 run() 方法，调用 start() 时 会自动调用 run()  —— 线程执行run中代码

```python
# 线程执行代码的封装   
import threading
import time
class MyThread(threading.Thread):
    def run(self):
        for i in range(3):
            time.sleep(1)
            msg = "I'm "+self.name+' @ '+str(i)  # name属性中保存的是当前线程的名字，自动指定
            print(msg)
def test():
    for i in range(5):
        t = MyThread()
        t.start()
test()
```

说明：

- python的threading.Thread类有一个run方法，用于定义线程的功能函数，可以在自己的线程类中覆盖该方法。而创建自己的线程实例后，通过Thread类的start方法，可以启动该线程，交给python虚拟机进行调度，当该线程获得执行的机会时，就会调用run方法执行线程。当线程的run()方法结束时该线程完成。
-  从代码和执行结果我们可以看出，多线程程序的执行顺序是不确定的。当执行到sleep语句时，线程将被阻塞（Blocked），到sleep结束后，线程进入就绪（Runnable）状态，等待调度。而线程调度将自行选择一个线程执行。上面的代码中只能保证每个线程都运行完整个run函数，但是线程的启动顺序、run函数中每次循环的执行顺序都不能确定。 

##### 多线程共享全局变量

在函数中 对全局变量进行修改时，是否需要使用 global ，需要看是否对全局变量的指向进行修改；如果修改了指向，即让全局变量指向了新的内存地址，则必须使用 global ；如果仅仅修改了指向的空间中的数据，则不必使用 global

```python
# 这使用了两种传变量方式 -- 直接用（全局变量） / 通过 线程的args参数    虽然这g_nums 也是全局变量
import threading
import time
g_num = 100
g_nums = [11, 22]
def test1(temp):
    global g_num
    g_num += 99
    temp.append(33)
    print("-----in test1 g_num=%d, temp=%s----" % (g_num, str(temp)))
def test2(temp):
    print("-----in test2 g_num=%d, temp=%s----" % (g_num, str(temp)))
def main():
    # target指定将来 这个线程去哪个函数执行代码
    # args指定将来调用 函数的时候 传递什么数据过去
    t1 = threading.Thread(target=test1, args=(g_nums,))  # args 参数为元组，所以有，
    t2 = threading.Thread(target=test2, args=(g_nums,))
    t1.start()
    time.sleep(1)
    t2.start()
    time.sleep(1)
    print("-----in main Thread g_num=%d, g_nums=%s----" % (g_num, str(g_nums)))
if __name__ == "__main__":
    main()
```

##### 资源竞争问题

多线程开发可能遇到的问题：如果**多个线程同时**对**同一个全局变量操作**，会出现**资源竞争问题**，从而数据结果会不正确。

示例：

> 假设两个线程t1和t2都要对全局变量g_num(默认是0)进行加1运算，t1和t2都各对g_num加10次，g_num的最终的结果应该为20。但是由于是多线程同时操作，有可能出现下面情况：
>
> 1. 在g_num=0时，t1取得g_num=0。此时系统把t1调度为”sleeping”状态，把t2转换为”running”状态，t2也获得g_num=0
> 2. 然后t2对得到的值进行加1并赋给g_num，使得g_num=1
> 3. 然后系统又把t2调度为”sleeping”，把t1转为”running”。线程t1又把它之前得到的0加1后赋值给g_num。
> 4. 这样导致虽然t1和t2都对g_num加1，但结果仍然是g_num=1

```python
import threading
import time
g_num = 0
def work1(num):
    global g_num
    for i in range(num):
        g_num += 1
    print("----in work1, g_num is %d---"%g_num)
def work2(num):
    global g_num
    for i in range(num):
        g_num += 1
    print("----in work2, g_num is %d---"%g_num)
print("---线程创建之前g_num is %d---"%g_num)
t1 = threading.Thread(target=work1, args=(1000000,))
t1.start()
t2 = threading.Thread(target=work2, args=(1000000,))
t2.start()
while len(threading.enumerate()) != 1:
    time.sleep(1)
print("2个线程对同一个全局变量操作之后的最终结果是:%s" % g_num)
# 运行结果：
# ---线程创建之前g_num is 0---
# ----in work1, g_num is 1088005---
# ----in work2, g_num is 1286202---
# 2个线程对同一个全局变量操作之后的最终结果是:1286202
```

##### 同步

同步就是协同步调，按预定的先后次序进行运行。  如进程、线程同步，可理解为进程或线程A和B一块配合，A执行到一定程度时要依靠B的某个结果，于是停下来，示意B运行;B执行，再将结果给A;A再继续操作。 

##### 互斥锁

- 当多个线程几乎同时修改某一个共享数据的时候，需要进行同步控制
- 线程同步能够保证多个线程安全访问竞争资源，最简单的同步机制是引入互斥锁。
- 互斥锁为资源引入一个状态：锁定/非锁定

某个线程要更改共享数据时，先将其锁定，此时资源的状态为“锁定”，其他线程不能更改；直到该线程释放资源，将资源的状态变成“非锁定”，其他的线程才能再次锁定该资源。互斥锁保证了每次只有一个线程进行写入操作，从而保证了多线程情况下数据的正确性。

threading模块中定义了Lock类，可以方便的处理锁定：

```python
mutex = threading.Lock()  # 创建互斥锁 默认没有上锁 上锁只能上一次
mutex.acquire()  # 锁定
mutex.release()  # 释放
```

注意：

- 如果这个锁之前是没有上锁的，那么acquire不会堵塞
- 如果在调用acquire对这个锁上锁之前 它已经被 其他线程上了锁，那么此时acquire会堵塞，直到这个锁被解锁为止
- 上锁的代码越少越好

>  谁先上锁，谁先做事情；谁后上锁，谁就做不了    上厕所，锁门后，外边只能排队等

示例的解决：

```python
import threading
import time
g_num = 0  # 定义一个全局变量
def test1(num):
    global g_num
    # 上锁，如果之前没有被上锁，那么此时 上锁成功
    # 如果上锁之前 已经被上锁了，那么此时会堵塞在这里，直到 这个锁被解开位置
    for i in range(num):
        mutex.acquire()  # 上锁 如果都在for外面上锁，会执行完整个for循环，不符合 上锁的代码越少越好
        g_num += 1
        mutex.release()  # 解锁
    print("-----in test1 g_num=%d----" % g_num)
def test2(num):
    global g_num
    for i in range(num):
        mutex.acquire()  # 上锁
        g_num += 1
        mutex.release()  # 解锁
    print("-----in test2 g_num=%d=----" % g_num)
mutex = threading.Lock()  # 创建一个互斥锁，默认是没有上锁的
def main():
    t1 = threading.Thread(target=test1, args=(1000000,))
    t2 = threading.Thread(target=test2, args=(1000000,))
    t1.start()
    t2.start()
    # 等待上面的2个线程执行完毕....
    time.sleep(2)
    print("-----in main Thread g_num = %d---" % g_num)
if __name__ == "__main__":
    main()
# 运行结果：
# ---test1---g_num=1920255
# ---test2---g_num=2000000
# 2个线程对同一个全局变量操作之后的最终结果是:2000000
```

##### 死锁

在线程间共享多个资源的时候，如果两个线程分别占有一部分资源并且同时等待对方的资源，就会造成死锁。 

示例：

```python
import threading
import time
class MyThread1(threading.Thread):
    def run(self):
        mutexA.acquire()  # 对mutexA上锁
        # mutexA上锁后，延时1秒，等待另外那个线程 把mutexB上锁
        print(self.name+'----do1---up----')
        time.sleep(1)
        mutexB.acquire()  # 此时会堵塞，因为这个mutexB已经被另外的线程抢先上锁了
        print(self.name+'----do1---down----')
        mutexB.release()
        mutexA.release()  # 对mutexA解锁
class MyThread2(threading.Thread):
    def run(self):
        mutexB.acquire()  # 对mutexB上锁
        # mutexB上锁后，延时1秒，等待另外那个线程 把mutexA上锁
        print(self.name+'----do2---up----')
        time.sleep(1)
        mutexA.acquire()  # 此时会堵塞，因为这个mutexA已经被另外的线程抢先上锁了
        print(self.name+'----do2---down----')
        mutexA.release()
        mutexB.release()  # 对mutexB解锁
mutexA = threading.Lock()
mutexB = threading.Lock()
if __name__ == '__main__':
    t1 = MyThread1()
    t2 = MyThread2()
    t1.start()
    t2.start()
```

避免死锁：设计时避免（银行家算法） /  添加超时时间等

##### 银行家算法 

银行家算法是从当前状态出发，逐个按安全序列检查各客户谁能完成其工作，然后假定其完成工作且归还全部贷款，再进而检查下一个能完成工作的客户，......。如果所有客户都能完成工作，则找到一个安全序列，银行家才是安全的。 

##### 案例：多任务版UTP聊天器

> 需求：
>
> - 编写一个有2个线程的程序
> - 线程1用来接收数据然后显示
> - 线程2用来检测键盘数据然后通过udp发送数据

实现：`udp_threading_app.py` 文件

##### 小结

1. 多任务：实现多个程序(函数等)可以一起运行
2. 线程是实现多任务的一种基本方式，轻量级
3. 导入 threading.Thread 类，创建实例对象，在调用start()时创建线程，并从创建对象时指定的target(函数引用)处开始执行，函数执行完，线程结束
4. 线程执行顺序不确定；多线程的调度由操作系统(/调度算法)决定；主线程最后结束
5. 通过 程序设计/互斥锁 方式，避免共享全局变量时资源竞争问题
6. 互斥锁 可能 导致 死锁

#### 进程

程序：例如xxx.py这是程序，是一个静态的

进程：一个程序运行起来后，**代码 +** 用到的**资源** 称之为进程，它是操作系统**分配资源**的**基本单元**。

不仅可以通过线程完成多任务，进程也可以

##### 进程的状态

工作中，任务数往往大于cpu的核数，即一定有一些任务正在执行，而另外一些任务在等待cpu进行执行，因此导致了有了不同的状态。

<img src="https://user-images.githubusercontent.com/51505633/79089066-462a9f00-7d77-11ea-8c9b-428f4ab202df.jpg" alt="process" style="zoom:50%;" />

- 就绪态：运行的条件都已经慢去，正在等在cpu执行
- 执行态：cpu正在执行其功能
- 等待态：等待某些条件满足，例如一个程序sleep了，此时就处于等待态

##### 进程的创建 - multiprocessing

multiprocessing模块就是跨平台版本的多进程模块，提供了一个Process类来代表一个进程对象，这个对象可以理解为是一个独立的进程，可以执行另外的事情 

```python
import time
import multiprocessing
def test1():
    while True:
        print("----1----")
        time.sleep(1)
def test2():
    while True:
        print("----2----")
        time.sleep(1)
if __name__ == "__main__":  # 必须有这个语句，不然报错 RuntimeError
    p1 = multiprocessing.Process(target=test1)
    p2 = multiprocessing.Process(target=test2)
    p1.start()
    p2.start()
    while True:
        print("----0----")
        time.sleep(1)
```

创建子进程时，只需要传入一个执行函数和函数的参数，创建一个Process实例，用start()方法启动

调用 start() 时子进程创建，与主进程共享一样的 代码和资源，不能共享的会复制 —— **写时拷贝**

**具体如何处理？**

> 由于Python运行过程中，新创建进程后，进程会导入正在运行的文件，即在运行代码时，运行到mp.Process，新的进程会重新读入该代码，对于没有 `if __name__=="__main__":` 保护的代码，新进程都认为是要再次运行的代码，这是子进程又一次运行mp.Process，但是在multiprocessing.Process的源码中是对子进程再次产生子进程是做了限制的，是不允许的，于是出现如上的错误提示。 
>
> 当代码被当做脚本读入的时候，命名空间会被命名为 `"main"`，对于在脚本运行过程中读入的代码命名空间都不会被命名为 `"main"`。这也就是说创建的子进程是不会读取 `if __name__=="__main__":` 保护下的代码。 

##### 进程pid

```python
# -*- coding:utf-8 -*-
from multiprocessing import Process
import os
import time
def run_proc():
    """子进程要执行的代码"""
    while True:
        print("--子进程 pid=%d >2> 父进程pid=%d--" % (os.getpid(), os.getppid()))
        time.sleep(1)
if __name__ == '__main__':
    print("--主进程 pid=%d >0> 父进程pid=%d--" % (os.getpid(), os.getppid()))
    # os.getpid()获取当前进程id     os.getppid()获取父进程id
    p = Process(target=run_proc)
    p.start()
    while True:
        print("--主进程 pid=%d >1> 父进程pid=%d--" % (os.getpid(), os.getppid()))
        time.sleep(1)
```

(VScode中)主程序的父进程id为执行程序的终端的进程号，主进程和子进程都为 Python 解释器

> 强制结束一个进程时，其他进程继续运行，强制结束所有进程后，**命令行阻塞**；但如果主进程已经运行结束(非无限循环)，强制结束子进程后，代码运行终止。

##### Process 语法结构

`Process([group [, target [, name [, args [, kwargs]]]]])`：

- `target`：如果传递了函数的引用，可以任务这个子进程就执行这里的代码
- `args`：给target指定的函数传递的参数，以元组的方式传递
- `kwargs`：给target指定的函数传递命名参数
- `name`：给进程设定一个名字，可以不设定
- `group`：指定进程组，大多数情况下用不到

Process创建的实例对象的常用方法：

- `start()`：启动子进程实例（创建子进程）
- `is_alive()`：判断进程子进程是否还在活着
- `join([timeout])`：是否等待子进程执行结束，或等待多少秒
- `terminate()`：不管任务是否完成，立即终止子进程

Process创建的实例对象的常用属性：

- `name`：当前进程的别名，默认为Process-N，N为从1开始递增的整数
- `pid`：当前进程的pid（进程号）

进程的执行顺序不固定，但主进程会等待子进程执行完毕

##### 给子进程指定的函数传递参数

```python
# -*- coding:utf-8 -*-
from multiprocessing import Process
import os
from time import sleep
def run_proc(name, age, *args, **kwargs):
    for i in range(10):
        print('子进程运行中，name=%s,age=%d ,pid=%d...' % (name, age, os.getpid()))
        print(args)
        print(kwargs)
        sleep(0.2)
if __name__=='__main__':
    p = Process(target=run_proc, args=('test',18,11,22,33), kwargs={"m":20})
    p.start()
    sleep(1)  # 1秒中之后，立即结束子进程
    p.terminate()
    p.join()
```

##### 多进程间不共享全局变量

```python
# -*- coding:utf-8 -*-
from multiprocessing import Process
import os
import time
nums = [11, 22]
def work1():
    """子进程要执行的代码"""
    print("in process1 pid=%d ,nums=%s" % (os.getpid(), nums))
    nums.append(33)
    time.sleep(1)
    print("in process1 pid=%d ,nums=%s" % (os.getpid(), nums))
def work2():
    """子进程要执行的代码"""
    print("in process2 pid=%d ,nums=%s" % (os.getpid(), nums))
if __name__ == '__main__':
    p1 = Process(target=work1)
    p1.start()
    p1.join()
    p2 = Process(target=work2)
    p2.start()
```

##### 进程、线程对比

###### 功能

- 进程，能够完成多任务，比如 在一台电脑上能够同时运行多个QQ
- 线程，能够完成多任务，比如 一个QQ中的多个聊天窗口

###### 定义

- **进程**是系统进行**资源分配和调度**的一个**独立单位**.
- **线程**是**进程**的一个**实体**,是**CPU调度和分派的基本单位**,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源.

###### 区别

- **一个程序**至少有**一个进程**,一个进程至少有**一个线程**。
- 线程的划分尺度小于进程(资源比进程少)，使得多线程程序的并发性高。
- **进程**在执行过程中拥有**独立**的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。
- **线程不能够独立执行**，必须依存在进程中。

可以将进程理解为工厂中的一条流水线，而其中的线程就是这个流水线上的工人

###### 优缺点

线程和进程在使用上各有优缺点：线程执行开销小，但不利于资源的管理和保护；而进程正相反。

##### 进程间通信 - Queue 队列

> socket 也可以实现进程间通信

##### Queue 的使用

可以使用multiprocessing模块的Queue实现多进程之间的数据传递，Queue本身是一个消息列队程序，示例：

```python
from multiprocessing import Queue
q = Queue(3)  # 初始化一个Queue对象，最多可接收三条put消息
q.put("消息1") 
q.put("消息2")
print(q.full())  # False
q.put("消息3")
print(q.full())  # True
# 因为消息列队已满下面的try都会抛出异常，第一个try会等待2秒后再抛出异常，第二个Try会立刻抛出异常
try:
    q.put("消息4",True,2)
except:
    print("消息列队已满，现有消息数量:%s"%q.qsize())
try:
    q.put_nowait("消息4")
except:
    print("消息列队已满，现有消息数量:%s"%q.qsize())
# 推荐的方式，先判断消息列队是否已满，再写入
if not q.full():
    q.put_nowait("消息4")
# 读取消息时，先判断消息列队是否为空，再读取
if not q.empty():
    for i in range(q.qsize()):
        print(q.get_nowait())
```

> 初始化Queue()对象时（例如：q=Queue()），若括号中没有指定最大可接收的消息数量，或数量为负值，那么就代表可接受的消息数量没有上限（直到内存的尽头）；
>
> - **Queue.qsize()**：返回当前队列包含的消息数量；
>
> - **Queue.empty()**：如果队列为空，返回True，反之False ；
>
> - **Queue.full()**：如果队列满了，返回True,反之False；
>
> - **Queue.get([block[, timeout]])**：获取队列中的一条消息，然后将其从列队中移除，block默认值为True；
>
>     1）如果block使用默认值，且没有设置timeout（单位秒），消息列队如果为空，此时程序将被阻塞（停在读取状态），直到从消息列队读到消息为止，如果设置了timeout，则会等待timeout秒，若还没读取到任何消息，则抛出"Queue.Empty"异常；
>
>     2）如果block值为False，消息列队如果为空，则会立刻抛出"Queue.Empty"异常；
>
> - **Queue.get_nowait()**：相当Queue.get(False)；
>
> - **Queue.put(item,[block[, timeout]])**：将item消息写入队列，block默认值为True；
>
>     1）如果block使用默认值，且没有设置timeout（单位秒），消息列队如果已经没有空间可写入，此时程序将被阻塞（停在写入状态），直到从消息列队腾出空间为止，如果设置了timeout，则会等待timeout秒，若还没空间，则抛出"Queue.Full"异常；
>
>     2）如果block值为False，消息列队如果没有空间可写入，则会立刻抛出"Queue.Full"异常；
>
> - **Queue.put_nowait(item)**：相当Queue.put(item, False)；

##### 多进程通过Queue实现数据共享

一个进程向Queue中写入数据，另外一个进程从Queue中获取数据，通过**Queue**完成了 多个需要配合的进程间的数据共享，从而能够 起到 **解耦**的作用

```python
import multiprocessing
def download_from_web(q):
    """下载数据"""
    # 模拟从网上下载的数据
    data = [11, 22, 33, 44]
    # 向队列中写入数据
    for temp in data:
        q.put(temp)
    print("---下载器已经下载完了数据并且存入到队列中----")
def analysis_data(q):
    """数据处理"""
    waitting_analysis_data = list()  # 同 []，但可读性更强
    # 从队列中获取数据
    while True:
        data = q.get()
        waitting_analysis_data.append(data)
        if q.empty():
            break
    # 模拟数据处理
    print(waitting_analysis_data)
# 1. 创建一个队列
q = multiprocessing.Queue()
# 2. 创建多个进程，将队列的引用当做实参进行传递到里面
p1 = multiprocessing.Process(target=download_from_web, args=(q,))
p2 = multiprocessing.Process(target=analysis_data, args=(q,))
p1.start()
p2.start()
```

Queue 只能用于同一个电脑的同一个程序的多个进程，Redis 可以实现消息队列，实现分布式。

##### 进程池 Pool

用multiprocessing模块提供的Pool方法，创建多个子进程。

初始化Pool时，可以指定一个最大进程数，当有新的请求提交到Pool中时，如果池还没有满，那么就会创建一个新的进程用来执行该请求；但如果池中的进程数已经达到指定的最大值，那么该请求就会等待，直到池中有进程结束，才会用之前的进程来执行新的任务。

进程数量很少或确定时，不需要使用进程池；很多或不确定时，使用进程池

```python
# -*- coding:utf-8 -*-
from multiprocessing import Pool
import os, time, random
def worker(msg):
    t_start = time.time()
    print("%s开始执行,进程号为%d" % (msg,os.getpid()))
    # random.random()随机生成0~1之间的浮点数
    time.sleep(random.random()*2) 
    t_stop = time.time()
    print(msg,"执行完毕，耗时%0.2f" % (t_stop-t_start))
if __name__ == '__main__':
    po = Pool(3)  # 定义一个进程池，最大进程数3
    # 非现在创建子进程，在使用时创建子进程
    for i in range(0,10):
        # Pool().apply_async(要调用的目标,(传递给目标的参数元祖,))
        # 每次循环将会用空闲出来的子进程去调用目标
        po.apply_async(worker,(i,))  # 要执行的任务 函数名
    print("----start----")
    po.close()  # 关闭进程池，关闭后po不再接收新的请求
    po.join()  # 等待po中所有子进程执行完成，必须放在close语句之后
    print("-----end-----")
```

主进程 不会等待 进程池中的创建的子进程 执行完毕，需要阻塞，使其等待

##### Pool 常用函数

- `apply_async(func[, args[, kwds]])` ：使用非阻塞方式调用func（并行执行，堵塞方式必须等待上一个进程退出才能执行下一个进程），args为传递给func的参数列表，kwds为传递给func的关键字参数列表；
- `close()`：关闭Pool，使其不再接受新的任务；
- `terminate()`：不管任务是否完成，立即终止；
- `join()`：主进程阻塞，等待子进程的退出， 必须在close或terminate之后使用；

##### 进程池中的 Queue

如果要使用Pool创建进程，就需要使用multiprocessing.Manager()中的Queue()，而不是multiprocessing.Queue()

```python
# 修改import中的Queue为Manager
from multiprocessing import Manager,Pool
import os,time,random
def reader(q):
    print("reader启动(%s),父进程为(%s)" % (os.getpid(), os.getppid()))
    for i in range(q.qsize()):
        print("reader从Queue获取到消息：%s" % q.get(True))
def writer(q):
    print("writer启动(%s),父进程为(%s)" % (os.getpid(), os.getppid()))
    for i in "itcast":
        q.put(i)
if __name__=="__main__":
    print("(%s) start" % os.getpid())
    q = Manager().Queue()  # 使用Manager中的Queue
    po = Pool()
    po.apply_async(writer, (q,))
    time.sleep(1)  # 先让上面的任务向Queue存入数据，然后再让下面的任务开始从中取数据
    po.apply_async(reader, (q,))
    po.close()
    po.join()
    print("(%s) End" % os.getpid())
```

> 如果进程池中产生异常，不会输出异常信息。

##### 案例：文件夹 copy 器

实现：`dir_copy_process.py` 文件

 \r 默认将指针返回到最开始后输出（*在原位置再次输出*）

#### 协程

##### 迭代器 

> 迭代是访问集合元素的一种方式。迭代器是一个可以记住遍历的位置的对象。迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束。迭代器只能往前不会后退。

###### 可迭代对象 Iterable

可以对list、tuple、str等类型的数据使用for...in...的循环语法从其中依次拿到数据进行使用，我们把这样的过程称为遍历，也叫**迭代**。

**但是，是否所有的数据类型都可以放到for...in...的语句中，然后让for...in...每次从中取出一条数据供我们使用，即供我们迭代吗？**

```python
# MyList 的目的 --> 自己实现一个额可迭代的对象
# 我们自定义一个容器MyList用来存放数据，可以通过add方法向其中添加数据
class MyList(object):
    def __init__(self):
            self.container = []
    def add(self, item):
            self.container.append(item)
mylist = MyList()
mylist.add(1)
mylist.add(2)
mylist.add(3)
for num in mylist:
    print(num)
# TypeError: 'MyList' object is not iterable
```

自定义了一个容器类型MyList，在将一个存放了多个数据的MyList对象放到for...in...的语句中，发现for...in...并不能从中依次取出一条数据返回给我们，也就说我们随便封装了一个可以存放多条数据的类型却并不能被迭代使用。 

把可以通过for...in...这类语句迭代读取一条数据供我们使用的对象称之为**可迭代对象（Iterable）**。 

###### 如何判断一个对象是否可以迭代

使用 isinstance() 判断一个对象是否是 Iterable 对象

```python
from collections import Iterable  # Iterable 是一个类
print(isinstance([], Iterable))  # True    isinstance 判断是不是一个实例
print(isinstance('abc', Iterable))  # True
print(isinstance(mylist, Iterable))  # False
print(isinstance(100, Iterable))  # False
```

###### 可迭代对象的本质

对可迭代对象进行迭代使用的过程，发现每迭代一次（即在for...in...中每循环一次）都会返回对象中的下一条数据，一直向后读取数据直到迭代了所有数据后结束。那么，在这个过程中就应该有一个“人”去记录每次访问到了第几条数据，以便每次迭代都可以返回下一条数据。我们把这个能帮助我们进行数据迭代的“人”称为**迭代器(Iterator)**。 

**可迭代对象的本质**就是可以向我们**提供**一个这样的中间“人”即**迭代器**帮助我们对其**进行迭代遍历**使用。 

可迭代对象通过`__iter__`方法向我们提供一个迭代器，我们在迭代一个可迭代对象的时候，实际上就是先获取该对象提供的一个迭代器，然后通过这个迭代器来依次获取对象中的每一个数据.

**也就是说，一个具备了`__iter__`方法的对象，就是一个可迭代对象。**

```python
from collections import Iterable
class MyList(object):
    def __init__(self):
        self.container = []
    def add(self, item):
        self.container.append(item)
    def __iter__(self):  # 如果想要一个对象成为一个可迭代的对象，即可使用for，那么必须实现__iter__方法
        """必须返回一个具有__iter__和__next__方法的引用 —— 迭代器对象"""
        pass  # 我们暂时忽略如何构造一个迭代器对象
mylist = MyList()
print("判断mylist是否是可以迭代的对象:", isinstance(mylist, Iterable))  # True    print里面是一个元组
for num in mylist:
    print(num)
# iter() returned non-iterator of type 'NoneType'
```

添加了 `__iter__` 方法的 mylist 对象已经是一个可迭代对象了

###### iter()函数与next()函数

**list、tuple等都是可迭代对象，我们可以通过iter()函数获取这些可迭代对象的迭代器。然后我们可以对获取到的迭代器不断使用next()函数来获取下一条数据。**iter()函数实际上就是调用了可迭代对象的`__iter__`方法。 

```python
li = [11, 22, 33, 44, 55]
li_iter = iter(li)
print(next(li_iter))  # 11
# ... 省略
print(next(li_iter))  # 55
print(next(li_iter))  # StopIteration
```

当我们已经迭代完最后一个数据之后，再次调用next()函数会抛出StopIteration的异常，来告诉我们所有数据都已迭代完成，不用再执行next()函数了。

###### 如何判断一个对象是否是迭代器

使用 isinstance() 判断一个对象是否是 Iterator 对象 

```python
from collections import Iterator
print(isinstance([], Iterator))  # False
print(isinstance(iter([]), Iterator))  # True
print(isinstance(iter("abc"), Iterator))  # True
```

###### 迭代器 Iterator

迭代器是用来帮助我们记录每次迭代访问到的位置，当我们对迭代器使用next()函数的时候，迭代器会向我们返回它所记录位置的下一个位置的数据。实际上，在使用next()函数的时候，调用的就是迭代器对象的`__next__`方法（Python3中是对象的`__next__`方法，Python2中是对象的next()方法）。**所以，我们要想构造一个迭代器，就要实现它的`__next__`方法**。但这还不够，python要求迭代器本身也是可迭代的，所以我们还要为迭代器实现`__iter__`方法，而`__iter__`方法要返回一个迭代器，迭代器自身正是一个迭代器，所以迭代器的`__iter__`方法返回自身即可。

**一个实现了`__iter__`方法和`__next__`方法的对象，就是迭代器。**

```python
import time
from collections import Iterator
class MyList(object):
    """自定义的一个可迭代对象"""
    def __init__(self):
        self.items = []
    def add(self, val):
        self.items.append(val)
    def __iter__(self):
        return MyIterator()  # 创建了一个实例对象，返回对象的引用  这样就满足for条件了
        # 先执行右边 创建实例对象，然后把对象的引用返回
class MyIterator(object):
    """自定义的供上面可迭代对象使用的一个迭代器"""
    def __next__(self):  # 必须有的方法
        # pass
        return 111
    def __iter__(self):  # 必须有的方法
        pass
if __name__ == '__main__':
    mylist = MyList()
    mylist.add(1)
    mylist.add(2)
    mylist.add(3)
    # iter(mylist)  # 自动调用__iter__方法，得到返回值 返回的是一个迭代器（具有 两个必须有的方法）
    mylist_iterator = iter(mylist)
    print("判断mylist_iterator是否是迭代器:", isinstance(mylist_iterator, Iterator))  # True
    print(next(mylist_iterator))  # 111  next函数自动调用__next__方法，得到其返回值
    for num in mylist:
        print(num)  # 会一直输出 111
        time.sleep(1)
    # 把 __next__方法 的返回值改为 mylist 中的内容，就实现了 自己实现一个可以迭代的对象
```

`for temp in xxx_obj` 会干什么：

1. 判断 xxx_obj 是否是可迭代对象
2. 在1成立的前提下，调用iter函数，得到xxx_obj对象的`__iter__` 方法的返回值
3. `__iter__` 方法的返回值 是一个迭代器
4. for循环通过迭代器的 next函数取值，调用迭代器中的 `__next__`，返回什么，temp就是什么（这会执行多次）

```python
class MyList(object):
    """自定义的一个可迭代对象"""
    def __init__(self):
        self.items = []
    def add(self, val):
        self.items.append(val)
    def __iter__(self):
        myiterator = MyIterator(self)  # 括号中为对象的引用，为了使__next__得到self.items
        return myiterator  # 返回对象的引用
class MyIterator(object):
    """自定义的供上面可迭代对象使用的一个迭代器"""
    def __init__(self, mylist):  # mylist 就指向了MyList类的对象
        self.mylist = mylist  # 定义一个属性指向了MyList类的对象
        self.current = 0  # current用来记录当前访问到的位置 这个不能定义在__next__中  实例属性
    def __next__(self):  # 必须有的方法
        if self.current < len(self.mylist.items):  # for循环不知道何时终止，需加判断条件
            item = self.mylist.items[self.current]  # 得到了指向MyList类的对象的items列表
            self.current += 1
            return item  # 先 +1 再返回
        else:  # 没有的话 一直为 None，需自定义异常
            raise StopIteration  # 迭代器取完的异常，for会自动停止
    def __iter__(self):  # 必须有的方法
        pass
if __name__ == '__main__':
    mylist = MyList()
    mylist.add(1)
    mylist.add(2)
    mylist.add(3)
    for num in mylist:
        print(num)
# 实现了 自己实现一个可以迭代的对象
```

在 MyList 类中 `__iter__` 返回 self，省一个对象，是否可行？可行。

```python
# for 时判断类是否有__iter__(可迭代)，由于返回为自己，自己还有__next__，因此也为迭代器
# for 会调用 __iter__中返回对象的__next__方法
class MyList(object):
    """自定义的一个可迭代对象"""
    def __init__(self):
        self.items = []
        self.current = 0
    def add(self, val):
        self.items.append(val)
    def __iter__(self):
        return self
    def __next__(self):
        if self.current < len(self.items):
            item = self.items[self.current]
            self.current += 1
            return item
        else:
            raise StopIteration
if __name__ == '__main__':
    mylist = MyList()
    mylist.add(1)
    mylist.add(2)
    mylist.add(3)
    for num in mylist:
        print(num)
# 迭代器一定为可迭代对象
```

###### for...in...循环的本质

`for item in Iterable`循环的本质就是先通过iter()函数获取可迭代对象Iterable的迭代器，然后对获取到的迭代器不断调用next()方法来获取下一个值并将其赋值给item，当遇到StopIteration的异常后循环结束。 

###### 迭代器的应用场景

迭代器最核心的功能就是可以通过next()函数的调用来返回下一个数据值。如果每次返回的数据值不是在一个已有的数据集合中读取的，而是通过程序按照一定的规律计算生成的，那么也就意味着可以不用再依赖一个已有的数据集合，也就是说不用再将所有要迭代的数据都一次性缓存下来供后续依次读取，这样可以节省大量的存储（内存）空间。 

举个例子，比如，数学中有个著名的斐波拉契数列（Fibonacci），数列中第一个数为0，第二个数为1，其后的每一个数都可由前两个数相加得到：0, 1, 1, 2, 3, 5, 8, 13, 21, 34, ...

现在我们想要通过for...in...循环来遍历迭代斐波那契数列中的前n个数。那么这个斐波那契数列我们就可以用迭代器来实现，每次迭代都通过数学计算来生成下一个数。

```python
class FibIterator(object):
    """斐波那契数列迭代器"""
    def __init__(self, n):
        self.n = n  # 指明生成数列的前n个数
        self.current = 0  # current用来保存当前生成到数列中的第几个数了
        self.num1 = 0  # num1用来保存前前一个数，初始值为数列中的第一个数0
        self.num2 = 1  # num2用来保存前一个数，初始值为数列中的第二个数1
    def __next__(self):
        """被next()函数调用来获取下一个数"""
        if self.current < self.n:
            num = self.num1
            self.num1, self.num2 = self.num2, self.num1+self.num2
            self.current += 1
            return num  # 一直将self.num1作为输出的值
        else:
            raise StopIteration
    def __iter__(self):
        """迭代器的__iter__返回自身即可"""
        return self
if __name__ == '__main__':
    fib = FibIterator(10)
    for num in fib:
        print(num, end=" ")
```

###### 并不是只有for循环能接收可迭代对象

除了for循环能接收可迭代对象，list、tuple等也能接收。

```python
li = list(FibIterator(15))
print(li)
tp = tuple(FibIterator(6))
print(tp)
```

###### 小结

迭代器用极小的代码，极小的内存空间，生成数据

##### 生成器

利用迭代器，我们可以在每次迭代获取数据（通过next()方法）时按照特定的规律进行生成。但是我们在实现一个迭代器时，关于当前迭代到的状态需要我们自己记录，进而才能根据当前状态生成下一个数据。为了达到记录当前状态，并配合next()函数进行迭代使用，我们可以采用更简便的语法，即**生成器(generator)。生成器是一类特殊的迭代器**。 

###### 创建生成器方法1 - ()

把一个列表生成式的 [ ] 改成 ( )  —— 了解

```python
L = [x*2 for x in range(5)]
print(L)  # [0, 2, 4, 6, 8]
G = (x*2 for x in range(5))
print(G)  # <generator object <genexpr> at 0x00000196AB379308>
for i in G:
    print(i, end=" ")  # 0 2 4 6 8
```

创建 L 和 G 的区别仅在于最外层的 [ ] 和 ( ) ， L 是一个列表，而 G 是一个生成器。我们可以直接打印出列表L的每一个元素，而对于生成器G，我们可以按照迭代器的使用方法来使用，即可以通过next()函数、for循环、list()等方法使用。 

###### 创建生成器方法2 - 定义函数

```python
# 使用生成器完成 斐波那契数列
def fib(n):
    current = 0
    num1, num2 = 0, 1
    while current < n:
        num = num1
        num1, num2 = num2, num1+num2
        current += 1
        yield num
    return 'done'
F = fib(10)  # 只会将n取值为10，不会执行函数代码
for num in F:  # for循环时，开始执行函数，到yield语句时，返回内容（暂停而不是结束），再次循环时，从yield语句开始执行后续语句
    print(num)
```

在使用生成器实现的方式中，我们将原本在迭代器`__next__`方法中实现的基本逻辑放到一个函数中来实现，但是将每次迭代返回数值的return换成了yield，此时新定义的函数便不再是函数，而是一个**生成器（模板）**了。(理解为类)

简单来说：只要**在def中有yield关键字**的 就称为 **生成器**。

此时按照调用函数的方式使用生成器就不再是执行函数体了，而是会返回一个生成器对象，然后就可以按照使用迭代器的方式来使用生成器了。 

```python
def create_num(all_num):
    print("--1--", end=" ")
    a, b = 0, 1
    current_num = 0
    while current_num < all_num:
        print("--2--", end=" ")
        yield a  # 如果一个函数中有yield语句，那么这个就不在是函数，而是一个生成器的模板
        print("--3--", end=" ")
        a, b = b, a+b
        current_num += 1
        print("--4--", end=" ")
    return "done"
# 如果在调用create_num的时候，发现这个函数中有yield那么此时，不是调用函数，而是创建一个生成器对象
obj = create_num(10)
ret = next(obj)
print(ret, end=" ")
ret = next(obj)
print(ret, end=" ")
print("=" * 10)
obj2 = create_num(2)  # 创建第二个生成器对象
while True:  # 通过异常判断生成器已经结束
    try:
        ret = next(obj2)
        print(ret, end=" ")
    except StopIteration as ret:
        print(ret.value)
        # 读取 return 的值  想要得到生成器对象return结果，需要捕获异常，再通过value属性获取
        break
# --1-- --2-- 0 --3-- --4-- --2-- 1 ==========
# --1-- --2-- 0 --3-- --4-- --2-- 1 --3-- --4-- done
```

用for循环调用generator时，发现拿不到generator的return语句的返回值。如果想要拿到返回值，必须捕获StopIteration错误，返回值包含在StopIteration的value中 

###### 创建生成器方法3 - send()

 使用send()函数来唤醒执行。使用send()函数的一个好处是可以在唤醒的同时向断点处传入一个附加数据。 

```python
def create_num(all_num):
    a, b = 0, 1
    current_num = 0
    while current_num < all_num:
        ret = yield a
        print("ret>>>", ret, end=" ")
        a, b = b, a+b
        current_num += 1
obj = create_num(10)
# obj.send(None)  # send一般不会放到第一次启动生成器，如果非要这样做 那么传递None
ret = next(obj)
print(ret, end=" ")
ret = next(obj)
print(ret, end=" ")
# send里面的数据会 传递给第5行，当做yield a的结果，然后ret保存这个结果,,, 
# send的结果是下一次调用yield时 yield后面的值
ret = obj.send("hahahha")  
print(ret, end=" ")
# 0 ret>>> None 1 ret>>> hahahha 1 
```

可以使用send修改create_num中的参数，比如修改current_num的值，或者增加一些条件等

###### 小结

生成器：让函数暂停执行

- 使用了yield关键字的函数不再是函数，而是生成器。（使用了yield的函数就是生成器）
- yield关键字有两点作用：
  - 保存当前运行状态（断点），然后暂停执行，即将生成器（函数）挂起
  - 将yield关键字后面表达式的值作为返回值返回，此时可以理解为起到了return的作用
- 可以使用next()函数让生成器从断点处继续执行，即唤醒生成器（函数）
- Python3中的生成器可以使用return返回最终运行的返回值

##### 协程 - yield

协程，又称微线程，纤程。英文名Coroutine。 

协程是python个中另外一种实现多任务的方式，只不过比线程更小占用更小执行单元（理解为需要的资源）。 为啥说它是一个执行单元，因为它自带CPU上下文。这样只要在合适的时机， 我们可以把一个协程 切换到另一个协程。 只要这个过程中保存或恢复 CPU上下文那么程序还是可以运行的。

通俗的理解：在一个线程中的某个函数，可以在任何地方保存当前函数的一些临时变量等信息，然后切换到另外一个函数中执行，注意不是通过调用函数的方式做到的，并且切换的次数以及什么时候再切换到原来的函数都由开发者自己确定

```python
import time
def work1():
    while True:
        print("----work1---")
        yield
        time.sleep(0.5)
def work2():
    while True:
        print("----work2---")
        yield
        time.sleep(0.5)
def main():
    w1 = work1()
    w2 = work2()
    # 先让w1运行一会，当w1中遇到yield的时候，返回，然后
    # 执行w2，当它遇到yield的时候，再次切换到w1中
    # 这样w1/w2/w1/w2的交替运行，最终实现了多任务....协程
    while True:
        next(w1)
        next(w2)
if __name__ == "__main__":
    main()
# 假的多任务，并发的   一个进程中的一个线程
```

###### 协程和线程差异

在实现多任务时, 线程切换从系统层面远不止保存和恢复 CPU上下文这么简单。 操作系统为了程序运行的高效性每个线程都有自己缓存Cache等等数据，操作系统还会帮你做这些数据的恢复操作。 所以线程的切换非常耗性能。但是协程的切换只是单纯的操作CPU的上下文，所以一秒钟切换个上百万次系统都抗的住。

##### 协程 - greenlet

 为了更好使用协程来完成多任务，python中的greenlet模块对其封装，从而使得切换任务变的更加简单。

```python
from greenlet import greenlet
import time
def test1():
    while True:
        print("---A--")
        gr2.switch()
        time.sleep(0.5)
def test2():
    while True:
        print("---B--")
        gr1.switch()
        time.sleep(0.5)
gr1 = greenlet(test1)  # 返回值是 greenlet 对象
gr2 = greenlet(test2)
gr1.switch()  # 切换到gr1中运行
```

##### 协程 - gevent

greenlet已经实现了协程，但是还得人工切换，python还有一个比greenlet更强大的并且能够自动切换任务的模块`gevent` 

其原理是当一个greenlet遇到IO(指的是input output 输入输出，比如网络、文件操作等)操作时，比如访问网络，就自动切换到其他的greenlet，等到IO操作完成，再在适当的时候切换回来继续执行。

由于IO操作非常耗时，经常使程序处于等待状态，有了gevent为我们自动切换协程，就保证总有greenlet在运行，而不是等待IO

###### gevent的使用

```python
import gevent
def f1(n):
    for i in range(n):
        print(gevent.getcurrent(), i)  #  gevent.getcurrent() 当前哪一个
        # time.sleep(0.5)  # 不可以，gevent不认为是耗时操作
        gevent.sleep(0.5)  # 模拟一个耗时操作 会自动切换
def f2(n):
    for i in range(n):
        print(gevent.getcurrent(), i)
        gevent.sleep(0.5)
def f3(n):
    for i in range(n):
        print(gevent.getcurrent(), i)
        gevent.sleep(0.5)
g1 = gevent.spawn(f1, 5)  # 参数一：去哪执行 二：参数  创建时不会执行
g2 = gevent.spawn(f2, 5)
g3 = gevent.spawn(f3, 5)
g1.join()  # 等待g1执行完  耗时操作，gevent自动开始切换
g2.join()
g3.join()
```

线程结束时协程死亡

`green.spawn`会启动所有协程，协程都是运行在同一个线程之中的，所以协程不能够跨线程同步数据。 

延时、堵塞等 都需要使用 gevent 中的，通过打补丁 自动实现

在Gevent中`gevent.sleep()`模拟的是Gevent可以识别的IO阻塞，若使用`time.sleep()`或其他阻塞，Gevent是不能够直接识别的，需要使用猴子补丁

###### 给程序打补丁

```python
from gevent import monkey  # 必须放在被打补丁的前面，如time、socket模块之前
import gevent
import random
import time

# 有耗时操作时需要
monkey.patch_all()  # 将程序中用到的耗时操作的代码，换为gevent中自己实现的模块

def coroutine_work(coroutine_name):
    for i in range(10):
        print(coroutine_name, i)
        time.sleep(random.random())

gevent.joinall([  # 等待所有，需要list
        gevent.spawn(coroutine_work, "work1"),
        gevent.spawn(coroutine_work, "work2")
])  # 等待所有协程执行完，才会结束
```

协程用 gevent，前两种都是原理。

##### 案例：图片下载器

实现：`gevent_img_downloader.py` 文件

##### 进程、线程、协程对比

请仔细理解如下的通俗描述：

- 有一个老板想要开个工厂进行生产某件商品（例如剪子）
- 他需要花一些财力物力制作一条生产线，这个生产线上有很多的器件以及材料这些所有的 为了能够生产剪子而准备的资源称之为：进程
- 只有生产线是不能够进行生产的，所以老板的找个工人来进行生产，这个工人能够利用这些材料最终一步步的将剪子做出来，这个来做事情的工人称之为：线程
- 这个老板为了提高生产率，想到3种办法：
  1. 在这条生产线上多招些工人，一起来做剪子，这样效率是成倍増长，即单进程 多线程方式
  2. 老板发现这条生产线上的工人不是越多越好，因为一条生产线的资源以及材料毕竟有限，所以老板又花了些财力物力购置了另外一条生产线，然后再招些工人这样效率又再一步提高了，即多进程 多线程方式
  3. 老板发现，现在已经有了很多条生产线，并且每条生产线上已经有很多工人了（即程序是多进程的，每个进程中又有多个线程），为了再次提高效率，老板想了个损招，规定：如果某个员工在上班时临时没事或者再等待某些条件（比如等待另一个工人生产完谋道工序 之后他才能再次工作） ，那么这个员工就利用这个时间去做其它的事情，那么也就是说：如果一个线程等待某些条件，可以充分利用这个时间去做其它事情，其实这就是：协程方式

简单总结

1. 进程是资源分配的单位
2. 线程是操作系统调度的单位
3. 进程切换需要的资源很最大，效率很低
4. 线程切换需要的资源一般，效率一般（当然了在不考虑GIL的情况下）
5. 协程切换任务资源很小，效率高
6. 多进程、多线程根据cpu核数不一样可能是并行的，但是协程是在一个线程中 所以是并发

### 2 Web 服务器

#### 正则表达式

判断是否符合条件//数据清洗，得到想要的数据

```python
import re  # 导入re模块
# 使用match方法进行匹配操作
result = re.match(正则表达式,要匹配的字符串)
# 如果上一步匹配到数据的话，可以使用group方法来提取数据
result.group()  # 满足要求的数据
```

```python
print(re.match(r"Chen", "ChenRong123"))  # 匹配出来陈
# run：<re.Match object; span=(0, 4), match='Chen'>
```

match：尝试从字符串的起始位置匹配一个模式，如果不是起始位置匹配成功的话，match()就返回none。 （匹配到会返回值,不然返回None）

##### 匹配单个字符

正则表达式的单字符匹配：

- `. `：匹配任意1个字符（除了\n）
- `[] `：匹配[ ]中列举的字符
- `\d `：匹配数字，即0-9
- `\D `：匹配非数字，即不是数字，大写字母都与小写相反
- `\s `：匹配空白，即 空格，tab键
- `\S `：匹配非空白
- `\w `：匹配单词字符，即a-z、A-Z、0-9、_ ，慎用，匹配中文等也可以
- `\W `：匹配非单词字符 

```python
import re
ret = re.match(r"t.o","two")
print(ret.group())
# 匹配0到9第一种写法
ret = re.match(r"[0123456789]Hello Python","7Hello Python")
print(ret.group())
# 匹配0到9第二种写法
ret = re.match(r"[0-9]Hello Python","7Hello Python")  # 连续的可以用 -
print(ret.group())
# 下面这个正则不能够匹配到数字4，因此ret为None
ret = re.match(r"[0-35-9]Hello Python","4Hello Python")
ret = re.match(r"[1-8a-c]Hello Python","aHello Python")  # 可以组合字母与数字
print(ret.group())
# 使用\d进行匹配
ret = re.match(r"嫦娥\d号","嫦娥1号发射成功") 
print(ret.group())
# 使用\w进行匹配
ret = re.match(r"\wHello Python","_Hello Python")
print(ret.group())
ret = re.match(r"\wHello Python","=Hello Python")
```

##### 匹配多个字符

匹配多个字符的相关格式，与其他配合

- `*`：匹配前一个字符出现0次或者无限次，即可有可无
- `+`：匹配前一个字符出现1次或者无限次，即至少有1次
- `?`：匹配前一个字符出现1次或者0次，即要么有1次，要么没有
- `{m}`：匹配前一个字符出现m次
- `{m,n}`：匹配前一个字符出现从m到n次

```python
import re
ret = re.match(r"\d{3,4}-?\d{8}","010-12345678")
print(ret.group())
html_content = """
sadad
caacd
23dcd
"""
ret = re.match(r".*",html_content)
print(ret.group())  # sadad
ret = re.match(r".*",html_content, re.S)  # re.S 使. 匹配 \n
print(ret.group())
# 匹配变量名是否有效
names = ["age", "_age", "1age", "age1", "a_age", "age_1_", "age!", "a#123", "__________"]
for name in names:
    # ^规定开头  $规定结尾  
    # python中的match默认是从头开始判断的所以，在match中可以不写^，
    # 但是match不会判断结尾，所以当需要以xxx结尾的时候 还需要写上$
    # ret = re.match(r"[A-Za-Z_]+[A-Za-Z_0-9]*", name) # 不需要+，这样就是一位
    ret = re.match(r"^[A-Za-Z_]+[A-Za-Z_0-9]*$", name)
    if ret:
        print("变量名:%s 符合要求....通过正则匹配出来的数据是:%s" % (name, ret.group()))
    else:
        print("变量名:%s 不符合要求...." % name)
```

##### 匹配开头结尾

- `^`：匹配字符串开头  （还有取反的含义）
- `$`：匹配字符串结尾

```python
# 匹配出163的邮箱地址，且@符号之前有4到20位英文、数字、下划线，例如hello@163.com
import re
email = input("请输入一个邮箱地址:")
# 如果在正则表达式中需要用到了某些普通的字符，比如 . 比如? 等，
# 仅仅需要在他们前面添加一个 反斜杠进行转义
ret = re.match(r"[a-zA-Z0-9_]{4,20}@163\.com$", email)
if ret:
	print("%s符合要求...." % email)
else:
	print("%s不符合要求...." % email)
```

##### 匹配分组

- `|`：匹配左右任意一个表达式
- `(ab)`：将括号中字符作为一个分组
- `\num`：引用分组num匹配到的字符串
- `(?P<name>)`：分组起别名
- `(?P=name)`：引用别名为name分组匹配到的字符串

```python
ret = re.match("[a-zA-Z0-9_]{4,20}@(163|126|qq)\.com$", "test@qq.com")
print(ret.group())  # test@qq.com
# () 还可以取数据 匹配成功后的
ret = re.match("([a-zA-Z0-9_]{4,20})@(163|126|qq)\.com$", "test@qq.com")
print(ret.group(1))  # test
print(ret.group(2))  # qq
# 使用 \num
ret = re.match(r"<([a-zA-Z]*)>\w*</\1>", "<html>hh</html>")  # \1 取分组中匹配的值
print(ret.group())
html_str = "<body><h1>hahahah</h1></body>"
ret = re.match(r"<(\w*)><(\w*)>.*</\2></\1>", html_str)
print(ret.group())
# 使用 (?P<name>)、(?P=name) 适用于分组很多时
ret = re.match(r"<(?P<p1>\w*)><(?P<p2>\w*)>.*</(?P=p2)></(?P=p1)>", html_str)
print(ret.group())
```

##### re 模块的高级用法

search： 扫描整个字符串并返回第一个成功的匹配。 

```python
import re
ret = re.search(r"\d+", "阅读次数为 9999")
print(ret.group())  # 9999
```

findall：在字符串中找到正则表达式所匹配的所有子串，并返回一个列表，如果没有找到匹配的，则返回空列表。

```python
import re
ret = re.findall(r"\d+", "python = 9999, c = 7890, c++ = 12345")
print(ret)  # ['9999', '7890', '12345']
```

sub：用于替换字符串中的匹配项 

```python
import re
ret = re.sub(r"\d+", '998', "python = 997, c++ = 1024")
print(ret)  # python = 998, c++ = 998
# sub 支持函数调用
def add(temp):
    strNum = temp.group()
    num = int(strNum) + 1
    return str(num)
ret = re.sub(r"\d+", add, "python = 99")
print(ret)  # python = 100
```

split：按照能够匹配的子串将字符串分割后返回列表

```python
import re
ret = re.split(r":| ","info:xiaoZhang 33 shandong")
print(ret)  # ['info', 'xiaoZhang', '33', 'shandong']
```

```python
import re
html_str = """
<dd class="job_bt">
        <h3 class="description">职位描述：</h3>
        <div>
        <p>职位诱惑：<br>机器学习相关项目，完全新技术驱动，互联网公司，工作氛围好，扁平管理，有技术大牛带<br><br>职位描述：<br>配合架构师和机器学习专家，完成项目的编码、测试和上线。<br><br>我们期望：<br>1.&nbsp;211院校计算机相关专业本科以上学历；<br>2.&nbsp;有扎实的编程和计算机基础，熟悉常用算法和数据结构。<br>3.&nbsp;具有很强的问题解决能力，综合知识（或者通过搜索能快速掌握知识）强，了解前端、网络、多线程、数据库、Web开发等知识。<br>4.&nbsp;2年以上工作经验（Python或者JAVA方向，如果编程能力特别过硬可以放开语言要求）；<br><br>工作内容：<br>1.&nbsp;根据业务需求进行需求分析和代码编写；<br>2.&nbsp;结合系统实现对代码进行充分的自测，以及配合测试工程师联合进行测试；<br>3.&nbsp;配合机器学习算法专家进行代码编写</p>
        </div>
    </dd>
"""
ret = re.findall(r"<[^>]*>", html_str)
# [^>]表示不是 > 的字符，*表示重复零次或更多次，这个意思是非 > 的字符可以有一个或多个，也可以没有。
# 意思就是不能有 > ,这 把 * 换为 + 一样  因为没有 <>这种
print(ret)
ret = re.sub(r"<[^>]*>|\s|&nbsp;", "", html_str)
print(ret)5
```

 当符号`^`在方括号表达式(`[]`)中使用时，表示**不接受该方括号表达式中的字符集合**。要匹配`^`字符本身，请使用 `\^`。 

##### 贪婪和非贪婪

Python里数量词默认是贪婪的，总是尝试匹配尽可能多的字符；非贪婪则相反，总是尝试匹配尽可能少的字符。在"*","?","+","{m,n}"后面加上？，使贪婪变成非贪婪。

```python
import re
s="This is a number 234-235-22-423"
r=re.match(r".+(\d+-\d+-\d+-\d+)",s)
print(r.group(1))  # '4-235-22-423'
r=re.match(r".+?(\d+-\d+-\d+-\d+)",s)
print(r.group(1))  # '234-235-22-423'
```

正则表达式模式中使用到通配字，那它在从左到右的顺序求值时，会尽量“抓取”满足匹配最长字符串，在我们上面的例子里面，“.+”会从字符串的启始处抓取满足模式的最长字符，其中包括我们想得到的第一个整型字段的中的大部分，“\d+”只需一位字符就可以匹配，所以它匹配了数字“4”，而“.+”则匹配了从字符串起始到这个第一位数字4之前的所有字符。

解决方式：非贪婪操作符“？”，这个操作符可以用在"*","+","?"的后面，要求正则匹配的越少越好。

```python
import re
ret = re.match(r"aa(\d+?)","aa2343ddd")
print(ret.group(1))  # '2'
ret = re.match(r"aa(\d+?)ddd","aa2343ddd")
print(ret.group(1))  # '2343'  由于限制了后边 非贪婪也是同样的结果
img_url = """<img data-original="https://rpic.douyucdn.cn/appCovers/2016/11/13/1213973_201611131917_small.jpg" src="https://rpic.douyucdn.cn/appCovers/2016/11/13/1213973_201611131917_small.jpg" style="display: inline;">"""
ret = re.search(r"https://.*?\.jpg", img_url)
print(ret.group())
```

##### r 的作用

 Python中字符串前面加上 r 表示原生字符串 

```python
import re
my_path = "c:\\a\\b\\c"
print(my_path)
print(re.match("c:\\\\a\\\\b\\\\c", my_path).group())
print(re.match(r"c:\\a\\b\\c", my_path).group())
```

>  正则表达式使用反斜杆（`\`）来转义特殊字符，使其可以匹配字符本身，而不是指定其他特殊的含义。这可能会和python字面意义上的字符串转义相冲突。比如，要匹配一个反斜杆本身，你也许要用`\\\\`来做为正则表达式的字符串，因为正则表达式要是`\\`，而字符串里，每个反斜杆都要写成`\\` 。
>
> 你也可以在字符串前加上 r 这个前缀来避免部分疑惑，因为 r 开头的python字符串是 raw 字符串，所以里面的所有字符都不会被转义，比如属`r'\n'`这个字符串就是一个反斜杆加上一字母n，而`'\n'`是个换行符。因此，上面的`'\\\\'`可以写成`r'\\'`，这样，应该就好理解很多了。

Python里的原生字符串很好地解决了这个问题，写出来的表达式也更直观。

#### HTTP 协议简介

在Web应用中，服务器把网页传给浏览器，实际上就是把网页的HTML代码发送给浏览器，让浏览器显示出来。而浏览器和服务器之间的传输协议是HTTP，所以：

- HTML是一种用来定义网页的文本，会HTML，就可以编写网页；
- HTTP是在网络上传输HTML的协议，用于浏览器和服务器的通信。

开发者工具中：Elements显示网页的结构、Network显示浏览器和服务器的通信

##### HTTP 协议的分析

发送或响应的数据是有格式的，这就是HTTP协议。（可用网络调试助手和浏览器模拟请求与响应）

##### 浏览器请求

最主要的头两行分析如下，第一行：`GET / HTTP/1.1`

GET表示一个读取请求，将从服务器获得网页数据（要），/表示URL的路径，URL总是以/开头，/就表示首页，最后的HTTP/1.1指示采用的HTTP协议版本是1.1。目前HTTP协议的版本就是1.1，但是大部分服务器也支持1.0版本，主要区别在于1.1版本允许多个HTTP请求复用一个TCP连接(长连接)，以加快传输速度。

从第二行开始，每一行都类似于Xxx: abcdefg（为字符串），如`Host: www.sina.com`，表示请求的域名是`www.sina.com`。如果一台服务器有多个网站，服务器就需要通过Host来区分浏览器请求的是哪个网站。

 **HTTP协议里，一个Header一行** 

> 长连接；接受的格式；浏览器版本；接受的压缩格式；接受的语言 等等

**发送的Header是告诉服务器怎么做/要求**

发送的请求格式如下：

```http
GET / HTTP/1.1
Host: www.baidu.com
Connection: keep-alive
Cache-Control: max-age=0
Upgrade-Insecure-Requests: 1
User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/74.0.3729.131 Safari/537.36
Accept:text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3
Accept-Encoding: gzip, deflate, br
Accept-Language: zh-CN,zh;q=0.9
```

HTTP请求分为Header和Body两部分。POST 时 会有 Body。

##### 服务器响应

HTTP响应分为Header和Body两部分（Body是可选项），我们在Network中看到的Header最重要的几行如下：

`HTTP/1.1 200 OK` ：200表示一个成功的响应，后面的OK是说明。如果返回的不是200，那么往往有其他的功能，例如：失败的响应有404 Not Found：网页不存在；500 Internal Server Error：服务器内部出错；等等。

`Content-Type: text/html`：Content-Type指示响应的内容，这里是text/html表示HTML网页。

> 请注意，浏览器就是依靠Content-Type来判断响应的内容是网页还是图片，是视频还是音乐。浏览器并不靠URL来判断响应的内容，所以，即使URL是`http://www.baidu.com/meimei.jpg`，它也不一定就是图片。

**响应的Header是告诉浏览器怎么做/要求**

响应的数据格式如下：

```http
HTTP/1.1 200 OK
Bdpagetype: 2
Bdqid: 0xced4a9a1000734e4
Cache-Control: private
Connection: keep-alive
Content-Encoding: gzip
Content-Type: text/html;charset=utf-8
Date: Tue, 14 Apr 2020 09:38:07 GMT
Expires: Tue, 14 Apr 2020 09:38:06 GMT
Server: BWS/1.1
Set-Cookie: BDSVRTM=316; path=/
Set-Cookie: BD_HOME=1; path=/
Set-Cookie: H_PS_PSSID=1461_31125_21111_31187_30908_30823_31085_31164_31196; path=/; domain=.baidu.com
Strict-Transport-Security: max-age=172800
Traceid: 1586857087060169268214903723575831114980
X-Ua-Compatible: IE=Edge,chrome=1
Transfer-Encoding: chunked

<!DOCTYPE html>
等等
```

HTTP响应的Body就是HTML源码，选择查看网页源码可以在浏览器中直接查看HTML源码。

Header是连续的，没有空行，只要有空行，则后边内容为Body。HTTP 中的换行使用：`\r\n`

##### 浏览器解析过程

当浏览器读取到新浪首页的HTML源码后，它会解析HTML，显示页面，然后，根据HTML里面的各种链接，再发送HTTP请求给新浪服务器，拿到相应的图片、视频、Flash、JavaScript脚本、CSS等各种资源，最终显示出一个完整的页面。所以我们在Network下面能看到很多额外的HTTP请求。

##### HTTP 小结

###### HTTP 请求与响应

步骤1：浏览器首先向服务器发送HTTP请求，请求包括：

> **方法**：GET还是POST，GET仅请求资源，POST会附带用户数据；**路径**：/full/url/path；**域名**：由Host头指定：`Host: www.sina.com`；以及其他相关的Header；
>
> 如果是POST，那么请求还包括一个Body，包含用户数据

步骤2：服务器向浏览器返回HTTP响应，响应包括：

> **响应代码**：200表示成功，3xx表示重定向，4xx表示客户端发送的请求有错误，5xx表示服务器端处理时发生了错误；**响应类型**：由Content-Type指定；以及其他相关的Header；
>
> 通常服务器的HTTP响应会携带内容，也就是有一个Body，包含响应的内容，网页的HTML源码就在Body中。

步骤3：如果浏览器还需要继续向服务器请求其他资源，比如图片，就再次发出HTTP请求，重复步骤1、2。

> Web采用的HTTP协议采用了非常简单的请求-响应模式，从而大大简化了开发。当我们编写一个页面时，我们只需要在HTTP请求中把HTML发送出去，不需要考虑如何附带图片、视频等，浏览器如果需要请求图片和视频，它会发送另一个HTTP请求，因此，**一个HTTP请求只处理一个资源(此时就可以理解为TCP协议中的短连接，每个链接只获取一个资源，如需要多个就需要建立多个连接)**

HTTP协议同时具备极强的扩展性，虽然浏览器请求的是`http://www.sina.com`的首页，但是新浪在HTML中可以链入其他服务器的资源，比如`<img src="http://i1.sinaimg.cn/home/2013/1008/U8455P30DT20131008135420.png">  `，从而将请求压力分散到各个服务器上，并且，一个站点可以链接到其他站点，无数个站点互相链接起来，就形成了World Wide Web，简称WWW。

###### HTTP 格式

每个HTTP请求和响应都遵循相同的格式，一个HTTP包含Header和Body两部分，其中Body是可选的。HTTP协议是一种文本协议，所以，它的格式也非常简单。

**HTTP GET请求的格式：**

```http
GET /path HTTP/1.1
Header1: Value1
Header2: Value2
Header3: Value3
```

**每个Header一行一个，换行符是`\r\n`。**

**HTTP POST请求的格式：**

```http
POST /path HTTP/1.1
Header1: Value1
Header2: Value2
Header3: Value3

body data goes here...
```

**当遇到连续两个`\r\n`时，Header部分结束，后面的数据全部是Body。**

**HTTP响应的格式：**

````http
200 OK
Header1: Value1
Header2: Value2
Header3: Value3

body data goes here...
```

HTTP响应如果包含body，也是通过**两个`\r\n`来分隔**的。

Body的数据类型由Content-Type头来确定，如果是网页，Body就是文本，如果是图片，Body就是图片的二进制数据。

当存在Content-Encoding时，Body数据是被压缩的，最常见的压缩方式是gzip，所以，看到Content-Encoding: gzip时，需要将Body数据先解压缩，才能得到真正的数据。压缩的目的在于减少Body的大小，加快网络传输。

#### Web静态服务器

##### Web静态服务器-1-显示固定的页面

python 实现服务器，浏览器请求

```python
# show_a_html.py
import socket
def service_client(new_socket):
    """为这个客户端返回数据"""
    # 1. 接收浏览器发送过来的请求 ，即http请求  
    # GET / HTTP/1.1
    # .....
    request = new_socket.recv(1024)
    print(request)
    # 2. 返回http格式的数据，给浏览器
    # 2.1 准备发送给浏览器的数据---header
    response = "HTTP/1.1 200 OK\r\n"
    response += "\r\n"  # 浏览器解析换行 用\r\n
    # 2.2 准备发送给浏览器的数据---body
    response += "hahahhah"
    new_socket.send(response.encode("utf-8"))
    new_socket.close()  # 关闭套接字 !
def main():
    """用来完成整体的控制"""
    tcp_server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)  # 1. 创建套接字
    tcp_server_socket.bind(("", 7890))  # 2. 绑定
    tcp_server_socket.listen(128)  # 3. 变为监听套接字
    while True:
        new_socket, client_addr = tcp_server_socket.accept()  # 4. 等待新客户端的链接
        service_client(new_socket)  # 5. 为这个客户端服务
    tcp_server_socket.close()  # 关闭监听套接字 !
if __name__ == "__main__":
    main()
```

##### TCP 的`3`次握手

<img src="https://user-images.githubusercontent.com/51505633/79301086-28963a80-7f1b-11ea-81e8-874a05acc295.png" alt="三次握手、四次挥手" style="zoom:67%;" />

# TCP 的`4`次挥手



3次握手的开始是 connect发起，成功是服务器调用 accept



4次原因



服务器 超时时间

客户端 等2分多 防止 服务器没收到应答，再次发送

 2 MSL

谁先调 close  谁等待

客户端端口随机

##### Web静态服务器-2-显示需要的页面

```python
# show_need_html.py
import socket
import re
import os
def service_client(new_socket):
    """为这个客户端返回数据"""
    # 1. 接收浏览器发送过来的请求 ，即http请求  
    # GET / HTTP/1.1
    # .....
    request = new_socket.recv(1024).decode("utf-8")
    print(">>>"*50)
    print(request)
    request_lines = request.splitlines()  # 先切割
    print("")
    print(">"*20)
    print(request_lines)
    # GET /index.html HTTP/1.1
    # get post put del
    file_name = ""
    ret = re.match(r"[^/]+(/[^ ]*)", request_lines[0]) # 不是/都行  空格停
    if ret:
        file_name = ret.group(1)
        print("*"*50, file_name)
        if file_name == "/":  # 这需要上面的变量
            file_name = "/index.html"
        file_name = file_name[1:]  # 和linux 不同，路径不一致 这用替换更好
    # 2. 返回http格式的数据，给浏览器
    file_path = os.path.join(".\html", file_name)
    print("file_path >>> ", file_path)
    try:
        f = open(file_path, "rb")  # 打开文件有危险
    except:
        response = "HTTP/1.1 404 NOT FOUND\r\n"
        response += "\r\n"
        response += "------file not found-----"
        new_socket.send(response.encode("utf-8"))
    else:
        html_content = f.read()
        f.close()
        # 2.1 准备发送给浏览器的数据---header
        response_header = "HTTP/1.1 200 OK\r\n"
        response_header += "\r\n"
        # 2.2 准备发送给浏览器的数据---boy
        response_body = html_content
        response = response_header.encode("utf-8") + response_body
        # 将response发送给浏览器
        new_socket.send(response)
        # 将response body发送给浏览器
        # new_socket.send(html_content)
    # 关闭套接字
    new_socket.close()
def main():
    """用来完成整体的控制"""
    # 1. 创建套接字
    tcp_server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)  # 1. 创建套接字
    # 设置当服务器先close 即服务器端4次挥手之后资源能够立即释放
    # 这样就保证了，下次运行程序时 可以立即绑定7890端口
    tcp_server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    # 2. 绑定
    tcp_server_socket.bind(("127.0.0.1", 7899))
    # 3. 变为监听套接字
    tcp_server_socket.listen(128)
    while True:
        # 4. 等待新客户端的链接
        new_socket, client_addr = tcp_server_socket.accept()
        # 5. 为这个客户端服务
        service_client(new_socket)
    # 关闭监听套接字
    tcp_server_socket.close()
if __name__ == "__main__":
    main()
```

以上代码需要 html 文件夹

存在问题：有时候 request 返回空值，会报错！当客户端的套接字调用close后，服务器端会recv解堵塞，并且返回的长度为0，因此服务器可以通过返回数据的长度来区别客户端是否已经下线?

```python
server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
# 设置当服务器先close 即服务器端4次挥手之后资源能够立即释放，这样就保证了
# 下次运行程序时 可以立即绑定7788端口
```

##### Web静态服务器-3-多进程

需要在主进程调用new_socket.close()，未修改文件目录

```python
import socket
import re
import multiprocessing
def service_client(new_socket):
    """为这个客户端返回数据"""
    request = new_socket.recv(1024).decode("utf-8")
    request_lines = request.splitlines()
    file_name = ""
    ret = re.match(r"[^/]+(/[^ ]*)", request_lines[0])
    if ret:
        file_name = ret.group(1)
        if file_name == "/":
            file_name = "/index.html"
    try:
        f = open("./html" + file_name, "rb")
    except:
        response = "HTTP/1.1 404 NOT FOUND\r\n"
        response += "\r\n"
        response += "------file not found-----"
        new_socket.send(response.encode("utf-8"))
    else:
        html_content = f.read()
        f.close()
        response = "HTTP/1.1 200 OK\r\n"
        response += "\r\n"
        new_socket.send(response.encode("utf-8"))
        new_socket.send(html_content)
    # 关闭套接字
    new_socket.close()
def main():
    """用来完成整体的控制"""
    tcp_server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    tcp_server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    tcp_server_socket.bind(("", 7890))
    tcp_server_socket.listen(128)
    while True:
        new_socket, client_addr = tcp_server_socket.accept()
        # 5. 为这个客户端服务
        p = multiprocessing.Process(target=service_client, args=(new_socket,))
        p.start()
        new_socket.close()  # 子进程复制了new_socket，关闭的是子进程的，主进程还需要关闭
        # 主进程不调用close时, 浏览器会一直的等待, 四次挥手就不会开始!
        # 两个 new_socket 指向的同一个文件 类似于
    # 关闭监听套接字
    tcp_server_socket.close()
if __name__ == "__main__":
    main()
```

##### Web静态服务器-4-多线程

无需在主线程调用new_socket.close()，未修改文件目录

```python
import socket
import re
import threading
def service_client(new_socket):
    """为这个客户端返回数据"""
    request = new_socket.recv(1024).decode("utf-8")
    request_lines = request.splitlines()
    file_name = ""
    ret = re.match(r"[^/]+(/[^ ]*)", request_lines[0])
    if ret:
        file_name = ret.group(1)
        if file_name == "/":
            file_name = "/index.html"
    try:
        f = open("./html" + file_name, "rb")
    except:
        response = "HTTP/1.1 404 NOT FOUND\r\n"
        response += "\r\n"
        response += "------file not found-----"
        new_socket.send(response.encode("utf-8"))
    else:
        html_content = f.read()
        f.close()
        response = "HTTP/1.1 200 OK\r\n"
        response += "\r\n"
        new_socket.send(response.encode("utf-8"))
        new_socket.send(html_content)
    # 关闭套接字
    new_socket.close()
def main():
    """用来完成整体的控制"""
    tcp_server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    tcp_server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    tcp_server_socket.bind(("", 7890))
    tcp_server_socket.listen(128)
    while True:
        new_socket, client_addr = tcp_server_socket.accept()
        # 5. 为这个客户端服务
        p = threading.Thread(target=service_client, args=(new_socket,))
        p.start()
        # new_socket.close() 多线程没有复制,共享，不需要close
    # 关闭监听套接字
    tcp_server_socket.close()
if __name__ == "__main__":
    main()
```

区别: 线程比线程耗费的资源小, 以下用协程实现, 会更方便 

多进程、多线程 在请求量的大时消耗资源过大

##### Web静态服务器-5-协程

使用gevent实现http服务器，效率最高

```python
from gevent import monkey
import socket
import re
import gevent
monkey.patch_all()
def service_client(new_socket):
    """为这个客户端返回数据"""
    request = new_socket.recv(1024).decode("utf-8")
    request_lines = request.splitlines()
    file_name = ""
    ret = re.match(r"[^/]+(/[^ ]*)", request_lines[0])
    if ret:
        file_name = ret.group(1)
        if file_name == "/":
            file_name = "/index.html"
    try:
        f = open("./html" + file_name, "rb")
    except:
        response = "HTTP/1.1 404 NOT FOUND\r\n"
        response += "\r\n"
        response += "------file not found-----"
        new_socket.send(response.encode("utf-8"))
    else:
        html_content = f.read()
        f.close()
        response = "HTTP/1.1 200 OK\r\n"
        response += "\r\n"
        new_socket.send(response.encode("utf-8"))
        new_socket.send(html_content)
    # 关闭套接
    new_socket.close()
def main():
    """用来完成整体的控制"""
    tcp_server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    tcp_server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    tcp_server_socket.bind(("", 7890))
    tcp_server_socket.listen(128)
    while True:
        new_socket, client_addr = tcp_server_socket.accept()
        # 5. 为这个客户端服务
        gevent.spawn(service_client, new_socket)
        # new_socket.close()
    # 关闭监听套接字
    tcp_server_socket.close()
if __name__ == "__main__":
    main()
```

 `green.spawn`会启动所有协程，协程都是运行在同一个线程之中的，所以协程不能够跨线程同步数据。 

原来的`join()` 和` joinall()` 都是为了阻塞当前流程，并执行所有给定的Greenlet，执行流只会在所有的Greenlet执行完毕后才会继续向下执行。 

而现在是无限循环，因此不需要`join()` 和` joinall()` 

##### Web静态服务器-6-单进程-单线程-非堵塞模式

单进程-单线程 时 会在 recv() 堵塞， accept无法服务，因此要实现 单进程-单线程 时 不堵塞

由于套接字默认堵塞，可用如下命令设置套接字为非堵塞的方式

`tcp_server_tcp.setblocking(False)  # 设置套接字为非堵塞的方式`

非堵塞时，accept() 、recv()数据没来 会产生异常，需要异常处理

```python
import socket
import time
tcp_server_tcp = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
tcp_server_tcp.bind(("", 7899))
tcp_server_tcp.listen(128)
tcp_server_tcp.setblocking(False)  # 设置套接字为非堵塞的方式
# while True:
#     try:
#         new_socket, new_addr = tcp_server_tcp.accept()
#     except Exception as ret:
#         print("---没有新的客户端到来---")
#     else:
#         print("---只要没有产生异常，那么也就意味着 来了一个新的客户端----")
#         new_socket.setblocking(False)  # 设置套接字为非堵塞的方式 因为默认堵塞
#         try:
#             recv_data = new_socket.recv(1024)
#            except Exception as ret:
#                 print(ret)
#                 print("----这个客户端没有发送过来数据----")
#             else:
#                 print("-----没有异常,客户端发送过来数据-----")
#                 print(recv_data)
# 上面存在问题 有一个客户端到来时 但没有数据，再次while时 就变为等新客户端到来
# 把 第二个 try 移出去， 使用list 保存 请求的客户端
# client_socket_list.append(new_socket)
client_socket_list = list()
while True:
    time.sleep(0.5)
    try:
        new_socket, new_addr = tcp_server_tcp.accept()
    except Exception as ret:
        print("---没有新的客户端到来---")
    else:
        print("---只要没有产生异常，那么也就意味着 来了一个新的客户端----")
        new_socket.setblocking(False)  # 设置套接字为非堵塞的方式
        client_socket_list.append(new_socket)
    for client_socket in client_socket_list:
        try:
            recv_data = client_socket.recv(1024)  # 对方调用close后 删除套接字
        except Exception as ret:
            print(ret)
            print("----这个客户端没有发送过来数据----")
        else:
            print("-----没有异常-----")
            print(recv_data)
            if recv_data:
                # 对方发送过来数据
                print("----客户端发送过来了数据-----")
            else:
                # 对方调用close 导致了 recv返回
                client_socket.close()  # 这都是引用 执行顺序可以换
                client_socket_list.remove(client_socket)
                print("---客户端已经关闭----")
```

上述代码实现了单进程-单线程，监听多个套接字

普通的方式，单进程-单线程会堵塞，导致多浏览器访问时等待，所以使用多线程、多进程为其服务；上边代码是单进程-单线程，通过非阻塞监听多个套接字，实现了同样的目的。

因为列表的循环执行的，所以是并发服务器。

系统先收数据，有个缓存区，recv 时取走数据(0.5 秒检查，短时间到达缓存区的，会一起取走)，没有则产生异常/堵塞。

##### 长连接、短连接

TCP在真正的读写操作之前，server与client之间必须建立一个连接，当读写操作完成后，双方不再需要这个连接时它们可以释放这个连接，连接的建立通过三次握手，释放则需要四次握手，所以说每个连接的建立都是需要资源消耗和时间消耗的。

###### TCP短连接

模拟一种TCP短连接的情况:

1. client 向 server 发起连接请求
2. server 接到请求，双方建立连接
3. client 向 server 发送消息
4. server 回应 client
5. 一次读写完成，此时双方任何一个都可以发起 close 操作

在步骤5中，一般都是 client 先发起 close 操作。当然也不排除有特殊的情况。从上面的描述看，短连接一般只会在 client/server 间传递一次读写操作！

###### TCP长连接

再模拟一种长连接的情况:

1. client 向 server 发起连接
2. server 接到请求，双方建立连接
3. client 向 server 发送消息
4. server 回应 client
5. 一次读写完成，连接不关闭
6. 后续读写操作...
7. 长时间操作之后client发起关闭请求

###### TCP长/短连接操作过程

- 短连接的操作步骤是：建立连接——数据传输——关闭连接...建立连接——数据传输——关闭连接
- 长连接的操作步骤是：建立连接——数据传输...（保持连接）...数据传输——关闭连接

###### TCP长/短连接的优点和缺点

- **长连接**可以**省**较多的**TCP建立和关闭**的操作，减少浪费，节约时间。对于**频繁请求资源**的客户来说，较**适用长连接**。
- client与server之间的连接如果一直不关闭的话，会存在一个问题，随着客户端连接越来越多，server早晚有扛不住的时候，这时候server端需要采取一些策略，如关闭一些长时间没有读写事件发生的连接，这样可以避免一些恶意连接导致server端服务受损；如果条件再允许就可以以客户端机器为颗粒度，限制每个客户端的最大长连接数，这样可以完全避免某个蛋疼的客户端连累后端服务。
- **短连接**对于服务器来说**管理较为简单**，存在的连接都是有用的连接，**不需要额外的控制手段**。但**如果客户请求频繁**，将在**TCP的建立和关闭操作上浪费时间和带宽**。

###### TCP长/短连接的应用场景

-  长连接多用于操作频繁，点对点的通讯，而且连接数不能太多情况。 例如：数据库的连接用长连接，如果用短连接频繁的通信会造成socket错误，而且频繁的socket 创建也是对资源的浪费。
-  像WEB网站的http服务一般都用短链接，因为长连接对于服务端来说会耗费一定的资源，而像WEB网站这么频繁的成千上万甚至上亿客户端的连接用短连接会更省一些资源。

**HTTP/1.1 -- 长连接    HTTP/1.0 -- 短连接**

网页图片多时，需要都从服务器获取，短连接方式，服务器需要多个进程/线程 处理，浪费资源；长连接时不会再建立新的 进程/线程/协程

##### Web静态服务器-6-单进程-单线程-非堵塞-长连接模式

上面实现的代码都是短连接，因为虽然用的 HTTP/1.1，但是服务器返回数据后，关闭套接字，断开连接了。

```python
import socket
import re
def service_client(new_socket, request):
    """为这个客户端返回数据"""
    request_lines = request.splitlines()
    file_name = ""
    ret = re.match(r"[^/]+(/[^ ]*)", request_lines[0])
    if ret:
        file_name = ret.group(1)
        if file_name == "/":
            file_name = "/index.html"
    try:
        f = open("./html" + file_name, "rb")
    except:
        response = "HTTP/1.1 404 NOT FOUND\r\n"
        response += "\r\n"
        response += "------file not found-----"
        new_socket.send(response.encode("utf-8"))
    else:
        html_content = f.read()
        f.close()
        response_body = html_content
        response_header = "HTTP/1.1 200 OK\r\n"
        response_header += "Content-Length:%d\r\n" % len(response_body)
        # Content-Length:len-->浏览器此时不需要调用close会自动发起新请求
        response_header += "\r\n"
        response = response_header.encode("utf-8") + response_body  # 此时都是二进制字符串
        new_socket.send(response)
        # 这不能 close()，那如何使浏览器知道数据已经收完了？
        # Content-Length 告诉浏览器body长度，浏览器获取完所需全部数据后，主动断开连接
def main():
    """用来完成整体的控制"""
    tcp_server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    tcp_server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    tcp_server_socket.bind(("", 7890))
    tcp_server_socket.listen(128)
    tcp_server_socket.setblocking(False)  # 将套接字变为非堵塞
    client_socket_list = list()
    while True:
        try:  # 等待新客户端的链接
            new_socket, client_addr = tcp_server_socket.accept()
        except Exception as ret:
            pass
        else:
            new_socket.setblocking(False)
            client_socket_list.append(new_socket)
        for client_socket in client_socket_list:
            try:
                recv_data = client_socket.recv(1024).decode("utf-8")
            except Exception as ret:
                pass
            else:
                if recv_data:
                    service_client(client_socket, recv_data)  # 将数据传入
                else:
                    client_socket.close()  # 浏览器获取完所需全部数据后，主动 close() (挥手)
                    client_socket_list.remove(client_socket)
    # 关闭监听套接字
    tcp_server_socket.close()
if __name__ == "__main__":
    main()
```

##### Web静态服务器-7-epoll

epoll —— linux服务器采用，nginx 采用 epoll 实现

epoll 是单进程单线程，epoll 将列表放入特殊内存空间，应用和内核都可访问，没有拷贝过程，套接字的文件描述符检测时不遍历(轮询)，通过事件通知方式

事件通知：哪个套接字数据到了，通知套接字收

特点：**共享内存**、**事件通知**

```python
# epoll 实现 HTTP 服务器
import socket
import re
import select
def service_client(new_socket, request):
    """为这个客户端返回数据"""
    request_lines = request.splitlines()
    file_name = ""
    ret = re.match(r"[^/]+(/[^ ]*)", request_lines[0])
    if ret:
        file_name = ret.group(1)
        # print("*"*50, file_name)
        if file_name == "/":
            file_name = "/index.html"
    try:
        f = open("./html" + file_name, "rb")
    except:
        response = "HTTP/1.1 404 NOT FOUND\r\n"
        response += "\r\n"
        response += "------file not found-----"
        new_socket.send(response.encode("utf-8"))
    else:
        html_content = f.read()
        f.close()
        response_body = html_content
        response_header = "HTTP/1.1 200 OK\r\n"
        response_header += "Content-Length:%d\r\n" % len(response_body)
        response_header += "\r\n"
        response = response_header.encode("utf-8") + response_body
        new_socket.send(response)
def main():
    """用来完成整体的控制"""
    tcp_server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    tcp_server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    tcp_server_socket.bind(("", 7890))
    tcp_server_socket.listen(128)
    tcp_server_socket.setblocking(False)  # 将套接字变为非堵塞
    # 创建一个epoll对象
    epl = select.epoll()
    # 将监听套接字对应的fd注册到epoll中
    epl.register(tcp_server_socket.fileno(), select.EPOLLIN)
    # tcp_server_socket.fileno() 获取对应文件描述符(fd)，其为数字
    # select.EPOLLIN 监测前一个是否有输入，事件类型
    fd_event_dict = dict()
    while True:
        fd_event_list = epl.poll()  # 返回列表
        # 默认会堵塞，直到 os监测到数据到来 通过事件通知方式 告诉这个程序，此时才会解堵塞
        # [(fd, event), (套接字对应的文件描述符, 这个文件描述符到底是什么事件 例如 可以调用recv接收等)]
        for fd, event in fd_event_list:
            # 等待新客户端的链接
            if fd == tcp_server_socket.fileno():  # 第一次肯定为 tcp_server_socket
                new_socket, client_addr = tcp_server_socket.accept()
                epl.register(new_socket.fileno(), select.EPOLLIN)  # 将套接字对应的fd注册到epoll中
                fd_event_dict[new_socket.fileno()] = new_socket  # 为了根据 fd 得到 socket
            elif event==select.EPOLLIN:
                # 判断已经链接的客户端是否有数据发送过来
                recv_data = fd_event_dict[fd].recv(1024).decode("utf-8")
                if recv_data:
                    service_client(fd_event_dict[fd], recv_data)
                else:
                    fd_event_dict[fd].close()
                    epl.unregister(fd)
                    del fd_event_dict[fd]
    # 关闭监听套接字
    tcp_server_socket.close()
if __name__ == "__main__":
    main()
```

### 3 网络通信

#### TCP/IP协议(族)

协议就是一个规定。为了把全世界的所有不同类型的计算机都连接起来，就必须规定一套全球通用的协议，为了实现互联网这个目标，互联网协议族（Internet Protocol Suite）就是通用协议标准。因为互联网协议包含了上百种协议标准，但是最重要的两个协议是TCP和IP协议，所以，大家把互联网的协议**简称TCP/IP协议(族)**

常用的网络协议如下图所示：

![TCP-IP协议族中各协议之间的关系](https://user-images.githubusercontent.com/51505633/79482359-52e31780-8043-11ea-8e29-bb207c9e9152.jpg)

![传输示意图](https://github.com/sunhx0914/Picture/issues/2#issuecomment-614763369)

传输层添加端口，IP层添加ip，链路层帧头为mac地址(网卡上的序列号)

事实标准：应用层、运输层、网际层(网络层)、网络接口层(链路层)  —— TCP/IP 四层模型

理论标准：应用层、表示层、会话层、传输层、网络层、数据链路层、物理层  —— OSI 七层模型

#### wireshark

过滤条件：tcp、ip.src、ip.dst、udp.port == 2405、ip.src == 192.168.33.45 and(or) udp

目的：确定数据发送成功与否、判断哪出问题

#### 网络通信过程

##### 2台电脑的网络

如果两台电脑之间通过网线连接是可以直接通信的，但是需要提前设置好ip地址以及网络掩码，并且ip地址需要控制在同一网段内， 例如 一台为`192.168.1.1`另一台为`192.168.1.2` 

ip地址 用于区分主机

网络掩码 与 ip地址 按位与操作(都1时为1) ，计算主机号和网络号，确定是否为同一网络

##### 使用集线器组成一个网络

当有多台电脑需要组成一个网时，那么可以通过集线器（Hub）将其链接在一起。一般集线器的接口较少

网线中是电信号 不能像电线一样多接

集线器缺点：它以**广播**的方式进行发送任何数据，即如果集线器接收到来自A电脑的数据本来是想转发给B电脑，如果此时它还连接着另外两台电脑C、D，那么它会把这个数据给每个电脑都发送一份，因此会导致网络拥堵

##### 使用交换机组成一个网络

克服了集线器以广播发送数据的缺点，当需要广播的时候发送广播，当需要单播的时候又能够以单播的方式进行发送，它已经替代了之前的集线器。

网卡要先判断是否发给自己，因此需要mac地址(可通过arp协议获取）

arp 广播得到目的 ip 对应的 mac地址

网卡默认接收 FF:FF:FF:FF:FF:FF 的地址，通过这个返回目的mac地址

发送数据(去)时是广播，返回数据(回)时不是广播，因为已经知道了源ip和源mac

##### 使用路由器连接多个网络

路由器： 连接不同的网络

为了让自己电脑能发送数据给不同的网络号里电脑， 必须要设置默认网关

默认网关是能转发数据的设备，往往是路由器

发给默认网关时，mac地址写的是默认网关的mac地址， 转发的时候写的是默认网关的另一个mac地址，ip地址不变

路由器转发数据时，ip地址保持不变，源、目的mac一直在变

<img width="1514" alt="QQ20171023-111517@2x" src="https://user-images.githubusercontent.com/51505633/79484902-fa157e00-8046-11ea-897e-781bfe3ea0b6.png">

##### 通信过程(复杂)

较为复杂的通信过程如：访问`www.itheima.com `

1. 在浏览器中输入一个网址时，需要将它先**解析出ip地址**来(DNS服务器用来解析域名对应的ip地址)

   本地有DNS服务器 ip 地址

   通过arp得到默认网关地址，将请求的域名解析数据发送给网关，网关接入互联网，层层转发，DNS服务器接收到数据后，返回域名对应的ip地址

   ip地址是由范围的，通过ip可以知道地区

2. 当得到ip地址之后，浏览器以tcp的方式3次握手连接服务器

3. 以tcp的方式发送http协议的请求数据 给 服务器

4. 服务器tcp的方式回应http协议的应答数据 给浏览器，浏览器显示数据

5. 浏览器发送tcp的4次挥手

路由器之间有发现协议

<img width="1092" alt="QQ20170807-212411@2x" src="https://user-images.githubusercontent.com/51505633/79487291-9bea9a00-804a-11ea-8972-8a6c399b84de.png">

#### NAT(网络地址转换器)

1. 当在家里用宽带链接上网时，会把电话线(光纤)---->调制解调制(简称猫)------->电脑等设备

2. 电脑会得到来自电信服务商的一个公网ip地址（**只有公网ip地址才能上网**），此时可以直接上网

3. 为了能够让多台设备都可以上网，需要将数据进行“分流” 电话线(光纤)---->调制解调制(简称猫)------->路由器------>电脑等设备

4. 此时路由器的一端有一个公网ip地址，剩下的4个（型号不同个数不同）可以接入电脑等设备 并且 它们的ip是私有ip(例如 192.168.1.2)

5. 当一个电脑（192.168.1.2）上网时，先通过DNS协议解析出某个域名对应的ip，然后

   - 发送数据时,在经过路由器时转换为公网ip以及路由器自己分配的临时端口

     192.168.1.2:6789----->192.168.1.1 路由器 116.226.52.212:6539------->猫---->万维网

   - 接收数据时,在经过路由器时转换为路由器之前记录的ip以及port

     万维网------->猫----->116.226.52.212:6539 路由器 192.168.1.1 ---->192.168.1.2:6789

<img width="1184" alt="QQ20171023-123017@2x" src="https://user-images.githubusercontent.com/51505633/79487880-7f029680-804b-11ea-8a3d-62aa2c1c3b73.png" style="zoom: 45%;" >

#### 总结

- MAC地址：在设备与设备之间数据通信时用来标记收发双方（网卡的序列号）
- IP地址：在逻辑上标记一台电脑，用来指引数据包的收发方向（相当于电脑的序列号）
- 网络掩码：用来区分ip地址的网络号和主机号
- 默认网关：当需要发送的数据包的目的ip不在本网段内时，就会发送给默认的一台电脑，成为网关
- 集线器：已过时，用来连接多态电脑，缺点：每次收发数据都进行广播，网络会变的拥堵
- 交换机：集线器的升级版，有学习功能知道需要发送给哪台设备，根据需要进行单播、广播
- 路由器：连接多个不同的网段，让他们之间可以进行收发数据，每次收到数据后，ip不变，但是MAC地址会变化
- DNS：用来解析出IP（类似电话簿）
- http服务器：提供浏览器能够访问到的数据







**通信过程：**

1 DNS 解析 域名    有 DNS 的ip，，得先发送给网关，，得先发 arp 得到 网关

先得到默认网关的mac

2  向服务器 3 次握手

3 以tcp的方式发送http协议的请求数据 给 服务器
4 服务器tcp的方式回应http协议的应答数据 给浏览器

为什么用mac   可以查查







### 4 Python高级

#### GIL锁

GIL（全局解释区锁）面试题如下

> 描述Python GIL的概念， 以及它对python多线程的影响？编写一个多线程抓取网页的程序，并阐明多线程抓取程序是否可比单线程性能有提升，并解释原因。

Guido的声明：http://www.artima.com/forums/flat.jsp?forum=106&thread=214235

> 参考答案:
>
> 1. Python语言和GIL没有半毛钱关系。仅仅是由于历史原因在Cpython虚拟机(解释器)，难以移除GIL。
> 2. GIL：全局解释器锁。每个线程在执行的过程都需要先获取GIL，保证同一时刻只有一个线程可以执行代码。
> 3. 线程释放GIL锁的情况： 在IO操作等可能会引起阻塞的system call之前,可以暂时释放GIL,但在执行完毕后,必须重新获取GIL Python 3.x使用计时器（执行时间达到阈值后，当前线程释放GIL）或Python 2.x，tickets计数达到100
> 4. Python使用多进程是可以利用多核的CPU资源的。
> 5. 多线程爬取比单线程性能有提升，因为遇到IO阻塞会自动释放GIL锁

**pass 占位符，空语句**

Python 的多线程由于存在著名的 GIL，无法让两个线程真正“同时运行”，所以实际上是无法到达并行状态的 

**GIL 使多线程程序在同一时刻只有一个线程在运行**，只会使用一个核，GIL 是cpython解释器存在的问题

*一般多进程比多线程消耗资源，但如果使用cpython解释器，可以用多进程代替多线程*

>python由于历史遗留的问题，严格说多个线程并不会同时执行（没法有效利用多核处理器，python的并发只是一个核心的交替执行不同的代码）。
>
>解释器执行代码时，有一个GIL锁：Global Interpreter Lock，任何Python线程执行前，必须先获得GIL锁，然后，每执行100条字节码，解释器就自动释放GIL锁，让别的线程有机会执行。
>
>这个GIL全局锁实际上把所有线程的执行代码都给上了锁，所以，多线程在Python中只能交替执行，即使100个线程跑在100核CPU上，也只能用到1个核。

计算密集型 不用线程，使用进程，而 IO密集型 可以 使用 线程，也可以使用协程

如何解决 GIL：1. 换解释器 2. 换语言，用其他语言替代线程做的事(python语言可以对c程序代码进行调用，还有java\c++\js)

> [Python3调用C程序示例](https://www.jianshu.com/p/edb8698d1374)

#### 深拷贝、浅拷贝

直接赋值：其实就是对象的引用（别名） 

浅拷贝：浅拷贝是对于一个对象的顶层拷贝，通俗的理解是：拷贝了引用，并没有拷贝内容

深拷贝：深拷贝是对于一个对象所有层次的拷贝(递归)

```python
import copy
a1 = [11, 22]
b1 = a1  # 直接赋值：指向/就是对象的引用
print(a1, b1)
print(id(a1), id(b1))  # id() 指向数据的地址
a1.append(33)
print(a1, b1)
print("-" * 20)
a2 = [11, 22]
b2 = copy.deepcopy(a2)  # 对a指向的列表进行深拷贝
print(a2, b2)
print(id(a2), id(b2))
a2.append(33)
print(a2, b2)
print("-" * 20)
# copy.copy 浅拷贝 是对于一个对象的顶层拷贝  
# c 和 d 是一个独立的对象，但他们的子对象还是指向统一对象（是引用）
# copy.deepcopy(), c 和 e 完全拷贝了父对象及其子对象，两者是完全独立的。
a, b = [11, 22], [44, 55]
c = [a, b]
d = copy.copy(c)
e = copy.deepcopy(c)
print(id(c), id(d), id(e))
print(id(c[0]), id(d[0]), id(e[0]))
a.append(33)
c.append(66)
print(c, d, e)
# 1921547446856 1921547446152 1921547446792
# 1921547446984 1921547446984 1921547446920
# [[11, 22, 33], [44, 55], 66] [[11, 22, 33], [44, 55]] [[11, 22], [44, 55]]
'''浅拷贝对不可变类型和可变类型的copy不同
copy.copy对于可变类型，会进行浅拷贝
copy.copy对于不可变类型(不会修改，所以无需拷贝)，不会拷贝，仅仅是指向()'''
a3 = (11, 22)
b3 = a3
print(id(a3), id(b3))
# 元组中为不可变类型(全为不可变类型数据)，copy 和 deepcopy 都不会拷贝，仅仅是指向
# 元组中为 可变类型(存在可变类型数据，即使最顶层为不可变)，copy 不会拷贝，但deepcopy会 深拷贝
列表的切片 复制列表-list[:]  为 浅拷贝
字典的copy()方法 为 浅拷贝
字典的value 不存于字典，只存引用
函数传递的是引用，函数中的操作会修改源列表
```

首先**深拷贝和浅拷贝**都是对象的拷贝，都会生成一个看起来相同的对象，他们本质的区别是拷贝出来的对象的地址是否和原对象一样，也就是**地址的复制还是值的复制**的区别。

#####  什么是可变对象，什么是不可变对象：

- 可变对象是指，一个对象在不改变其所指向的地址的前提下，可以修改其所指向的地址中的值；
- 不可变对象是指，一个对象所指向的地址上值是不能修改的，如果你修改了这个对象的值，那么它指向的地址就改变了，相当于你把这个对象指向的值复制出来一份，然后做了修改后存到另一个地址上了，但是可变对象就不会做这样的动作，而是直接在对象所指的地址上把值给改变了，而这个对象依然指向这个地址。

列表中为字符串对象时，深拷贝后虽然列表中元素的地址一样，但是列表的地址不同。

#### 私有化

- `xx`: 公有变量
- `_x`: 单前置下划线,私有化属性或方法，from module import *禁止导入,类对象和子类可以访问
- `__xx`：双前置下划线,避免与子类中的属性命名冲突，无法在外部直接访问(名字重整所以访问不到) 
- `__xx__`：双前后下划线,用户名字空间的魔法对象或属性。例如:`__init__` , __ 不要自己发明这样的名字
- `xx_`：单后置下划线,用于避免与Python关键词的冲突，不建议用

`__xx`：私有属性/方法，不会继承，`__xx__`：公有属性/方法，会继承

通过name mangling（名字重整(目的就是以防子类意外重写基类的方法或者属性)如：_Class__object）机制就可以访问private了。

> 在一个类中定义的属性（无论是类属性还是实例属性），如果是以 双下划线 (`__`) 开头，那么这个属性是对外 (包括其子类中) 不可见的，类似于 java 中的 private 属性。如何做到这一点呢, 毕竟 Python 并没有真正意义上的访问约束机制（比如 private, protected 修饰符）。Python 的做法是 name mangling(名字重整)。具体做法是 如果你在某个类 clsA 中定义了一个属性，名称是  `__a`, 那么 python 会把这个属性更名成  `_clsA__a`， 但是更名后不影响你在内部使用，你在类的内部，还是可以使用`self.__a` 来范围。如果你非要在外部访问 这个属性，就只能使用 inst._clsA__a 来访问。 

```python
class Person(object):
    def __init__(self, name, age, taste):
        self.name = name
        self._age = age  # 禁止导入
        self.__taste = taste  # 私有属性
    def showperson(self):
        print(self.name, self._age, self.__taste)  # 通过方法可以访问私有属性
    def dowork(self):
        self._work()
        self.__away()
    def _work(self):  # 禁止导入
        print('my _work')
    def __away(self):    # 私有方法
        print('my __away')
class Student(Person):
    def construction(self, name, age, taste):
        self.name = name
        self._age = age  # 禁止导入
        self.__taste = taste  # 私有属性
    def showstudent(self):
        print(self.name, self._age, self.__taste)
    @staticmethod
    def testbug():
        _Bug.showbug()  # 静态方法，通过类直接调用，不需要创建对象，不会隐式传递self
# 模块内可以访问，当from  cur_module import *时，不导入
class _Bug(object):  # 禁止导入
    @staticmethod
    def showbug():
        print("showbug")
s1 = Student('jack', 25, 'football')
s1.showperson()
print('*'*20)
# 无法访问__taste,导致报错
# s1.showstudent() # 这成了子类对象访问私有属性
s1.construction('rose', 30, 'basketball')
s1.showperson()  # 私有属性没法改
print('*'*20)
s1.showstudent()
print('*'*20)
Student.testbug()
```

小结：

- 父类中属性名为`__名字`的，子类不继承，子类不能访问
- 如果在子类中向`__名字`赋值，那么会在子类中定义的一个与父类相同名字的属性
- `_名`的变量、函数、类在使用`from xxx import *`时都不会被导入

#### import导入模块

如果模块是被**第一次**导入, 它将被加载并执行。 一个模块只被加载一次, 无论它被导入多少次。 这可以阻止多重导入时代码被多次执行。  

##### 搜索路径：

导入 sys 模块，打印 `sys.path` 输出 列表

- 从上面列出的目录里依次查找要导入的模块文件
- `''`表示当前路径
- 列表中的路径的先后顺序代表了python解释器在搜索模块时的先后顺序

##### 程序执行时添加新的模块路径：

```python
sys.path.append('/home/itcast/xxx')
sys.path.insert(0, '/home/itcast/xxx')  # 可以确保先搜索这个路径
```

##### 重新导入模块

模块被导入后进行过修改，`import module`不能重新导入模块，重新导入需用`reload`

(在交互模式下 导入，不结束，新开终端，修改模块内容，源导入不会更新；先导入的已经加载内存，修改的是硬盘)

```python
from imp import reload
reload(module_name)
```

##### Import 和from是赋值语句

像def一样，import和from是可执行的语句，他们可以出现在if中，可以出现在函数中，执行到这些语句的时候才会进行解析，也就是说，被导入的模块和变量名只有在对应的import或from语句执行后才可以使用。

**Import将整个模块对象赋值给一个变量名**。（import xxx  两个过程：将xxx.py导入到python解释器；定义xxx变量，指向模块）

**From将一个或多个变量名赋值给另外一个模块中同名的对象**。所以from容易污染命名空间。

##### 不建议用 `from module import *`

 在实践中, `from module import *` 不是良好的编程风格，如果使用from导入变量，且那些变量碰巧和作用域中现有变量同名，那么变量名就会被悄悄覆盖掉。使用import语句的时候就不会发生这种问题，因为我们是通过模块名才获取的变量名，像module.attr不会和现有作用域的attr冲突。 

###### 何时使用：

只在两种场合下建议使用这样的方法, 一个场合是：目标模块中的属性非常多, 反复键入模块名很不方便 , 例如 Tkinter (Python/Tk) 和 NumPy (Numeric Python) 模块 , 可能还有 socket 模块。

另一个场合是在交互解释器下, 因为这样可以减少输入次数。

##### 多模块开发时的注意点

```python
# common.py  公用模块
RECV_DATA_LIST = list()  # 用来存储数据
HANDLE_FLAG = False  # 用来标记是否处理完成
# handle_msg.py  只负责处理
from common import RECV_DATA_LIST
# from common import HANDLE_FLAG
import common
def handle_data():
    """模拟处理recv_msg模块接收的数据"""
    print("--->handle_data")
    for i in RECV_DATA_LIST:
        print(i)
    # 既然处理完成了，那么将变量HANDLE_FLAG设置为True，意味着处理完成
    # global HANDLE_FLAG
    # HANDLE_FLAG = True
    common.HANDLE_FLAG = True
def test_handle_data():
    """测试处理是否完成，变量是否设置为True"""
    print("--->test_handle_data")
    # if HANDLE_FLAG:
    if common.HANDLE_FLAG:
        print("=====已经处理完成====")
    else:
        print("=====未处理完成====")
# recv_msg.py  只负责收
from common import RECV_DATA_LIST
# from common import HANDLE_FLAG
import common
def recv_msg():
    """模拟接收到数据，然后添加到common模块中的列表中"""
    print("--->recv_msg")
    for i in range(5):
        RECV_DATA_LIST.append(i)
def test_recv_data():
    """测试接收到的数据"""
    print("--->test_recv_data")
    print(RECV_DATA_LIST)
def recv_msg_next():
    """已经处理完成后，再接收另外的其他数据"""
    print("--->recv_msg_next")
    # if HANDLE_FLAG:
    if common.HANDLE_FLAG:
        print("------发现之前的数据已经处理完成，这里进行接收其他的数据(模拟过程...)----")
    else:
        print("------发现之前的数据未处理完，等待中....------")
# main.py
from recv_msg import *
from handle_msg import *
def main():
    recv_msg()  # 1. 接收数据
    test_recv_data()  # 2. 测试是否接收完毕
    recv_msg_next()  # 3. 判断如果处理完成，则接收其它数据
    handle_data()  # 4. 处理数据
    test_handle_data()  # 5. 测试是否处理完毕
    recv_msg_next()  # 6. 判断如果处理完成，则接收其它数据
if __name__ == "__main__":
    main()
```

存在的可能出错的点：

`HANDLE_FLAG` 通过 先导入common模块，再通过`common.HANDLE_FLAG` 方式读取/修改值时，由于两个文件中对应语句都指向了 common中的`HANDLE_FLAG`（因为两个变量common都指向了common.py模块） ，因此读取/修改时一致，如下图。

<img width="964" alt="QQ20171024-081134@2x" src="https://user-images.githubusercontent.com/51505633/79428333-982e2780-7ff8-11ea-9cdf-3a66cd736e90.png" style="zoom:50%;" >

而通过 `from common import HANDLE_FLAG`导入时，定义变量`HANDLE_FLAG` ，其指向 common中`HANDLE_FLAG` 的值(False)。`handle_msg` 中修改值时，`HANDLE_FLAG`变量会指向新的地址，而不是修改源地址中的值。（RECV_DATA_LIST 为list，通过append方法，会修改地址中的值；但如果用 = 新列表方式修改，也不会修改值，而是指向新列表）这样导致recv_msg读取时读到错误值，产生 bug。

导入模块语句也相当于赋值，所以为全局变量，需要 global 声明，如果没有，`HANDLE_FLAG` 变量指向了值为 `True`的新地址，且为局部变量，不会影响同文件的test_handle_data函数。

使用global 声明后，虽然成为了全局变量，会影响同文件的test_handle_data函数，但是模块中的`HANDLE_FLAG` 会指向新的地址，recv_msg_next函数中读取的还是源地址的值。

<img width="950" alt="QQ20171024-080610@2x" src="https://user-images.githubusercontent.com/51505633/79428043-2ce45580-7ff8-11ea-8edc-d7b37428ca33.png" style="zoom:50%;" >

#### 再议 封装、继承、多态

封装，对象的属性是独有的，但是方法是公有的，创建对象时独有变量，而通过模板的引用来调用函数(`__class__`方法)

`__dict__`方法标记对象的属性

self 是形参，可以为其他，对应就行

##### 封装好处

> 1. 在使用面向过程编程时，当需要对数据处理时，需要考虑用哪个模板中哪个函数来进行操作，但是当用面向对象编程时，因为已经将数据存储到了这个独立的空间中，这个独立的空间（即对象）中通过一个特殊的变量（__class__）能够获取到类（模板），而且这个类中的方法是有一定数量的，与此类无关的将不会出现在本类中，因此需要对数据处理时，可以很快速的定位到需要的方法是谁 这样更方便
> 2. 全局变量是只能有1份的，多很多个函数需要多个备份时，往往需要利用其它的变量来进行储存；而通过封装 会将用来存储数据的这个变量 变为了对象中的一个“全局”变量，只要对象不一样那么这个变量就可以再有1份，所以这样更方便
> 3. 代码划分更清晰

##### 继承好处

> 1. 能够提升代码的重用率，即开发一个类，可以在多个子功能中直接使用
> 2. 继承能够有效的进行代码的管理，当某个类有问题只要修改这个类就行，而其继承这个类的子类往往不需要就修改

##### 多态：多种形态

子类重写方法，调用子类的；没重写，调用父类的，但调用的是同一个方法(名)  -- **只需写成父类方法的调用方式**。

```python
class MiniOS(object):
    """MiniOS 操作系统类 """
    def __init__(self, name):
        self.name = name
        self.apps = []  # 安装的应用程序名称列表

    def __str__(self):  # 返回对象的描述信息（必须为字符串），print 函数打印对象时自定义输出使用
        return "%s 安装的软件列表为 %s" % (self.name, str(self.apps))

    def install_app(self, app):
        # 判断是否已经安装了软件
        if app.name in self.apps:
            print("已经安装了 %s，无需再次安装" % app.name)
        else:
            app.install()  '''这实现多态!'''
            self.apps.append(app.name)
class App(object):
    def __init__(self, name, version, desc):
        self.name = name
        self.version = version
        self.desc = desc
    def __str__(self):
        return "%s 的当前版本是 %s - %s" % (self.name, self.version, self.desc)
    def install(self):
        print("将 %s [%s] 的执行程序复制到程序目录..." % (self.name, self.version))
class PyCharm(App):
    pass
class Chrome(App):
    def install(self):
        print("正在解压缩安装程序...")
        super().install()
linux = MiniOS("Linux")
print(linux)
pycharm = PyCharm("PyCharm", "1.0", "python 开发的 IDE 环境")
chrome = Chrome("Chrome", "2.0", "谷歌浏览器")
linux.install_app(pycharm)
linux.install_app(chrome)
linux.install_app(chrome)
print(linux)
```

#### 多继承以及MRO顺序

**函数名就是一个变量，指向一个函数**

**重写：**重新覆盖，子类覆盖父类中的同名方法，会调用子类的方法

**重载：**方法名相同，根据形参的数量，类型，自动调用不同方法（**Python 中几乎没有**，同名的方法/函数，后一个会覆盖前一个。(python中 `+` 是重载 数值和字符串两个情况时结果不一致)）

##### 调用被重写的父类方法的方式   

 重写之后，如果发现仍需要父类方法，有以下三种方式：

1. 父类名.父类方法() 

   使用类名调用父类被重写的方法时， 需要显式绑定第一个参数self ，eg：`Animal.__init__(self)`

   > python3基本上要把这种方式淘汰了。
   >
   > 它的机制你可以理解为：如果“孙子”类有俩“爸爸”类，他的两个“爸爸”类在自己的某一个方法中都调用了“爷爷”类的那个方法，当调用两个“爸爸”类中的这个方法时，而于是就造成了爷爷的代码被调用了多次（菱形继承）。一方面太冗余，另一方面可能出现不必要的bug，而如果使用的是super()方式的话，会按照类的`__mro__`属性的顺序来调用，就不存在这方面的问题。所以 父类名.父类方法() 的方式不推荐使用。

   示例：

   ```python
   # 单独调用父类的方法
   print("******多继承使用类名.__init__ 发生的状态******")
   class Parent(object):
       def __init__(self, name):
           print('parent的init开始被调用')
           self.name = name
           print('parent的init结束被调用')
   class Son1(Parent):
       def __init__(self, name, age):
           print('Son1的init开始被调用')
           self.age = age
           Parent.__init__(self, name)
           print('Son1的init结束被调用')
   class Son2(Parent):
       def __init__(self, name, gender):
           print('Son2的init开始被调用')
           self.gender = gender
           Parent.__init__(self, name)
           print('Son2的init结束被调用')
   class Grandson(Son1, Son2):
       def __init__(self, name, age, gender):
           print('Grandson的init开始被调用')
           Son1.__init__(self, name, age)  # 单独调用父类的初始化方法
           Son2.__init__(self, name, gender)
           print('Grandson的init结束被调用')
   gs = Grandson('grandson', 12, '男')
   print('姓名：', gs.name)
   print('年龄：', gs.age)
   print('性别：', gs.gender)
   print("******多继承使用类名.__init__ 发生的状态******\n\n")
   ```

2. super().父类方法()

   ```python
   # 多继承中super调用所有父类的被重写的方法
   print("******多继承使用super().__init__ 发生的状态******")
   class Parent(object):
       def __init__(self, name, *args, **kwargs):  # 为避免多继承报错，使用不定长参数，接受参数
           print('parent的init开始被调用')
           self.name = name
           print('parent的init结束被调用')
   class Son1(Parent):
       def __init__(self, name, age, *args, **kwargs):  # 为避免多继承报错，使用不定长参数，接受参数
           print('Son1的init开始被调用')
           self.age = age
           super().__init__(name, *args, **kwargs)  # 为避免多继承报错，使用不定长参数，接受参数
           # 这传递的是 调用函数时的数据  见下方拆包
           print('Son1的init结束被调用')
   class Son2(Parent):
       def __init__(self, name, gender, *args, **kwargs):  # 为避免多继承报错，使用不定长参数，接受参数
           print('Son2的init开始被调用')
           self.gender = gender
           super().__init__(name, *args, **kwargs)  # 为避免多继承报错，使用不定长参数，接受参数
           print('Son2的init结束被调用')
   class Grandson(Son1, Son2):
       def __init__(self, name, age, gender):
           print('Grandson的init开始被调用')
           # 多继承时，相对于使用类名.__init__方法，要把每个父类全部写一遍
           # 而super只用一句话，执行了全部父类的方法，这也是为何多继承需要全部传参的一个原因
           # super(Grandson, self).__init__(name, age, gender) 
           # 子类名可以修改，修改后按__mro__中对应类名的下个类中的对应方法
           super().__init__(name, age, gender)  # 默认是自己的类类名，等同于上一句
           # super()默认拿着自己的类名到MRO输出中找，找到匹配项的下一个的__init__执行
           print('Grandson的init结束被调用')
   print(Grandson.__mro__)
   # (<class '__main__.Grandson'>, <class '__main__.Son1'>, <class '__main__.Son2'>, <class '__main__.Parent'>, <class 'object'>)
   gs = Grandson('grandson', 12, '男')
   print('姓名：', gs.name)
   print('年龄：', gs.age)
   print('性别：', gs.gender)
print("******多继承使用super().__init__ 发生的状态******\n\n")
   ```

   `类名.__mro__`是依照C3算法衍生出来的一个类的属性，该属性的特点是：
   
1. 使**所有继承的类只执行一次**。
   2. 返回一个元祖，元祖中是**使用super()方法时调用父类方法的顺序**。（顺序是：拿着类名去元祖里面找，找到了之后，便去执行**它的‘下一个’对应的类中对应的方法**）
   
   > 注意：以上2个代码执行的结果不同。
   > 如果2个子类中都继承了父类，当在子类中**通过父类名调用**时，parent被执行了**2次**
   > 如果2个子类中都继承了父类，当在子类中**通过super调用**时，parent被执行了**1次**


3. super(子类名, self).父类方法()

    eg：`super(Son1, self).__init__()`，根据 `类名.__mro__` 的输出，会执行 Son2 中的`__init__()`
    
    **为什么要有self这个参数？**供参考：将自己作为实参传递给这个继承的类中，才能执行对应方法的代码
    
    使用 super() 时，为避免多继承报错，使用不定长参数，接受参数

##### 拆包

`*args `用来将参数打包成tuple给函数体调用； `**kwargs `打包关键字参数成dict给函数体调用 

```python
def test1(a, b, *args, **kwargs):  # args 接收(33,44,55)，不是*args接收的   变量名没有*!
    print(a, ">>", b, ">>", args, ">>", kwargs)
    # *就是拆包指令，所以输出args时是以未拆包，也就是原元组进行print的
    print("*args <<< ", *args)
    test2(a, b, args, kwargs)  # 相当于 test2(11,22,(33,44,55),{'age':18,'name':'douzi'})
    test2(a, b, *args, kwargs)  # 相当于 test2(11,22,33,44,55,{'age':18,'name':'douzi'})
    test2(a, b, *args, **kwargs)  # 相当于 test2(11,22,33,44,55, name="douzi", age=18)
def test2(a, b, *args, **kwargs):
    print("-2- ", a, ">>", b, ">>", args, ">>", kwargs)
test1(11, 22, 33, 44, 55, name="douzi", age=18)
```

 `*` 在Python中就一个作用，就是“拆包”， 拆包”顾名思义就是打开包，将包(在此指元组Tuple、字典Dictionary)里面的数据拆分成一个个单独的数据。 

##### 单继承中super

```python
print("******单继承使用super().__init__ 发生的状态******")
class Parent(object):
    def __init__(self, name):
        print('parent的init开始被调用')
        self.name = name
        print('parent的init结束被调用')
class Son1(Parent):
    def __init__(self, name, age):
        print('Son1的init开始被调用')
        self.age = age
        super().__init__(name)  # 单继承不能提供全部参数
        print('Son1的init结束被调用')
class Grandson(Son1):
    def __init__(self, name, age, gender):
        print('Grandson的init开始被调用')
        super().__init__(name, age)  # 单继承不能提供全部参数
        print('Grandson的init结束被调用')
gs = Grandson('grandson', 12, '男')
print('姓名：', gs.name)
print('年龄：', gs.age)
#print('性别：', gs.gender)
print("******单继承使用super().__init__ 发生的状态******\n\n")
```

总结：

1. `super().__init__`相对于`类名.__init__`，在单继承上用法基本无差
2. 但在多继承上有区别，super方法能保证每个父类的方法只会执行一次，而使用类名的方法会导致方法被执行多次，具体看前面的输出结果
3. 多继承时，使用super方法，对父类的传参数，应该是由于python中super的算法导致的原因，必须把参数全部传递，否则会报错
4. 单继承时，使用super方法，则不能全部传递，只能传父类方法所需的参数，否则会报错
5. 多继承时，相对于使用`类名.__init__`方法，要把每个父类全部写一遍, 而使用super方法，只需写一句话便执行了全部父类的方法，这也是为何多继承需要全部传参的一个原因

##### 面试题

> 以下的代码的输出将是什么? 说出你的答案并解释。

```python
class Parent(object):
    x = 1
class Child1(Parent):
    pass
class Child2(Parent):
    pass
print(Parent.x, Child1.x, Child2.x)  # 1 1 1
Child1.x = 2  # 添加类属性
print(Parent.x, Child1.x, Child2.x)  # 1 2 1
Parent.x = 3  # 修改父类属性
print(Parent.x, Child1.x, Child2.x)  # 3 2 3
```

这个答案的关键是，在 Python 中，**类变量在内部是作为字典处理的**。如果一个变量的名字没有在当前类的字典中发现，将搜索祖先类（比如父类）直到被引用的变量名被找到（如果这个被引用的变量名既没有在自己所在的类又没有在祖先类中找到，会引发一个 AttributeError 异常 ）。**（也是按MRO顺序查找）**

因此，在父类中设置 x = 1 会使得类变量 x 在引用该类和其任何子类中的值为 1。因此第一个的输出是` 1 1 1`。

随后，如果任何它的子类重写了该值(如执行语句 Child1.x = 2)，该值仅仅在子类中被改变。因此第二个的输出是` 1 2 1`。

最后，如果该值在父类中被改变(如执行 Parent.x = 3)，这个改变会影响到任何未重写该值的子类当中的值（在这个示例中被影响的子类是 Child2）。这就是为什么第三个 print 输出是` 3 2 3`。

> 如果一个类继承了某个类，可以理解为在子类中有个属性指向了继承的父类，而不是复制了父类的东西

#### 静态方法和类方法

##### 类属性、实例属性

它们在定义和使用中有所区别，而最本质的区别是内存中保存的位置不同，

- 实例属性属于对象， 在**每个对象**中都要保存**一份** 
- 类属性属于类， 在**内存中**只保存**一份** 

**实例对象通过`__class__` 属性指向类对象**， **对象名.__class__.类属性名="xxx"： 可以修改类属性** 

应用场景：通过类创建实例对象时，如果每个对象需要具有相同名字的属性，那么就使用类属性，用一份既可

##### 实例方法、静态方法和类方法

实例方法、静态方法和类方法，三种方法在内存中都归属于类，区别在于调用方式不同。 

- 实例方法：由对象调用；至少一个self参数(通过它来传递实例的属性和方法)；执行实例方法时，自动将调用该方法的对象赋值给self(python解释器传入：实例对象引用)
- 类方法：由对象/类调用；使用装饰器@classmethod；至少一个cls参数(当前类对象， 通过它来传递类的属性和方法 ，不能传实例的属性和方法)；执行类方法时，自动将调用该方法的类赋值给cls(python解释器传入：类对象引用)
- 静态方法：由对象/类调用；使用装饰器@staticmethod；无默认参数；方法体 中不能使用类或实例的任何属性和方法

```python
class Foo(object):
    def __init__(self, name):
        self.name = name
    def ord_func(self):  # self 实例对象的引用
        """ 定义实例方法，至少有一个self参数 """
        print('实例方法')  # print(self.name)
    @classmethod
    def class_func(cls):  # cls 类对象的引用
        """ 定义类方法，至少有一个cls参数 """
        print('类方法')
    @staticmethod
    def static_func():
        """ 定义静态方法 ，无默认参数"""  # 静态方法存在的目的是做一些不需要参数的操作，且归为一类
        print('静态方法')
f = Foo("中国")
f.ord_func()  # 调用实例方法
Foo.class_func()  # 调用类方法
Foo.static_func()  # 调用静态方法
```

对比

- 相同点：对于所有的方法而言，均属于类，所以 在**内存中**也只保存**一份**
- 不同点：方法**调用者不同**、调用方法时自动**传入的参数不同**
- 类对象只能调用 类方法、静态方法，实例对象全可以调用

#### property属性

 一种用起来像是使用的实例属性一样的特殊属性，可以对应于某个方法 

```python
# ############### 定义 ###############
class Foo:
    def func(self):
        pass
    # 定义property属性
    @property  # 使调用方法时之间写方法名
    def prop(self):
        pass  # 必须返回一个值
# ############### 调用 ###############
foo_obj = Foo()
foo_obj.func()  # 调用实例方法
foo_obj.prop  # 调用property属性  可读性更高
```

property属性的定义和调用要注意一下几点：

- **定义时**，在实例方法的基础上添加 @property 装饰器；并且**仅有一个self参数**

- 调用时，无需括号

  ```python
  方法：foo_obj.func()
  property属性：foo_obj.prop
  ```

##### 示例

> 对于京东商城中显示电脑主机的列表页面，每次请求不可能把数据库中的所有内容都显示到页面上，而是通过分页的功能局部显示，所以在向数据库中请求数据时就要显示的指定获取从第m条到第n条的所有数据 这个分页的功能包括：
>
> - 根据用户请求的当前页和总数据条数计算出 m 和 n
> - 根据m 和 n 去数据库中请求数据
>
> 不分页返回全部数据，需要的请求太多，分页后只需返回这一页的数据

```python
class Pager:
    def __init__(self, current_page):
        self.current_page = current_page  # 用户当前请求的页码（第一页、第二页...）
        self.per_items = 10  # 每页默认显示10条数据
    @property
    def start(self):
        val = (self.current_page - 1) * self.per_items
        return val
    @property
    def end(self):
        val = self.current_page * self.per_items
        return val
p = Pager(1)
p.start  # 就是起始值，即：m  把属性对应成方法调用  封装的体现：不用管计算过程，返回结果
p.end  # 就是结束值，即：n
```

 property属性的功能是：property属性内部进行一系列的逻辑计算，最终将计算结果返回。 

##### property属性创建的两种方式

- 装饰器 即：在方法上应用装饰器
- 类属性 即：在类中定义值为property对象的类属性

###### 装饰器方式

在类的实例方法上应用@property装饰器

Python中的类有`经典类`和`新式类`，`新式类`的属性比`经典类`的属性丰富。（ py2 如果类继object，那么该类是新式类，py3默认继承object）

经典类，具有**一种**@property装饰器，即上面的方式

新式类，具有**三种**@property装饰器

```python
class Goods:
    """python3中默认继承object类
       以python2、3执行此程序的结果不同，因为只有在python3中才有@xxx.setter  @xxx.deleter
    """
    @property  # 写在最前面
    def price(self):
        print('@property')
    @price.setter  # @方法名.setter
    def price(self, value):  # 方法名需一致
        print('@price.setter')
    @price.deleter  # @方法名.deleter
    def price(self):
        print('@price.deleter')
obj = Goods()
obj.price          # 自动执行 @property 修饰的 price 方法，并获取方法的返回值
obj.price = 123    # 自动执行 @price.setter 修饰的 price 方法，并将 123 赋值给方法的参数
del obj.price      # 自动执行 @price.deleter 修饰的 price 方法
```

- 经典类中的属性只有一种访问方式，其对应被 @property 修饰的方法
- 新式类中的属性有三种访问方式，并分别对应了三个被@property、@方法名.setter、@方法名.deleter修饰的方法

由于新式类中具有三种访问方式，根据几个属性的访问特点，分别将三个方法定义为对同一个属性：**获取、修改、删除**

```python
class Goods(object):
    def __init__(self):
        self.original_price = 100  # 原价
        self.discount = 0.8  # 折扣
    @property
    def price(self):
        new_price = self.original_price * self.discount  # 实际价格 = 原价 * 折扣
        return new_price
    @price.setter
    def price(self, value):  # value = 200
        self.original_price = value
    @price.deleter
    def price(self):
        del self.original_price
obj = Goods()
obj.price         # 获取商品价格
obj.price = 200   # 修改商品原价
del obj.price     # 删除商品原价
```

###### 类属性方式

方式：创建值为property对象的类属性

当使用类属性的方式创建property属性时，`经典类`和`新式类`无区别

```python
class Foo:
    def get_bar(self):
        return 'laowang'
    BAR = property(get_bar)  # 类属性
obj = Foo()
reuslt = obj.BAR  # 自动调用get_bar方法，并获取方法的返回值
print(reuslt)
```

property方法中有个四个参数

- 第一个参数是方法名，调用 `对象.属性` 时自动触发执行方法
- 第二个参数是方法名，调用 `对象.属性 ＝ XXX` 时自动触发执行方法
- 第三个参数是方法名，调用 `del 对象.属性` 时自动触发执行方法
- 第四个参数是字符串，调用 `对象.属性.__doc__ `，此参数是该属性的描述信息

```python
class Foo(object):
    def get_bar(self):
        print("getter...")
        return 'laowang'
    def set_bar(self, value): 
        """必须两个参数"""
        print("setter...")
        return 'set value' + value
    def del_bar(self):
        print("deleter...")
        return 'laowang'
    BAR = property(get_bar, set_bar, del_bar, "description...")
obj = Foo()
obj.BAR  # 自动调用第一个参数中定义的方法：get_bar
obj.BAR = "alex"  # 自动调用第二个参数中定义的方法：set_bar方法，并将“alex”当作参数传入
desc = Foo.BAR.__doc__  # 自动获取第四个参数中设置的值：description...
del obj.BAR  # 自动调用第三个参数中定义的方法：del_bar方法
```

 由于`类属性方式`创建property属性具有3种访问方式，根据几个属性的访问特点，分别将三个方法定义为对同一个属性：**获取、修改、删除** 

上述对应示例代码可修改为`类属性方式`

> WEB框架 Django 的视图中 request.POST 就是使用的类属性的方式创建的属性 

##### property属性-应用

私有属性目的：不想让对象引用直接获取/修改值

get 需要有返回值，set 可以不需要返回值

###### 1. 私有属性添加getter和setter方法

```python
# python 不建议，其他语言常见
class Money(object):
    def __init__(self):
        self.__money = 0
    def getMoney(self):
        return self.__money
    def setMoney(self, value):
        if isinstance(value, int):
            self.__money = value
        else:
            print("error:不是整型数字")
```

###### 2. 使用property升级getter和setter方法

```python
class Money(object):
    def __init__(self):
        self.__money = 0
    def getMoney(self):
        return self.__money
    def setMoney(self, value):  # 可进行数据过滤等
        if isinstance(value, int):
            self.__money = value
        else:
            print("error:不是整型数字")
    # 定义一个属性，当对这个money设置值时调用setMoney,当获取值时调用getMoney
    money = property(getMoney, setMoney)  
a = Money()
a.money = 100  # 调用setMoney方法
print(a.money)  # 调用getMoney方法
#100
```

###### 3. 使用property取代getter和setter方法

- 重新实现一个属性的设置和读取方法,可做边界判定

```python
class Money(object):
    def __init__(self):
        self.__money = 0
    # 使用装饰器对money进行装饰，那么会自动添加一个叫money的属性，当调用获取money的值时，调用装饰的方法
    @property
    def money(self):
        return self.__money
    # 使用装饰器对money进行装饰，当对money设置值时，调用装饰的方法
    @money.setter
    def money(self, value):
        if isinstance(value, int):
            self.__money = value
        else:
            print("error:不是整型数字")
a = Money()
a.money = 100
print(a.money)
```

##### 总结

- 定义property属性共有两种方式，分别是【装饰器】和【类属性】，而【装饰器】方式针对经典类和新式类又有所不同。
- 通过使用property属性，能够简化调用者在获取数据的流程

#### 魔法属性

无论人或事物往往都有不按套路出牌的情况，Python的类属性也是如此，存在着一些具有特殊含义的属性。

##### `__doc__`

- 表示类的描述信息

```python
class Foo:
    """ 描述类信息，这是用于看电影的神器 """
    def func(self):
        pass
print(Foo.__doc__)
#输出：类的描述信息
```

##### `__module__ `和 `__class__`

- __module__ 表示当前操作的对象在那个模块
- __class__ 表示当前操作的对象的类是什么

```python
# test.py
class Person(object):
    def __init__(self):
        self.name = 'laowang'
# main.py
from test import Person
obj = Person()
print(obj.__module__)  # 输出 test 即：输出模块
print(obj.__class__)  # 输出 test.Person 即：输出类
```

##### `__init__`

- **初始化方法**，通过类创建对象时，自动触发执行

```python
class Person:
    def __init__(self, name):
        self.name = name
        self.age = 18
obj = Person('laowang')  # 自动执行类中的 __init__ 方法
```

##### `__del__`

- 当对象在内存中被释放时，自动触发执行。

注：此方法一般无须定义，因为Python是一门高级语言，程序员在使用时无需关心内存的分配和释放，因为此工作都是交给Python解释器来执行，所以，`__del__`的调用是由解释器在进行垃圾回收时自动触发执行的。

```python
class Foo:
    def __del__(self):
        pass
```

##### `__call__`

- 对象后面加括号，触发执行。

注：`__init__`方法的执行是由创建对象触发的，即：`对象 = 类名()` ；而对于 `__call__` 方法的执行是由对象后加括号触发的，即：`对象()` 或者 `类()()`

```python
class Foo:
    def __init__(self):
        pass
    def __call__(self, *args, **kwargs):
        print('__call__')
obj = Foo()  # 执行 __init__
obj()  # 执行 __call__
```

##### `__dict__`

- 类或对象中的所有属性

类的实例属性属于对象；类中的类属性和方法等属于类，即：

```python
class Province(object):
    country = 'China'
    def __init__(self, name, count):
        self.name = name
        self.count = count
    def func(self, *args, **kwargs):
        print('func')
# 获取类的属性，即：类属性、方法、
print(Province.__dict__)
# 输出：{'__dict__': <attribute '__dict__' of 'Province' objects>, '__module__': '__main__', 'country': 'China', '__doc__': None, '__weakref__': <attribute '__weakref__' of 'Province' objects>, 'func': <function Province.func at 0x101897950>, '__init__': <function Province.__init__ at 0x1018978c8>}
# __init__ 变量名  指向一个函数
obj1 = Province('山东', 10000)
print(obj1.__dict__)  # 获取 对象obj1 的属性  输出：{'count': 10000, 'name': '山东'}
obj2 = Province('山西', 20000)
print(obj2.__dict__)  # 获取 对象obj2 的属性  # 输出：{'count': 20000, 'name': '山西'}
```

##### `__str__`

- 如果一个类中定义了`__str__`方法，那么在 **获取对象的描述** 时，默认输出该方法的返回值。

```python
class Foo:
    def __str__(self):
        return 'laowang'
obj = Foo()
print(obj)  # 输出：laowang
dis = "当前对象的描述：%s" % obj
```

##### `__getitem__`、`__setitem__`、`__delitem__`

- 用于索引操作，如字典。以上分别表示获取、设置、删除数据

```python
class Foo(object):
    # for item in 可迭代对象，自己实现时有如下方法，可作为字典
    def __getitem__(self, key):  
        print('__getitem__', key)
    def __setitem__(self, key, value):
        print('__setitem__', key, value)
    def __delitem__(self, key):
        print('__delitem__', key)
obj = Foo()
result = obj['k1']      # 自动触发执行 __getitem__
obj['k2'] = 'laowang'   # 自动触发执行 __setitem__
del obj['k1']           # 自动触发执行 __delitem__
```

##### `__getslice__`、`__setslice__`、`__delslice__`

- 该三个方法用于分片操作，如：列表

```python
class Foo(object):
    # for item in 可迭代对象，自己实现时有如下方法，可作为列表
    def __getslice__(self, i, j):
        print('__getslice__', i, j)
    def __setslice__(self, i, j, sequence):
        print('__setslice__', i, j)
    def __delslice__(self, i, j):
        print('__delslice__', i, j)
obj = Foo()
obj[-1:1]                   # 自动触发执行 __getslice__  # 取不出值
obj[0:1] = [11,22,33,44]    # 自动触发执行 __setslice__  # 把源列表的值替换掉
del obj[0:2]                # 自动触发执行 __delslice__
```

#### 面向对象设计

- 继承 - 是基于Python中的属性查找(如X.name)
- 多态 - 在X.method方法中，method的意义取决于X的类型
- 封装 - 方法和运算符实现行为，数据隐藏默认是一种惯例

#### with与 上下文管理器

对于系统资源如文件、数据库连接、socket 而言，应用程序打开这些资源并执行完业务逻辑之后，必须做的一件事就是要关闭（断开）该资源。

比如 Python 程序打开一个文件，往文件中写内容，写完之后，就要关闭该文件，否则会出现什么情况呢？极端情况下会出现 "Too many open files" 的错误，因为系统允许你打开的最大文件数量是有限的。

普通的open() - write() - close() 方式，如果在调用 write 的过程中，出现了异常进而导致后续代码无法继续执行，close 方法无法被正常调用，因此资源就会一直被该程序占用者释放。 

 改进是对可能发生异常的代码处进行 try 捕获，使用 try/finally 语句。 只要把 close() 放在 finally 代码中，文件就一定会关闭。 

 一种更加简洁、优雅的方式就是用 with 关键字。open 方法的返回值赋值给变量 f，当离开 with 代码块的时候，系统会自动调用 f.close() 方法， with 的作用和使用 try/finally 语句是一样的。 

```python
def m3():
    with open("output.txt", "r") as f:
        f.write("Python之禅")
```

 with 的原理要涉及到上下文管理器（Context Manager）。 

##### 什么是上下文(context)

> 上下文在不同的地方表示不同的含义，要感性理解。context其实说白了，和文章的上下文是一个意思，在通俗一点，我觉得叫环境更好。....
>
> 林冲大叫一声“啊也！”....
>
> 问:这句话林冲的“啊也”表达了林冲怎样的心里？答:啊你妈个头啊！
>
> 看，一篇文章，给你摘录一段，没前没后，你读不懂，因为有语境，就是语言环境存在，一段话说了什么，要通过上下文(文章的上下文)来推断。
>
> app点击一个按钮进入一个新的界面，也要**保存**你是在哪个屏幕跳过来的等等**信息**，以便你点击返回的时候能正确跳回，如果不存肯定就无法正确跳回了。
>
> 看这些都是上下文的典型例子，理解成环境就可以，(而且上下文虽然叫上下文，但是程序里面一般都只有上文而已，只是叫的好听叫上下文。进程中断在操作系统中是有上有下的，这个高深的问题就不深究了)

##### 上下文管理器

任何实现了 `__enter__()` 和 `__exit__()` 方法的对象都可称之为上下文管理器，上下文管理器对象可以使用 with 关键字。显然，文件（file）对象也实现了上下文管理器。

那么文件对象是如何实现这两个方法的呢？模拟实现一个文件类，让该类实现 `__enter__()` 和 `__exit__()` 方法。

```python
class File():
    def __init__(self, filename, mode):
        self.filename = filename
        self.mode = mode
    def __enter__(self):
        print("entering")
        self.f = open(self.filename, self.mode)
        return self.f  # 返回open的返回值
    def __exit__(self, *args):
        print("will exit")
        self.f.close()  # self.f 已经存储，是上下文
with File('out.txt', 'w') as f:  
    # File('out.txt', 'w') - 创建实例对象，返回其引用
    # with 检查 实例对象 是否为 上下文管理器（有无__enter__()和__exit__()方法）
    # 是上下文管理器，自动调用__enter__()方法，其返回值是什么，f 就是什么  f也指向open
    # with 判断File实例化的对象 有无__enter__()和__exit__()方法
    print("writing")
    f.write('hello, python')  # 无论是否出现异常，也会调用__exit__()方法
```

`__enter__() `方法返回资源对象，这里就是你将要打开的那个文件对象，`__exit__()` 方法处理一些清除工作。

因为 File 类实现了上下文管理器，现在就可以使用 with 语句了。

##### 实现上下文管理器的另外方式

Python 还提供了一个 contextmanager 的装饰器，更进一步简化了上下文管理器的实现方式。通过 yield 将函数分割成两部分，yield 之前的语句在 `__enter__` 方法中执行，yield 之后的语句在 `__exit__` 方法中执行。紧跟在 yield 后面的值是函数的返回值。

```python
from contextlib import contextmanager
@contextmanager
def my_open(path, mode):  # 普通函数
    f = open(path, mode)
    yield f  # yield返回什么，with中f是什么，yield之后是 做完/异常 执行的事情
    f.close()
with my_open('out.txt', 'w') as f:
    f.write("hello , the simplest context manager")
```

##### 总结

Python 提供了 with 语法用于简化资源操作的后续清除操作，是 try/finally 的替代方法，实现原理建立在上下文管理器之上。此外，Python 还提供了一个 contextmanager 装饰器，更进一步简化上下管理器的实现方式。

### 5 Mysql

#### 数据库简介

##### 数据库

关系型数据库核心元素：行(记录)、列(字段)、数据表(行的集合)、数据库(数据表的集合)

##### RDBMS

> Relational Database Management System 通过表来表示关系型

- 当前主要使用两种类型的数据库：关系型数据库、非关系型数据库
- 所谓的关系型数据库RDBMS，是建立在关系模型基础上的数据库，借助于集合代数等数学概念和方法来处理数据库中的数据
- 关系型数据库的主要产品：
  - oracle：在以前的大型项目中使用,银行,电信等项目
  - mysql：web时代使用最广泛的关系型数据库
  - ms sql server：在微软的项目中使用
  - sqlite：轻量级数据库，主要应用在移动平台

##### RDBMS和数据库的关系

<img width="1056" alt="QQ20170814-163342@2x" src="https://user-images.githubusercontent.com/51505633/79886873-5bb16000-842c-11ea-9c66-73596b5542e0.png" style="zoom: 33%;" >

关系型数据库通常由多张表组成；通过RDBMS来管理数据库；RDBMS关系型数据库管理系统分为**客户端**和**服务端**；客户端通过**SQL语句**实现对数据的管理。

##### SQL

SQL(Structured Query Language)是结构化查询语言，是一种用来**操作RDBMS**的**数据库语言**，当前关系型数据库都支持使用SQL语言进行操作,也就是说可以通过 SQL 操作 oracle,sql server,mysql,sqlite 等等所有的关系型的数据库

- SQL语句主要分为：
  - **DQL：数据查询语言，用于对数据进行查询，如select**
  - **DML：数据操作语言，对数据进行增加、修改、删除，如insert、udpate、delete**
  - TPL：事务处理语言，对事务进行处理，包括begin transaction、commit、rollback
  - DCL：数据控制语言，进行授权与权限回收，如grant、revoke
  - DDL：数据定义语言，进行数据库、表的管理等，如create、drop
  - CCL：指针控制语言，通过控制指针完成表的操作，如declare cursor
- 对于web程序员来讲，重点是数据的crud（增删改查），必须熟练编写DQL、DML，能够编写DDL完成数据库、表的操作，其它语言如TPL、DCL、CCL了解即可
- SQL 是一门特殊的语言,专门用来操作关系数据库
- 不区分大小写

##### 数据完整性

- 一个数据库就是一个完整的业务单元，可以包含多张表，数据被存储在表中
- 在表中为了更加准确的存储数据，保证数据的正确有效，可以在创建表的时候，为表添加一些强制性的验证，包括数据字段的类型、约束

###### 数据类型

- 可以通过查看帮助文档查阅所有支持的数据类型
- 使用数据类型的原则是：够用就行，尽量使用取值范围小的，而不用大的，这样可以更多的节省存储空间
- 常用数据类型如下：
  - 整数：int，bit
  - 小数：decimal
  - 字符串：varchar,char
  - 日期时间: date, time, datetime
  - 枚举类型(enum)
- 特别说明的类型如下：
  - decimal表示浮点数，如decimal(5,2)表示共存5位数，小数占2位
  - char表示固定长度的字符串，如char(3)，如果填充`'ab'`时会补一个空格为`'ab '`
  - varchar表示可变长度的字符串，如varchar(3)，填充`'ab'`时就会存储`'ab'`
  - 字符串text表示存储大文本，当字符大于4000时推荐使用
  - 对于图片、音频、视频等文件，不存储在数据库中，而是上传到某个服务器上，然后在表中存储这个文件的保存路径
- 更全的数据类型可以参考http://blog.csdn.net/anxpp/article/details/51284106

###### 约束

- 主键primary key：物理上存储的顺序
- 非空not null：此字段不允许填写空值
- 惟一unique：此字段的值不允许重复
- 默认default：当不填写此值时会使用默认值，如果填写时以填写为准
- 外键foreign key：对关系字段进行约束，当为关系字段填写值时，会到关联的表中查询此值是否存在，如果存在则填写成功，如果不存在则填写失败并抛出异常
- 说明：虽然**外键约束**可以保证数据的有效性，但是在进行数据的crud（增加、修改、删除、查询）时，都会降低数据库的性能，所以**不推荐使用**，那么数据的有效性怎么保证呢？答：可以在逻辑层进行控制

###### 数值类型(常用)

| 类型        | 字节大小 | 有符号范围(Signed)                         | 无符号范围(Unsigned)     |
| :---------- | :------- | :----------------------------------------- | :----------------------- |
| TINYINT     | 1        | -128 ~ 127                                 | 0 ~ 255                  |
| SMALLINT    | 2        | -32768 ~ 32767                             | 0 ~ 65535                |
| MEDIUMINT   | 3        | -8388608 ~ 8388607                         | 0 ~ 16777215             |
| INT/INTEGER | 4        | -2147483648 ~2147483647                    | 0 ~ 4294967295           |
| BIGINT      | 8        | -9223372036854775808 ~ 9223372036854775807 | 0 ~ 18446744073709551615 |

###### 字符串

| 类型    | 字节大小 | 示例                                                         |
| :------ | :------- | :----------------------------------------------------------- |
| CHAR    | 0-255    | 类型:char(3) 输入 'ab', 实际存储为'ab ', 输入'abcd' 实际存储为 'abc' |
| VARCHAR | 0-255    | 类型:varchar(3) 输 'ab',实际存储为'ab', 输入'abcd',实际存储为'abc' |
| TEXT    | 0-65535  | 大文本                                                       |

###### 日期时间类型

| 类型      | 字节大小 | 示例                                                  |
| :-------- | :------- | :---------------------------------------------------- |
| DATE      | 4        | '2020-01-01'                                          |
| TIME      | 3        | '12:29:59'                                            |
| DATETIME  | 8        | '2020-01-01 12:29:59'                                 |
| YEAR      | 1        | '2017'                                                |
| TIMESTAMP | 4        | '1970-01-01 00:00:01' UTC ~ '2038-01-01 00:00:01' UTC |

##### 数据库设计

关系型数据库建议在E-R模型的基础上，抽取出来模型与关系，制定出表结构 

在开发中有很多设计数据库的软件，常用的如power designer，db desinger等，这些软件可以直观的看到实体及实体间的关系

###### 三范式

- 经过研究和对使用中问题的总结，对于设计数据库提出了一些规范，这些规范被称为范式(Normal Form)

- 目前有迹可寻的共有8种范式，一般需要遵守3范式即可

- 第一范式（1NF）：强调的是列的原子性，即列不能够再分成其他几列。

  > 考虑这样一个表：【联系人】（姓名，性别，电话） 如果在实际场景中，一个联系人有家庭电话和公司电话，那么这种表结构设计就没有达到 1NF。要符合 1NF 我们只需把列（电话）拆分，即：【联系人】（姓名，性别，家庭电话，公司电话）。1NF 很好辨别，但是 2NF 和 3NF 就容易搞混淆。

  

-  第二范式（2NF）：首先是 1NF，另外包含两部分内容，一是表必须有一个主键；二是没有包含在主键中的列必须完全依赖于主键，而不能只依赖于主键的一部分。

  > 考虑一个订单明细表：【OrderDetail】（OrderID，ProductID，UnitPrice，Discount，Quantity，ProductName）。 因为我们知道在一个订单中可以订购多种产品，所以单单一个 OrderID 是不足以成为主键的，主键应该是（OrderID，ProductID）。显而易见 Discount（折扣），Quantity（数量）完全依赖（取决）于主键（OderID，ProductID），而 UnitPrice，ProductName 只依赖于 ProductID。所以 OrderDetail 表不符合 2NF。不符合 2NF 的设计容易产生冗余数据。
  >
  > 可以把【OrderDetail】表拆分为【OrderDetail】（OrderID，ProductID，Discount，Quantity）和【Product】（ProductID，UnitPrice，ProductName）来消除原订单表中UnitPrice，ProductName多次重复的情况。

  

- 第三范式（3NF）：首先是 2NF，另外非主键列必须直接依赖于主键，不能存在传递依赖。即不能存在：非主键列 A 依赖于非主键列 B，非主键列 B 依赖于主键的情况。

  > 考虑一个订单表【Order】（OrderID，OrderDate，CustomerID，CustomerName，CustomerAddr，CustomerCity）主键是（OrderID）。 其中 OrderDate，CustomerID，CustomerName，CustomerAddr，CustomerCity 等非主键列都完全依赖于主键（OrderID），所以符合 2NF。不过问题是 CustomerName，CustomerAddr，CustomerCity 直接依赖的是 CustomerID（非主键列），而不是直接依赖于主键，它是通过传递才依赖于主键，所以不符合 3NF。 通过拆分【Order】为【Order】（OrderID，OrderDate，CustomerID）和【Customer】（CustomerID，CustomerName，CustomerAddr，CustomerCity）从而达到 3NF。 *第二范式（2NF）和第三范式（3NF）的概念很容易混淆，区分它们的关键点在于，2NF：非主键列是否完全依赖于主键，还是依赖于主键的一部分；3NF：非主键列是直接依赖于主键，还是直接依赖于非主键列。


###### E-R模型

  - E表示entry，实体，设计实体就像定义一个类一样，指定从哪些方面描述对象，一个实体转换为数据库中的一个表
  - R表示relationship，关系，关系描述两个实体之间的对应规则，关系的类型包括包括一对一、一对多、多对多
  - 关系也是一种数据，需要通过一个字段存储在表中
  - 实体A对实体B为1对1，则在表A或表B中创建一个字段，存储另一个表的主键值
  - 实体A对实体B为1对多：在表B中创建一个字段，存储表A的主键值
  - 实体A对实体B为多对多：新建一张表C，这个表只有两个字段，一个用于存储A的主键值，一个用于存储B的主键值

###### 逻辑删除

- 对于重要数据，并不希望物理删除，一旦删除，数据无法找回
- 删除方案：设置isDelete的列，类型为**bit**，表示逻辑删除，默认值为0
- 对于非重要数据，可以进行物理删除

#### Mysql 基本使用

##### 数据库

```mysql
-- 数据库的操作：查看、创建、删除

    -- 链接数据库
    mysql -uroot -p
    mysql -uroot -pmysql

    -- 退出数据库
    exit/quit/ctrl+d
    
    -- sql语句最后需要有分号;结尾
    -- 显示数据库版本
    select version();

    -- 显示时间
    select now();

    -- 查看所有数据库
    show databases;
    
    -- 创建数据库
    -- create database 数据库名 charset=utf8;
    create database python04;
    -- 默认 latin1
    create database python04new charset=utf8;

    -- 查看创建数据库的语句
    -- show crate database ....
    show create database python04;

    -- 查看当前使用的数据库
    select database();

    -- 使用数据库
    -- use 数据库的名字
    use python04new;

    -- 删除数据库
    -- drop database 数据库名;
    drop database python04;
    -- drop database `python-04`
```

##### 数据表

```mysql
-- 数据表的操作：查看、创建、修改、删除

-- 查看当前数据库中所有表
    show tables;
    
-- 创建表
    -- auto_increment表示自动增长
    -- not null 表示不能为空
    -- primary key 表示主键
    -- default 默认值
    -- create table 数据表名字 (字段 类型 约束[, 字段 类型 约束]);
    create table xxxxx(id int, name varchar(30));
    create table yyyyy(id int primary key not null auto_increment, name varchar(30));
    create table zzzzz(
        id int primary key not null auto_increment,
        name varchar(30)
    );
    -- 最后一个不要写 ','   约束没有顺序

-- 查看表结构
    -- desc 数据表的名字;
    desc xxxxx;

    -- 创建students表(id、name、age、high、gender、cls_id)
    create table students(
        id int unsigned not null auto_increment primary key,
        name varchar(30),
        age tinyint unsigned default 0,
        high decimal(5,2),
        gender enum("男", "女", "中性", "保密") default "保密",
        cls_id int unsigned
    );
    -- int 可以有无符号， unsigned 改为无符号
    -- enum 枚举   default 默认

    insert into students values(0, "老王", 18, 188.88, "男", 0);
    -- 顺序必须一致
    select * from students;

    -- 创建classes表(id、name)
    create table classes(
        id int unsigned not null auto_increment primary key,
        name varchar(30)
    );

    insert into classes values(0, "python04大神");
    select * from classes;

    -- 查看表的创建语句
    -- show create table 表名字;
    show create table students;

-- 修改表

    -- 修改表-添加字段
    -- alter table 表名 add 列名 类型;
    alter table students add birthday datetime;
    -- 这不应该用 datetime 后面改

    -- 修改表-修改字段：不重命名版
    -- alter table 表名 modify 列名 类型及约束;
    alter table students modify birthday date;

    -- 修改表-修改字段：重命名版
    -- alter table 表名 change 原名 新名 类型及约束;
    alter table students change birthday birth date default "2000-01-01";

    -- 修改表-删除字段  尽量不删
    -- alter table 表名 drop 列名;
    alter table students drop high;

-- 删除表  尽量不删
    -- drop database 数据库;
    -- drop table 数据表/表名;
    drop table xxxxx;
```

##### CURD

```mysql
-- 增删改查(CURD)：创建（Create）、更新（Update）、读取（Read）、删除（Delete）

    -- 增加
        -- 全列插入
        -- insert [into] 表名 values(...)
        -- 主键字段 可以用 0  null   default 来占位
        -- 向classes表中插入 一个班级
        insert into classes values(0, "菜鸟班");

        +--------+-------------------------------------+------+-----+------------+----------------+
        | Field  | Type                                | Null | Key | Default    | Extra          |
        +--------+-------------------------------------+------+-----+------------+----------------+
        | id     | int(10) unsigned                    | NO   | PRI | NULL       | auto_increment |
        | name   | varchar(30)                         | YES  |     | NULL       |                |
        | age    | tinyint(3) unsigned                 | YES  |     | 0          |                |
        | gender | enum('男','女','中性','保密')       | YES  |     | 保密       |                |
        | cls_id | int(10) unsigned                    | YES  |     | NULL       |                |
        | birth  | date                                | YES  |     | 2000-01-01 |                |
        +--------+-------------------------------------+------+-----+------------+----------------+

        -- 向students表插入 一个学生信息
        insert into students values(0, "小李飞刀", 20, "女", 1, "1990-01-01");
        insert into students values(null, "小李飞刀", 20, "女", 1, "1990-01-01");
        insert into students values(default, "小李飞刀", 20, "女", 1, "1990-01-01");

        -- 失败
        -- insert into students values(default, "小李飞刀", 20, "第4性别", 1, "1990-02-01");

        -- 枚举中 的 下标从1 开始 1---“男” 2--->"女"....
        insert into students values(default, "小李飞刀", 20, 1, 1, "1990-02-01");

        -- 部分插入
        -- insert into 表名(列1,...) values(值1,...)
        insert into students (name, gender) values ("小乔", 2);

        -- 多行插入
        insert into students (name, gender) values ("大乔", 2),("貂蝉", 2);
        insert into students values(default, "西施", 20, "女", 1, "1990-01-01"), (default, "王昭君", 20, "女", 1, "1990-01-01");

    -- 修改
        -- update 表名 set 列1=值1,列2=值2... where 条件;
        update students set gender=1; -- 全部都改
        update students set gender=1 where name="小李飞刀"; -- 只要name是小李飞刀的 全部的修改
        update students set gender=1 where id=3; -- 只要id为3的 进行修改
        update students set age=22, gender=1 where id=3; -- 只要id为3的 进行修改
    
    -- 查询基本使用
        -- 查询所有列
        -- select * from 表名;
        select * from students;

        ---定条件查询
        select * from students where name="小李飞刀"; -- 查询 name为小李飞刀的所有信息
        select * from students where id>3; -- 查询 name为小李飞刀的所有信息

        -- 查询指定列
        -- select 列1,列2,... from 表名;
        select name,gender from students;

        -- 可以使用as为列或表指定别名
        -- select 字段[as 别名] , 字段[as 别名] from 数据表 where ....;
        select name as 姓名,gender as 性别 from students;

        -- 字段的顺序
        select id as 序号, gender as 性别, name as 姓名 from students;
    
    -- 删除
        -- 物理删除
        -- delete from 表名 where 条件
        delete from students; -- 整个数据表中的所有数据全部删除
        delete from students where name="小李飞刀";

        -- 逻辑删除
        -- 用一个字段来表示 这条信息是否已经不能再使用了
        -- 给students表添加一个is_delete字段 bit 类型
        alter table students add is_delete bit default 0;
        update students set is_delete=1 where id=6;
```

##### 备份与恢复

```sh
# 备份
mysqldump –uroot –p 数据库名 > python.sql;
# 恢复
# 1. 连接mysql，创建新的数据库
# 2. 退出连接，执行如下命令
mysql -uroot –p 新数据库名 < python.sql
```

#### Mysql 查询

```mysql
-- 数据的准备
	-- 创建一个数据库
	create database python_test charset=utf8;

	-- 使用一个数据库
	use python_test;

	-- 显示使用的当前数据是哪个?
	select database();

	-- 创建一个数据表
	-- students表
	create table students(
	    id int unsigned primary key auto_increment not null,
	    name varchar(20) default '',
	    age tinyint unsigned default 0,
	    height decimal(5,2),
	    gender enum('男','女','中性','保密') default '保密',
	    cls_id int unsigned default 0,
	    is_delete bit default 0
	);

	-- classes表
	create table classes (
	    id int unsigned auto_increment primary key not null,
	    name varchar(30) not null
	);
	-- 向students表中插入数据
    insert into students values
    (0,'小明',18,180.00,2,1,0),
    (0,'小月月',18,180.00,2,2,1),
    (0,'彭于晏',29,185.00,1,1,0),
    (0,'刘德华',59,175.00,1,2,1),
    (0,'黄蓉',38,160.00,2,1,0),
    (0,'凤姐',28,150.00,4,2,1),
    (0,'王祖贤',18,172.00,2,1,1),
    (0,'周杰伦',36,NULL,1,1,0),
    (0,'程坤',27,181.00,1,2,0),
    (0,'刘亦菲',25,166.00,2,2,0),
    (0,'金星',33,162.00,3,3,1),
    (0,'静香',12,180.00,2,4,0),
    (0,'郭靖',12,170.00,1,4,0),
    (0,'周杰',34,176.00,2,5,0);

    -- 向classes表中插入数据
    insert into classes values (0, "python_01期"), (0, "python_02期"), (0, "python_04期");
    
-- 查询
	-- 查询所有字段
	-- select * from 表名;
	select * from students;
	select * from classes;
	select id, name from classes;

	-- 查询指定字段
	-- select 列1,列2,... from 表名;
	select name, age from students;
	
	-- 使用 as 给字段起别名
	-- select 字段 as 名字.... from 表名;
	select name as 姓名, age as 年龄 from students;

	-- select 表名.字段 .... from 表名;
	select students.name, students.age from students;

	-- 可以通过 as 给表起别名
	-- select 别名.字段 .... from 表名 as 别名;
	select students.name, students.age from students;
	select s.name, s.age from students as s;
	-- 失败的select students.name, students.age from students as s;

	-- 消除重复行
	-- distinct 字段
	select distinct gender from students;    
```

##### 条件

```mysql
-- 条件查询
    -- select .... from 表名 where .....
	
	-- 比较运算符
		-- > <  大于 小于
		-- 查询大于18岁的信息
		select * from students where age>18;
		select id,name,gender from students where age>18;
		select * from students where age<18;

		-- >=  <=  大于等于 小于等于
		-- 查询小于或者等于18岁的信息

		-- =
		-- 查询年龄为18岁的所有学生的名字
		select * from students where age=18;

		-- != 或者 <>  不等于

	-- 逻辑运算符
		-- and
		-- 18到28之间的所以学生信息
		select * from students where age>18 and age<28;
		-- 失败select * from students where age>18 and <28;

		-- 18岁以上的女性
		select * from students where age>18 and gender="女";
		select * from students where age>18 and gender=2;

		-- or
		-- 18以上或者身高查过180(包含)以上
		select * from students where age>18 or height>=180;

		-- not
		-- 不在 18岁以上的女性 这个范围内的信息
		-- select * from students where not age>18 and gender=2;
		select * from students where not (age>18 and gender=2);

		-- 年龄不是小于或者等于18 并且是女性
		select * from students where (not age<=18) and gender=2;

	-- 模糊查询
		-- like 
		-- % 替换0个或者多个
		-- _ 替换1个
		-- 查询姓名中 以 "小" 开始的名字
		select name from students where name="小";
		select name from students where name like "小%";

		-- 查询姓名中 有 "小" 所有的名字
		select name from students where name like "%小%";

		-- 查询有2个字的名字
		select name from students where name like "__";

		-- 查询有3个字的名字
		select name from students where name like "___";

		-- 查询至少有2个字的名字
		select name from students where name like "__%";

		-- rlike 正则
		-- 查询以 周开始的姓名
		select name from students where name rlike "^周.*";

		-- 查询以 周开始、伦结尾的姓名
		select name from students where name rlike "^周.*伦$";

	-- 范围查询
		-- in (1, 3, 8)表示在一个非连续的范围内
		-- 查询 年龄为18、34的姓名
		select name,age from students where age=18 or age=34;
		select name,age from students where age=18 or age=34 or age=12;
		select name,age from students where age in (12, 18, 34);

		-- not in 不非连续的范围之内
		-- 年龄不是 18、34岁之间的信息
		select name,age from students where age not in (12, 18, 34);

		-- between ... and ...表示在一个连续的范围内
		-- 查询 年龄在18到34之间的的信息
		select name, age from students where age between 18 and 34;
		
		-- not between ... and ...表示不在一个连续的范围内
		-- 查询 年龄不在在18到34之间的的信息
		select * from students where age not between 18 and 34;
		-- 正确的select * from students where not age between 18 and 34;
		-- 失败的select * from students where age not (between 18 and 34);
		-- not between 是一种用法  不是取反  上面那个是 取反 not age ...

	-- 空判断
		-- 判空is null
		-- 查询身高为空的信息
		select * from students where height is null;
		select * from students where height is NULL;
		select * from students where height is Null;

		-- 判非空is not null
		select * from students where height is not null;
```

**where**后面支持多种运算符，进行条件的处理：**比较运算符、逻辑运算符、模糊查询、范围查询、空判断**

##### 排序

```mysql
-- 排序
    -- select * from 表名 order by 列1 asc|desc [,列2 asc|desc,...]
    -- 将行数据按照列1进行排序，如果某些行列1的值相同时，则按照列2排序，以此类推
    
	-- order by 字段
	-- asc从小到大排列，即升序  默认
	-- desc从大到小排序，即降序

	-- 查询年龄在18到34岁之间的男性，按照年龄从小到到排序
	select * from students where (age between 18 and 34) and gender=1;
	select * from students where (age between 18 and 34) and gender=1 order by age;
	select * from students where (age between 18 and 34) and gender=1 order by age asc;

	-- 查询年龄在18到34岁之间的女性，身高从高到矮排序
	select * from students where (age between 18 and 34) and gender=2 order by height desc;
	-- 相同值时按照主键升序排列

	-- order by 多个字段
	-- 查询年龄在18到34岁之间的女性，身高从高到矮排序, 如果身高相同的情况下按照年龄从小到大排序
	select * from students where (age between 18 and 34) and gender=2 order by height desc,id desc;

	-- 查询年龄在18到34岁之间的女性，身高从高到矮排序, 如果身高相同的情况下按照年龄从小到大排序,
	-- 如果年龄也相同那么按照id从大到小排序
	select * from students where (age between 18 and 34) and gender=2 order by height desc,age asc,id desc;

	-- 按照年龄从小到大、身高从高到矮的排序
	select * from students order by age asc, height desc;
```

##### 聚合函数

```mysql
-- 聚合函数
    -- count max min sum avg round
    
	-- 总数 count()
	-- 查询男性有多少人，女性有多少人
	select * from students where gender=1;
	select count(*) from students where gender=1;
	select count(*) as 男性人数 from students where gender=1;
	select count(*) as 女性人数 from students where gender=2;

	-- 最大值 max()
	-- 查询最大的年龄  先查出来，再找
	select age from students;
	select max(age) from students;

	-- 查询女性的最高 身高
	select max(height) from students where gender=2;

	-- 最小值 min()
	
	-- 求和 sum()
	-- 计算所有人的年龄总和
	select sum(age) from students;
	
	-- 平均值 avg()
	-- 计算平均年龄
	select avg(age) from students;

	-- 计算平均年龄 sum(age)/count(*)  tong
	select sum(age)/count(*) from students;

	-- 四舍五入 round(123.23 , 1) 保留1位小数  可为0
	-- 计算所有人的平均年龄，保留2位小数
	select round(sum(age)/count(*), 2) from students;
	select round(sum(age)/count(*), 3) from students;

	-- 计算男性的平均身高 保留2位小数
	select round(avg(height), 2) from students where gender=1;
	-- select name, round(avg(height), 2) from students where gender=1;

	-- 需要存小数时，扩大整数倍存  3.14 * 100 -> 314
```

需要**存小数**时，存在误差，**扩大**整数倍**存**  **3.14 * 100 -> 314**

##### 分组

```mysql
-- 分组
	-- 分组意义是和 聚合函数 一起用
	-- 先分组，再从组里取数据

	-- group by
	-- 按照性别分组,查询所有的性别
	-- 失败select name from students group by gender; 因为 name 在每组内有多个值
	-- 失败select * from students group by gender;
	select gender from students group by gender;

	-- 计算每种性别中的人数
	select gender,count(*) from students group by gender;
	-- 使用的是分组后的数据

	-- 计算男性的人数
	select gender,count(*) from students where gender=1 group by gender;

	-- group_concat(...)
	-- 查询同种性别中的姓名
 	select gender,group_concat(name) from students where gender=1 group by gender;
 	select gender,group_concat(name, age, id) from students where gender=1 group by gender;
 	select gender,group_concat(name, "_", age, " ", id) from students where gender=1 group by gender;

	-- having  是对分组后的数据进行判断
	-- 查询平均年龄超过30岁的性别，以及姓名 having avg(age) > 30
	select gender, group_concat(name),avg(age) from students group by gender having avg(age)>30;
	
	-- 查询每种性别中的人数多于2个的信息
	select gender, group_concat(name) from students group by gender having count(*)>2;
```

##### 分页

```mysql
-- 分页
	-- limit start, count  limit要在最后

	-- 限制查询出来的数据个数
	select * from students where gender=1 limit 2;

	-- 查询前5个数据
	select * from students limit 0, 5;

	-- 查询id6-10（包含）的书序
	select * from students limit 5, 5;

	-- 每页显示2个，第1个页面
	select * from students limit 0,2;
	-- 每页显示2个，第2个页面
	select * from students limit 2,2;
	-- 每页显示2个，第3个页面
	select * from students limit 4,2;
	-- 每页显示2个，第4个页面
	select * from students limit 6,2; 
	-- -----> limit (第N页-1)*每页的个数, 每页的个数;

	-- 每页显示2个，显示第6页的信息, 按照年龄从小到大排序
	-- 失败select * from students limit 2*(6-1),2;
	-- 失败select * from students limit 10,2 order by age asc;
	select * from students order by age asc limit 10,2;

	select * from students where gender=2 order by height desc limit 0,2;
```

##### 连接查询

当查询结果的列来源于多张表时，需要将多张表连接成一个大的数据集，再选择合适的列返回。mysql支持三种类型的连接查询，分别为：

- 内连接查询：查询的结果为两个表匹配到的数据
-  右连接查询：查询的结果为两个表匹配到的数据，右表特有的数据，对于左表中不存在的数据使用null填充 
-  左连接查询：查询的结果为两个表匹配到的数据，左表特有的数据，对于右表中不存在的数据使用null填充 

```mysql
-- 连接查询
    -- select * from 表1 inner或left或right join 表2 on 表1.列 = 表2.列
    -- 多个表 合并数据
    
	-- inner join ... on  内连接  交集
	-- select ... from 表A inner join 表B;
	select * from students inner join classes;

	-- 查询 有能够对应班级的学生以及班级信息
	select * from students inner join classes on students.cls_id=classes.id;

	-- 按照要求显示姓名、班级
	select students.*, classes.name from students inner join classes on students.cls_id=classes.id;
	select students.name, classes.name from students inner join classes on students.cls_id=classes.id;

	-- 给数据表起名字
	select s.name, c.name from students as s inner join classes as c on s.cls_id=c.id;

	-- 查询 有能够对应班级的学生以及班级信息，显示学生的所有信息，只显示班级名称
	select s.*, c.name from students as s inner join classes as c on s.cls_id=c.id;
	
	-- 在以上的查询中，将班级姓名显示在第1列
	select c.name, s.* from students as s inner join classes as c on s.cls_id=c.id;

	-- 查询 有能够对应班级的学生以及班级信息, 按照班级进行排序
	-- select c.xxx s.xxx from student as s inner join clssses as c on .... order by ....;
	select c.name, s.* from students as s inner join classes as c on s.cls_id=c.id order by c.name;

	-- 当时同一个班级的时候，按照学生的id进行从小到大排序
	select c.name, s.* from students as s inner join classes as c on s.cls_id=c.id order by c.name,s.id;

    -- 外连接  左/右
	-- left join 左连接  以左表为基准取，没有为 null
	-- 查询每位学生对应的班级信息
	select * from students as s left join classes as c on s.cls_id=c.id;

	-- 查询没有对应班级信息的学生
	-- select ... from xxx as s left join xxx as c on..... where .....
	-- select ... from xxx as s left join xxx as c on..... having .....
	select * from students as s left join classes as c on s.cls_id=c.id having c.id is null;
	select * from students as s left join classes as c on s.cls_id=c.id where c.id is null;
	-- 结果中判断 最好用 having ,对原表判断 where

	-- right join   on
	-- 将数据表名字互换位置，用left join完成
```

##### 自关联

```mysql
-- 自关联
	-- 省级联动 url:http://demo.lanrenzhijia.com/2014/city0605/
	-- 将多个表的数据在一个表中存储   结构一致
	
	-- create table areas(aid int primary key, atitle varchar(20), pid int);
	-- 因为省没有所属的省份，所以可以填写为null
	-- 城市所属的省份pid，填写省所对应的编号id
	-- 这就是自关联，表中的某一列，关联了这个表中的另外一列，但是它们的业务逻辑含义是不一样的，城市信息的pid引用的是省信息的id
	-- 在这个表中，结构不变，可以添加区县、乡镇街道、村社区等信息

	-- 查询所有省份
	select * from areas where pid is null;

	-- 查询出山东省有哪些市  自己构建两个表
	select * from areas as province inner join areas as city on city.pid=province.aid having province.atitle="山东省";
	select province.atitle, city.atitle from areas as province inner join areas as city on city.pid=province.aid having province.atitle="山东省";

	-- 查询出青岛市有哪些县城
	select province.atitle, city.atitle from areas as province inner join areas as city on city.pid=province.aid having province.atitle="青岛市";
	select * from areas where pid=(select aid from areas where atitle="青岛市")
```

##### 子查询

```mysql
-- 子查询
    -- 在一个 select 语句中,嵌入了另外一个 select 语句, 那么被嵌入的 select 语句称之为子查询语句
    -- 子查询是嵌入到主查询中，是可以独立存在的语句，是一条完整的 select 语句
    
	-- 标量子查询  子查询返回的结果是一个数据(一行一列)
	-- 查询出高于平均身高的信息
    select * from students where height > (select avg(height) from students);
    
	-- 查询最高的男生信息
	select * from students where height = 188;
	select * from students where height = (select max(height) from students);

	-- 列级子查询  返回的结果是一列(一列多行)
	-- 查询学生的班级号能够对应的学生信息
	select * from students where cls_id in (select id from classes);
	-- 格式: 主查询 where 条件 in (列子查询)

    -- 行级子查询  返回的结果是一行(一行多列)
    -- 查找班级年龄最大，身高最高的学生
    select * from students where (height,age) = (select max(height),max(age) from students);
```

##### 总结

查询的完整格式

```mysql
SELECT select_expr [,select_expr,...] [      
      FROM tb_name
      [WHERE 条件判断]
      [GROUP BY {col_name | postion} [ASC | DESC], ...] 
      [HAVING 条件判断]
      [ORDER BY {col_name|expr|postion} [ASC | DESC], ...]
      [LIMIT {[offset,]rowcount | row_count OFFSET offset}]
]

-- 完整的select语句
select distinct *
from 表名
where ....
group by ... having ...
order by ...
limit start,count
```

- 执行顺序为：

  `from 表名` > `where ..` > `group by ..` > `select distinct *` > `having ..` > `order by ..` > `limit start,count`

- 实际使用中，只是语句中**某些**部分的**组合**，而不是全部

#### Mysql 与 Python 交互

##### 准备数据

创建数据表

```mysql
-- 创建 "京东" 数据库
create database jing_dong charset=utf8;
-- 使用 "京东" 数据库
use jing_dong;
-- 创建一个商品goods数据表
create table goods(
    id int unsigned primary key auto_increment not null,
    name varchar(150) not null,
    cate_name varchar(40) not null,
    brand_name varchar(40) not null,
    price decimal(10,3) not null default 0,
    is_show bit not null default 1,
    is_saleoff bit not null default 0
);
```

插入数据

```mysql
-- 向goods表中插入数据
insert into goods values(0,'r510vc 15.6英寸笔记本','笔记本','华硕','3399',default,default); 
insert into goods values(0,'y400n 14.0英寸笔记本电脑','笔记本','联想','4999',default,default);
insert into goods values(0,'g150th 15.6英寸游戏本','游戏本','雷神','8499',default,default); 
insert into goods values(0,'x550cc 15.6英寸笔记本','笔记本','华硕','2799',default,default); 
insert into goods values(0,'x240 超极本','超级本','联想','4880',default,default); 
insert into goods values(0,'u330p 13.3英寸超极本','超级本','联想','4299',default,default); 
insert into goods values(0,'svp13226scb 触控超极本','超级本','索尼','7999',default,default); 
insert into goods values(0,'ipad mini 7.9英寸平板电脑','平板电脑','苹果','1998',default,default);
insert into goods values(0,'ipad air 9.7英寸平板电脑','平板电脑','苹果','3388',default,default); 
insert into goods values(0,'ipad mini 配备 retina 显示屏','平板电脑','苹果','2788',default,default); 
insert into goods values(0,'ideacentre c340 20英寸一体电脑 ','台式机','联想','3499',default,default); 
insert into goods values(0,'vostro 3800-r1206 台式电脑','台式机','戴尔','2899',default,default); 
insert into goods values(0,'imac me086ch/a 21.5英寸一体电脑','台式机','苹果','9188',default,default); 
insert into goods values(0,'at7-7414lp 台式电脑 linux ）','台式机','宏碁','3699',default,default); 
insert into goods values(0,'z220sff f4f06pa工作站','服务器/工作站','惠普','4288',default,default); 
insert into goods values(0,'poweredge ii服务器','服务器/工作站','戴尔','5388',default,default); 
insert into goods values(0,'mac pro专业级台式电脑','服务器/工作站','苹果','28888',default,default); 
insert into goods values(0,'hmz-t3w 头戴显示设备','笔记本配件','索尼','6999',default,default); 
insert into goods values(0,'商务双肩背包','笔记本配件','索尼','99',default,default); 
insert into goods values(0,'x3250 m4机架式服务器','服务器/工作站','ibm','6888',default,default); 
insert into goods values(0,'商务双肩背包','笔记本配件','索尼','99',default,default);
```

如果字段为主键，`0 null default` 都可以，如果想要字段**取默认值**，**应该用  `default`** 

##### SQL语句的强化

- 查询类型cate_name为 '超极本' 的商品名称、价格

```mysql
select name,price from goods where cate_name = '超级本';
```

- 显示商品的种类

```mysql
select cate_name from goods group by cate_name;
```

- 求所有电脑产品的平均价格,并且保留两位小数

```mysql
select round(avg(price),2) as avg_price from goods;
```

- 显示每种商品的平均价格

```mysql
select cate_name,avg(price) from goods group by cate_name;
```

- 查询每种类型的商品中 最贵、最便宜、平均价、数量

```mysql
select cate_name,max(price),min(price),avg(price),count(*) from goods group by cate_name;
```

- 查询所有价格大于平均价格的商品，并且按价格降序排序

```mysql
select id,name,price from goods 
where price > (select round(avg(price),2) as avg_price from goods) 
order by price desc;
```

- 查询每种类型中最贵的电脑信息

```mysql
select * from goods
inner join 
    (
        select
        cate_name, 
        max(price) as max_price, 
        from goods group by cate_name
    ) as goods_new_info 
on goods.cate_name=goods_new_info.cate_name and goods.price=goods_new_info.max_price;  
-- goods_new_info.max(price) 不可以，所以需要 as
-- 左连接时 goods 需要在右边
```

这有同样的价格时会全部显示

##### 拆分为多个表

这只是学习怎么拆，**开发中会先设计表**

1) 商品分类表

```mysql
-- 创建商品分类表
create table if not exists goods_cates(
    id int unsigned primary key auto_increment,
    name varchar(40) not null
);
-- 查询goods表中商品的种类
select cate_name from goods group by cate_name;
-- 将分组结果写入到goods_cates数据表
insert into goods_cates (name) select cate_name from goods group by cate_name;  -- 列级子查询
-- 这不需要 values
```

2) 同步数据

```mysql
-- 通过goods_cates数据表来更新goods表  update 中也可以使用 连接的方式
update goods as g inner join goods_cates as c on g.cate_name=c.name set g.cate_name=c.id;
```

3) 商品品牌表

```mysql
-- select brand_name from goods group by brand_name;
-- 通过create...select来创建数据表并且同时写入记录,一步到位
-- 注意: 需要对brand_name 用as起别名，否则name字段就没有值
create table goods_brands (
    id int unsigned primary key auto_increment,
    name varchar(40) not null) select brand_name as name from goods group by brand_name;
```

4) 同步数据

```mysql
-- 通过goods_brands数据表来更新goods数据表
update goods as g inner join goods_brands as b on g.brand_name=b.name set g.brand_name=b.id;
```

5) 修改表结构

```mysql
-- 查看 goods 的数据表结构,会发现 cate_name 和 brand_name对应的类型为 `varchar` 但是存储的都是数字
desc goods;
-- 通过alter table语句修改表结构  (改为与另两个表一致)
alter table goods  
change cate_name cate_id int unsigned not null,
change brand_name brand_id int unsigned not null;
```

###### 外键(尽量别用)

```mysql
-- 分别在 goods_cates 和 goods_brands表中插入记录
insert into goods_cates(name) values ('路由器'),('交换机'),('网卡');
insert into goods_brands(name) values ('海尔'),('清华同方'),('神舟');
-- 在 goods 数据表中写入任意记录
insert into goods (name,cate_id,brand_id,price) 
values('LaserJet Pro P1606dn 黑白激光打印机', 12, 4,'1849');  -- 12 在 goods_cates 中 不存在
```

```mysql
-- 查询所有商品的详细信息 (通过内连接/左连接)
select g.id,g.name,c.name,b.name,g.price from goods as g
inner join goods_cates as c on g.cate_id=c.id
inner join goods_brands as b on g.brand_id=b.id;
```

- 如何**防止无效信息的插入**,就是可以在插入前判断类型或者品牌名称是否存在呢? 可以使用**外键**解决
- 外键约束:对数据的有效性进行验证
- 关键字: foreign key,只有 innodb数据库引擎 支持外键约束
- 对于已经存在的数据表 如何更新外键约束

```mysql
-- 给brand_id 添加外键约束成功
alter table goods add foreign key (brand_id) references goods_brands(id);
-- 给cate_id 添加外键失败，会出现1452错误
-- 错误原因:已经添加了一个不存在的cate_id值12,因此需要先删除
alter table goods add foreign key (cate_id) references goods_cates(id);
```

在创建数据表的时候设置外键约束，注意: goods 中的 cate_id 的类型一定要和 goods_cates 表中的 id 类型一致

```mysql
create table goods(
    id int primary key auto_increment not null,
    name varchar(40) default '',
    price decimal(5,2),
    cate_id int unsigned,
    brand_id int unsigned,
    is_show bit default 1,
    is_saleoff bit default 0,
    foreign key(cate_id) references goods_cates(id),
    foreign key(brand_id) references goods_brands(id)
);
```

如何取消外键约束

```mysql
-- 需要先获取外键约束名称,该名称系统会自动生成,可以通过查看表创建语句来获取名称
show create table goods;
-- 获取名称之后就可以根据名称来删除外键约束
alter table goods drop foreign key 外键名称;
```

- **在实际开发中,很少会使用到外键约束,会极大的降低表更新的效率**  -- 由于存储在硬盘

##### Python 中操作 MySQL 

<img src="https://user-images.githubusercontent.com/51505633/80234867-6fa6cd00-868b-11ea-9ee8-392a31bf5f6f.jpeg" alt="WechatIMG9052" style="zoom: 25%;" />

- 在py文件中引入pymysql模块

###### Connection 对象

- 用于建立与数据库的连接
- 创建对象：调用connect()方法

```python
from pymysql import *
conn=connect(参数列表)
# 参数host：连接的mysql主机，如果本机是'localhost'
# 参数port：连接的mysql主机的端口，默认是3306
# 参数database：数据库的名称
# 参数user：连接的用户名
# 参数password：连接的密码
# 参数charset：通信采用的编码方式，推荐使用utf8
```

对象的方法

- close()，关闭连接
- commit()，提交
- cursor()，返回Cursor对象，用于执行sql语句并获得结果
- rollback()，回滚

###### Cursor对象 (游标对象)

- 用于执行sql语句，使用频度最高的语句为select、insert、update、delete
- 获取Cursor对象：调用Connection对象的cursor()方法

```python
cs1=conn.cursor()
```

对象的方法

- close()关闭
- execute(operation [, parameters ])执行语句，返回受影响的行数，主要用于执行insert、update、delete语句，也可以执行create、alter、drop等语句
- fetchone()执行查询语句时，获取查询结果集的第一个行数据，返回一个元组
- fetchmany() 需要参数 取的行数据数量
- fetchall()执行查询时，获取结果集的所有行，一行构成一个元组，再将这些元组装入一个元组返回

对象的属性

- rowcount只读属性，表示最近一次execute()执行后受影响的行数
- connection获得当前连接对象

##### 增删改查

###### 查询数据

```python
from pymysql import *
def main():
    # 创建Connection连接
    conn = connect(host='localhost',port=3306,user='root',
                   password='mysql',database='jing_dong',charset='utf8')
    # 获得Cursor对象
    cs1 = conn.cursor()
    # 执行select语句，并返回受影响的行数：查询一条数据
    count = cs1.execute('select id,name from goods where id>=4')
    # 打印受影响的行数
    print("查询到%d条数据:" % count)
    for i in range(count):
        result = cs1.fetchone()  # 获取查询的结果
        print(result)
    # 或者
    # result = cs1.fetchall()
    # 关闭Cursor对象
    cs1.close()
    conn.close()
if __name__ == '__main__':
    main()
```

###### 增删改 数据

增删改操作 会修改数据库，查询不会    --  需要提交修改

```python
# 提交之前的操作，如果之前已经之执行过多次的execute，那么就都进行提交
conn.commit()  # 提交才生效，不然无效
# 执行execute 时，主键会自动增长  防止并发
conn.rollback()  # 回滚，其之前没提交的execute 不会生效  主键id 不会变为原来的，为增长后的
```

```python
from pymysql import *
def main():
    # 创建Connection连接
    conn = connect(host='localhost',port=3306,database='jing_dong',
                   user='root',password='mysql',charset='utf8')
    # 获得Cursor对象
    cs1 = conn.cursor()
    # 执行insert语句，并返回受影响的行数：添加一条数据
    # 增加
    count = cs1.execute('insert into goods_cates(name) values("硬盘")')
    print(count) # 打印受影响的行数
    # 更新
    count = cs1.execute('update goods_cates set name="机械硬盘" where name="硬盘"')
    # 删除
    count = cs1.execute('delete from goods_cates where id=6')
    # 提交之前的操作，如果之前已经之执行过多次的execute，那么就都进行提交
    conn.commit()
    # 关闭Cursor对象
    cs1.close()
    # 关闭Connection对象
    conn.close()
if __name__ == '__main__':
    main()
```

##### 参数化

- sql语句的参数化，可以有效防止sql注入
- 注意：此处不同于python的字符串格式化，全部使用%s占位

```python
from pymysql import *
def main():
    find_name = input("请输入物品名称：")
    # 创建Connection连接
    conn = connect(host='localhost',port=3306,user='root',
                   password='mysql',database='jing_dong',charset='utf8')
    # 获得Cursor对象
    cs1 = conn.cursor()
    # 非安全的方式
    # 输入 " or 1=1 or "   (双引号也要输入)
    # sql = 'select * from goods where name="%s"' % find_name
    # print("""sql===>%s<====""" % sql)
    # 执行select语句：会查询所有数据
    # cs1.execute(sql)

    # 安全的方式
    # 构造参数列表
    params = [find_name]
    # 执行select语句：查询数据
    cs1.execute('select * from goods where name=%s', params)
    # 注意：如果要是有多个参数，需要进行参数化
    # 那么params = [数值1, 数值2....]，此时sql语句中有多个%s即可 

    # 获取查询的结果
    result = cs1.fetchall()
    print(result)
    # 关闭Cursor对象
    cs1.close()
    conn.close()
if __name__ == '__main__':
    main()
```

#### Mysql 高级

##### 视图

> 对于复杂的查询，往往是有多个数据表进行关联查询而得到，如果数据库因为需求等原因发生了改变，为了保证查询出来的数据与之前相同，则需要在多个地方进行修改，维护起来非常麻烦
>
> 解决办法：定义**视图**

通俗的讲，**视图就是一条SELECT语句执行后返回的结果集**。所以我们在创建视图的时候，主要的工作就落在创建这条SQL查询语句上。

视图是对若干张基本表的引用，一张**虚表**，**查询**语句执行的**结果**，**不存储**具体的**数据**（基本表数据发生了改变，视图也会跟着改变）

 方便操作，特别是**查询操作**

```mysql
-- 定义视图：建议以v_开头
create view 视图名称 as select语句;
-- 查看视图：查看表会将所有的视图也列出来
show tables;
-- 使用视图：视图的用途就是查询
select * from v_stu_score;
-- 删除视图
drop view 视图名称;
```

###### 视图 demo

```mysql
create view v_goods_info as select g.*,c.name as cate_name, b.name as brand_name from goods as g left join goods_cates as c on g.cate_id = c.id left join goods_brands as b on g.cate_id = b.id;
show tables;
select * from v_goods_info;
```

###### 视图的作用

1. 提高了重用性，就像一个函数
2. 对数据库重构，却不影响程序的运行
3. 提高了安全性能，可以对不同的用户
4. 让数据更加清晰

##### 事务

所谓事务，是一个操作序列，这些操作要么都执行，要么都不执行，它是一个不可分割的工作单位。 

> 下面举一个银行应用是解释事务必要性的一个经典例子。假如一个银行的数据库有两张表：支票表（checking）和储蓄表（savings）。现在要从用户Jane的支票账户转移200美元到她的储蓄账户，那么至少需要三个步骤：
>
> 1. 检查支票账户的余额高于或者等于200美元。
> 2. 从支票账户余额中减去200美元。
> 3. 在储蓄帐户余额中增加200美元。
>
> 上述三个步骤的操作必须打包在一个事务中，任何一个步骤失败，则必须回滚所有的步骤。

###### 事务四大特性(简称ACID)

原子性(Atomicity)、一致性(Consistency)、隔离性(Isolation)、持久性(Durability)

###### 原子性

一个事务必须被视为一个不可分割的最小工作单元，整个事务中的所有操作要么全部提交成功，要么全部失败回滚，对于一个事务来说，不可能只执行其中的一部分操作，这就是事务的原子性

###### 一致性

数据库总是从一个一致性的状态转换到另一个一致性的状态。（在前面的例子中，一致性确保了，即使在执行第三、四条语句之间时系统崩溃，支票账户中也不会损失200美元，因为事务最终没有提交，所以事务中所做的修改也不会保存到数据库中。）

###### 隔离性

通常来说，一个事务所做的修改在最终提交以前，对其他事务是不可见的。（在前面的例子中，当执行完第三条语句、第四条语句还未开始时，此时有另外的一个账户汇总程序开始运行，则其看到支票帐户的余额并没有被减去200美元。）

###### 持久性

一旦事务提交，则其所做的修改会永久保存到数据库。（此时即使系统崩溃，修改的数据也不会丢失。）

###### 事务命令

表的引擎类型必须是innodb类型才可以使用事务，这是mysql表的默认引擎

```mysql
-- 开启事务：开启事务后执行修改命令，变更会维护到本地缓存中，而不维护到物理表中
begin;
-- 或者
start transaction;

-- 提交事务:将缓存中的数据变更维护到物理表中
commit;
-- 回滚事务：放弃缓存中变更的数据
rollback;
```

> **增删改**
>
> python中 执行execute时 默认开启了事务，需手动 commit；
>
> mysql客户端也默认开启了事务，但自动 commit；有需要时须手动开启事务

##### 索引

一般的应用系统对比数据库的读写比例在10:1左右(即有10次查询操作时有1次写的操作)，而且插入操作和更新操作很少出现性能问题，遇到最多、最容易出问题还是一些复杂的查询操作，所以查询语句的优化显然是重中之重。

当数据库中数据量很大时，查找数据会变得很慢，优化方案：**索引**

> **索引**是一种特殊的**文件**(InnoDB数据表上的索引是表空间的一个组成部分)，它们包含着对数据表里所有记录的**引用指针**。

更通俗的说，数据库索引好比是一本书前面的目录，能加快数据库的查询速度

索引的目的在于**提高查询效率**。

Mysql 索引使用 B-Tree

<img src="https://user-images.githubusercontent.com/51505633/80298512-98c87a00-87bf-11ea-845f-12fedc3d3d0a.jpg" alt="7178f37egw1err37xke42j20hc08caax" style="zoom: 67%;" />

###### 索引的使用

```mysql
-- 查看索引
show index from 表名;
-- 创建索引
-- - 如果指定字段是字符串，需要指定长度，建议长度与定义字段时的长度一致
-- - 字段类型如果不是字符串，可以不填写长度部分
create index 索引名称 on 表名(字段名称(长度))
-- 删除索引
drop index 索引名称 on 表名;
```

###### 索引demo

```mysql
-- 创建测试表testindex
create table test_index(title varchar(10));
```

使用python程序向表中加入十万条数据

```python
from pymysql import connect
def main():
    # 创建Connection连接
    conn = connect(host='localhost',port=3306,database='jing_dong',
                   user='root',password='mysql',charset='utf8')
    # 获得Cursor对象
    cursor = conn.cursor()
    # 插入10万次数据
    for i in range(100000):
        cursor.execute("insert into test_index values('ha-%d')" % i)
    # 提交数据
    conn.commit()
if __name__ == "__main__":
    main()
```

查询

```mysql
-- 开启运行时间监测
set profiling=1;
-- 查找第1万条数据ha-99999
select * from test_index where title='ha-99999';
-- 查看执行的时间
show profiles;
-- 为表title_index的title列创建索引
create index title_index on test_index(title(10));
select * from test_index where title='ha-99999';
-- 再次查看执行的时间
show profiles;
```

###### 注意

1. 建立太多的索引将会影响更新和插入的速度，因为它需要同样更新每个索引文件。对于一个经常需要更新和插入的表格，就没有必要为一个很少使用的where字句单独建立索引了，对于比较小的表，排序的开销不会很大，也没有必要建立另外的索引。
2. 建立索引会占用磁盘空间

##### 账户管理

> MySQL账户体系：根据账户所具有的权限的不同，MySQL的账户可以分为以下几种：
>
> - 服务实例级账号：启动了一个mysqld，即为一个数据库实例；如果某用户如root,拥有服务实例级分配的权限，那么该账号就可以删除所有的数据库、连同这些库中的表
> - 数据库级别账号：对特定数据库执行增删改查的所有操作
> - 数据表级别账号：对特定表执行增删改查等所有操作
> - 字段级别的权限：对某些表的特定字段进行操作
> - 存储程序级别的账号：对存储程序进行增删改查的操作

在生产环境下操作数据库时，绝对不可以使用root账户连接，而是创建特定的账户，授予这个账户特定的操作权限。账户的操作主要包括创建账户、删除账户、修改密码、授权权限等。

1. 进行账户操作时，需要使用root账户登录，这个账户拥有最高的实例级权限
2. 通常都使用数据库级操作权限

###### 授予权限

```mysql
-- 1. 查看所有用户
-- 所有用户及权限信息存储在mysql数据库的user表中
select host,user,authentication_string from user;
-- Host表示允许访问的主机, User表示用户名, authentication_string表示密码，为加密后的值

-- 2. 创建账户、授权  --需要使用root账户登录
-- 常用权限主要包括：create、alter、drop、insert、update、delete、select
-- 如果分配所有权限，可以使用all privileges
-- grant 权限列表 on 数据库 to '用户名'@'访问主机' identified by '密码';

-- 创建一个laowang的账号，密码为123456，只能通过本地访问, 并且只能对jing_dong数据库中的所有表进行读操作
grant select on jing_dong.* to 'laowang'@'localhost' identified by '123456';
-- 可以操作python数据库的所有表，方式为:jing_dong.*
-- 访问主机通常使用 百分号% 表示此账户可以使用任何ip的主机登录访问此数据库
-- 访问主机可以设置成 localhost或具体的ip，表示只允许本机或特定主机访问

-- 查看用户有哪些权限
show grants for laowang@localhost;
-- 退出root的登录后，再使用laowang账户登录 查看效果

-- 创建一个laoli的账号，密码为12345678，可以任意电脑连接访问, 并且对jing_dong数据库中的所有表拥有所有权限
grant all privileges on jing_dong.* to "laoli"@"%" identified by "12345678"
```

###### 账户操作

```mysql
-- 1. 修改权限
-- grant 权限名称 on 数据库 to 账户@主机 with grant option;
grant select,insert on jing_dong.* to 'laowang'@'localhost' with grant option;
-- 注意修改完成后需要刷新权限
flush privileges;

-- 2. 修改密码
-- 使用root登录，修改mysql数据库的user表，使用password()函数进行密码加密
-- update user set authentication_string=password('新密码') where user='用户名';
update user set authentication_string=password('123') where user='laowang';
-- 注意修改完成后需要刷新权限
flush privileges;

-- 3. 删除账户
-- 语法1：使用root登录
-- drop user '用户名'@'主机';
drop user 'laowang'@'localhost';

-- 语法2：使用root登录，删除mysql数据库的user表中数据
-- delete from user where user='用户名';
delete from user where user='laowang';
-- 操作结束之后需要刷新权限
flush privileges;

-- 推荐使用语法1删除用户, 如果使用语法1删除失败，采用语法2方式
```

**mysql远程登录危险，慎用！**

##### Mysql 主从

主从同步使得数据可以从一个数据库服务器复制到其他服务器上，在复制数据时，一个服务器充当主服务器（master），其余的服务器充当从服务器（slave）。因为复制是异步进行的，所以从服务器不需要一直连接着主服务器，从服务器甚至可以通过拨号断断续续地连接主服务器。通过配置文件，可以指定复制所有的数据库，某个数据库，甚至是某个数据库上的某个表。

使用主从同步的好处：

- 通过增加从服务器来提高数据库的性能，在主服务器上执行写入和更新，在从服务器上向外提供读功能，可以动态地调整从服务器的数量，从而调整整个数据库的性能。**（读写分离）**
- 提高数据安全，因为数据已复制到从服务器，从服务器可以终止复制进程，所以，可以在从服务器上备份而不破坏主服务器相应数据。**（数据备份）**
- 在主服务器上生成实时数据，而在从服务器上分析这些数据，从而提高主服务器的性能

主从还可以实现 **负载均衡**

###### 主从同步的机制

<img src="https://user-images.githubusercontent.com/51505633/80302904-64fd4c80-87df-11ea-8b2d-765b1816688b.png" alt="820365-20160821160615776-1749314661" style="zoom: 67%;" />

Mysql服务器之间的主从同步是基于二进制日志机制，主服务器使用二进制日志来记录数据库的变动情况，从服务器通过读取和执行该日志文件来保持和主服务器的数据一致。

在使用二进制日志时，主服务器的所有操作都会被记录下来，然后从服务器会接收到该日志的一个副本。从服务器可以指定执行该日志中的哪一类事件（譬如只插入数据或者只更新数据），默认会执行日志中的所有语句。

每一个从服务器会记录关于二进制日志的信息：文件名和已经处理过的语句，这样意味着不同的从服务器可以分别执行同一个二进制日志的不同部分，并且从服务器可以随时连接或者中断和服务器的连接。

主服务器和每一个从服务器都必须配置一个唯一的ID号（在my.cnf文件的[mysqld]模块下有一个server-id配置项），另外，每一个从服务器还需要通过CHANGE MASTER TO语句来配置它要连接的主服务器的ip地址，日志文件名称和该日志里面的位置（这些信息存储在主服务器的数据库里）

###### 配置主从同步的基本步骤

有很多种配置主从同步的方法，可以总结为如下的步骤：

1. 在主服务器上，必须开启二进制日志机制和配置一个独立的ID
2. 在每一个从服务器上，配置一个唯一的ID，创建一个用来专门复制主服务器数据的账号
3. 在开始复制进程前，在主服务器上记录二进制文件的位置信息
4. 如果在开始复制之前，数据库中已经有数据，就必须先创建一个数据快照（可以使用mysqldump导出数据库，或者直接复制数据文件）
5. 配置从服务器要连接的主服务器的IP地址和登陆授权，二进制日志文件名和位置

###### 详细配置主从同步的方法

```shell
# 1. 备份 主服务器 原有数据到 从服务器
# 如果在设置主从同步前，主服务器上已有大量数据，可以使用mysqldump进行数据备份并还原到从服务器以实现数据的复制。
# 在主服务器上进行备份
mysqldump -uroot -pmysql --all-databases --lock-all-tables > ~/master_db.sql
# --all-databases: 导出所有数据库; --lock-all-tables: 执行操作时锁住所有表，防止操作时有数据修改
# 在从服务器上进行数据还原
mysql –uroot –pmysql < master_db.sql

# 2 配置主服务器master
# 编辑设置mysqld的配置文件，设置log_bin和server-id
sudo vim /etc/mysql/mysql.conf.d/mysqld.cnf
# 重启mysql服务
sudo service mysql restart
# 登入主服务器Ubuntu中的mysql，创建用于从服务器同步数据使用的帐号
mysql –uroot –pmysql
GRANT REPLICATION SLAVE ON *.* TO 'slave'@'%' identified by 'slave';  (mysql中执行)
FLUSH PRIVILEGES;  (mysql中执行)
# 获取主服务器的二进制日志信息
SHOW MASTER STATUS;  (mysql中执行)
# File为使用的日志文件名字，Position为使用的文件位置，这两个参数须记下，配置从服务器时会用到

# 3 配置从服务器slave
# 编辑设置mysqld的配置文件，设置log_bin和server-id id不能重复
# 重启mysql服务

# 4 设置连接到master主服务器
change master to master_host='10.211.55.5', master_user='slave', master_password='slave',master_log_file='mysql-bin.000006', master_log_pos=590;  (mysql中执行)
# master_host：主服务器的ip地址
# master_log_file: 前面查询到的主服务器日志文件名
# master_log_pos: 前面查询到的主服务器日志文件位置

# 5 开启同步，查看同步状态
start slave;  (mysql中执行)
# Slave_IO_Running 和 Slave_SQL_Running 都为 yes, 则正常运行
```

#### 6 WSGI、mini-web框架

使用 WSGI 协议 实现 mini-web框架，以下内容是迭代的

##### 1)将多进程方式改为面向对象，实现web服务器

```python
# web_server.py 文件 web/http服务器
import socket
import re
import multiprocessing
class WSGIServer(object):
    def __init__(self):
        # 1. 创建套接字
        self.tcp_server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.tcp_server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        # 2. 绑定
        self.tcp_server_socket.bind(("", 7890))
        # 3. 变为监听套接字
        self.tcp_server_socket.listen(128)
    def service_client(self, new_socket):
        """为这个客户端返回数据"""
        # 1. 接收浏览器发送过来的请求 ，即http请求  
        # GET / HTTP/1.1
        # .....
        request = new_socket.recv(1024).decode("utf-8")
        # print(">>>"*50)
        # print(request)
        request_lines = request.splitlines()
        print("")
        print(">"*20)
        print(request_lines)
        # GET /index.html HTTP/1.1
        # get post put del
        file_name = ""
        ret = re.match(r"[^/]+(/[^ ]*)", request_lines[0])
        if ret:
            file_name = ret.group(1)
            # print("*"*50, file_name)
            if file_name == "/":
                file_name = "/index.html"
        # 2. 返回http格式的数据，给浏览器
        try:
            f = open("./html" + file_name, "rb")
        except:
            response = "HTTP/1.1 404 NOT FOUND\r\n"
            response += "\r\n"
            response += "------file not found-----"
            new_socket.send(response.encode("utf-8"))
        else:
            html_content = f.read()
            f.close()
            # 2.1 准备发送给浏览器的数据---header
            response = "HTTP/1.1 200 OK\r\n"
            response += "\r\n"
            # 2.2 准备发送给浏览器的数据---boy
            # response += "hahahhah"
            # 将response header发送给浏览器
            new_socket.send(response.encode("utf-8"))
            # 将response body发送给浏览器
            new_socket.send(html_content)
        # 关闭套接
        new_socket.close()
    def run_forever(self):
        """用来完成整体的控制"""
        while True:
            # 4. 等待新客户端的链接
            new_socket, client_addr = self.tcp_server_socket.accept()
            # 5. 为这个客户端服务
            p = multiprocessing.Process(target=self.service_client, args=(new_socket,))
            p.start()
            new_socket.close()
        # 关闭监听套接字
        self.tcp_server_socket.close()
def main():
    """控制整体，创建一个web 服务器对象，然后调用这个对象的run_forever方法运行"""
    wsgi_server = WSGIServer()
    wsgi_server.run_forever()
if __name__ == "__main__":
    main()
```

##### 2)在web服务器中集成解析动态请求的功能

```python
        # 2. 返回http格式的数据，给浏览器
        # 2.1 如果请求的资源不是以.py结尾，那么就认为是静态资源（html/css/js/png，jpg等）
        if not file_name.endswith(".py"):
            try:  # 省略
        else:
            # 2.2 如果是以.py结尾，那么就认为是动态资源的请求
            header = "HTTP/1.1 200 OK\r\n"
            header += "\r\n"
            body = "hahahah %s " % time.ctime()
            response = header+body
            # 发送response给浏览器
            new_socket.send(response.encode("utf-8"))
```

##### 3)将web服务器和逻辑处理的代码分开

```python
import mini_frame
            # 2.2 如果是以.py结尾，那么就认为是动态资源的请求
            header = "HTTP/1.1 200 OK\r\n"
            header += "\r\n"
            # body = "hahahah %s " % time.ctime()
            # if file_name == "/login.py":  # 这原来只在 mini_frame.py 中放了函数
            #     body = mini_frame.login()
            # elif file_name == "/register.py":
            #     body = mini_frame.register()
            body = mini_frame.application(file_name)  
            # 这样只需修改mini_frame中内容，这无需修改，如添加页面等
            response = header+body
            # 发送response给浏览器
            new_socket.send(response.encode("utf-8"))
# 新建 mini_frame.py  用于处理动态请求  相当于是 web应用/框架
import time
def login():
    return "i----login--welcome hahahh to our website.......time:%s" % time.ctime()
def register():
    return "-----register---welcome hahahh to our website.......time:%s" % time.ctime()
def profile():
    return "-----profile----welcome hahahh to our website.......time:%s" % time.ctime()
def application(file_name):
	if file_name == "/login.py":
		return login()
	elif file_name == "/register.py":
		return register()
	else:
		return "not found you page...."
```

##### 4)让web服务器支持WSGI协议

```python
            # 2.2 如果是以.py结尾，那么就认为是动态资源的请求
            env = dict()
            body = mini_frame.application(env, self.set_response_header)
            # env字典中存放的是web服务器要传递给 web框架的数据信息
            header = "HTTP/1.1 %s\r\n" % self.status
            for temp in self.headers:
                header += "%s:%s\r\n" % (temp[0], temp[1])
            header += "\r\n"
            response = header+body
            # 发送response给浏览器
            new_socket.send(response.encode("utf-8"))
# ...
    def set_response_header(self, status, headers):
        self.status = status
        self.headers = [("server", "mini_web v8.8")]  # 服务器信息要写在服务器中，不应该写在下方
        self.headers += headers
# mini_frame.py 文件
def application(environ, start_response):
    start_response('200 OK', [('Content-Type', 'text/html;charset=utf-8')])
    # start_response 可以把服务器信息和框架信息合并
    return 'Hello World! 我爱你中国....'
```

##### web服务器示意图

<img src="https://i.loli.net/2020/05/02/rc4wEJbymknpsYV.jpg" alt="web服务器示意图.002" style="zoom: 67%;" />

http服务器中处理请求时拆分，只处理静态资源，动态资源由web框架处理 

##### 浏览器请求动态页面过程

<img src="https://i.loli.net/2020/05/02/dUyDToQlwrbxZ3V.png" alt="img" style="zoom:67%;" />

##### WSGI

WSGI(Web Server Gateway Interface)允许开发者将选择web框架和web服务器分开。可以混合匹配web服务器和web框架，选择一个适合的配对。

web服务器必须具备WSGI接口，所有的现代Python Web框架都已具备WSGI接口，它让你不对代码作修改就能使服务器和特定的web框架协同工作。

WSGI接口定义非常简单，它只要求Web开发者实现一个函数，就可以响应HTTP请求。我们来看一个最简单的Web版本的“Hello World!”：

```python
def application(environ, start_response):
    start_response('200 OK', [('Content-Type', 'text/html')])
    # 第一个为状态码，第二个在列表中存元组，按冒号分隔内容
    return 'Hello World!'
```

上面的`application()`函数就是符合WSGI标准的一个HTTP处理函数，它接收两个参数：

- environ：一个包含所有HTTP请求信息的dict对象；
- start_response：一个发送HTTP响应的函数。

整个`application()`函数本身没有涉及到任何解析HTTP的部分，也就是说，把底层web服务器解析部分和应用程序逻辑部分进行了分离，这样开发者就可以专心做一个领域了

不过，等等，这个`application()`函数怎么调用？如果我们自己调用，两个参数environ和start_response我们没法提供，返回的str也没法发给浏览器。

所以`application()`函数必须由WSGI服务器来调用。有很多符合WSGI规范的服务器。而我们此时的web服务器项目的目的就是做一个既能解析静态网页还可以解析动态网页的服务器

> WSGI 没有官方的实现, 因为WSGI更像一个协议. 只要遵照这些协议,WSGI应用(Application)都可以在任何服务器(Server)上运行, 反之亦然。
>
> WSGI 接口有服务端和应用端两部分，服务端也可以叫网关端，应用端也叫框架端。服务端调用一个由应用端提供的可调用对象。
>
> WSGI规定，Web程序必须有一个可调用对象，且该可调用对象接收两个必选参数environ、start_response，返回一个可迭代对象用来表示http body：
>
> 1. environ：字典，包含请求的所有信息
> 2. start_response：在可调用对象中调用的函数，用来发起响应，参数包括状态码，headers等 （start_response 是一个函数引用，定义在服务器中）
>
> 在可调用对象`application()`函数中执行start_response指向的函数时，返回header给服务器(服务器中执行函数，将header存起来就可以)，执行完成后，回到应用程序继续执行，再返回body给服务器
>
> WSGI协议就是规定服务器给框架什么，然后框架给服务器回什么

##### 5)通过传递字典实现浏览器请求的资源不同响应不同

```python
            # 2.2 如果是以.py结尾，那么就认为是动态资源的请求
            env = dict()  # 这个字典中存放的是web服务器要传递给 web框架的数据信息
            env['PATH_INFO'] = file_name
            # {"PATH_INFO": "/index.py"}
            body = mini_frame.application(env, self.set_response_header)
            header = "HTTP/1.1 %s\r\n" % self.status
            for temp in self.headers:
                header += "%s:%s\r\n" % (temp[0], temp[1])
            header += "\r\n"
            response = header+body
            # 发送response给浏览器
            new_socket.send(response.encode("utf-8"))
            
# mini_frame.py 文件
def index():
    return "这是主页"
def login():
    return "这是登录页面"
def application(env, start_response):
    start_response('200 OK', [('Content-Type', 'text/html;charset=utf-8')])
    file_name = env['PATH_INFO']
    # file_name = "/index.py"
    if file_name == "/index.py":
        return index()
    elif file_name == "/login.py":
        return login()
    else:
        return 'Hello World! 我爱你中国....'
```

##### 6)使用模板文件实现

dynamic 文件夹存放 web应用/框架，static 文件夹存放静态文件，templates 文件夹存放模板文件

```python
# web_server中修改：
import dynamic.mini_frame
try:f = open("./static" + file_name, "rb")
body = dynamic.mini_frame.application(env, self.set_response_header)
# mini_frame.py 文件
import re
def index():
    with open("./templates/index.html", encoding="utf-8") as f:  # win10 需要 encoding
        content = f.read()
    return content
def center():
    with open("./templates/center.html", encoding="utf-8") as f:
        content = f.read()
    my_stock_info = "这里是从mysql查询出来的数据。。。"  # 替换模板中的数据
    content = re.sub(r"\{%content%\}", my_stock_info, content)
    return content
def application(env, start_response):  # 省略
```

**以执行 `*.py`文件的位置为基准，所有open 都从这个地址开始找文件    包括导入的模块中的open**

##### 7)运行web服务器时指定端口以及框架、支持配置文件

```python
# web_server 修改
import socket
import re
import multiprocessing
import time
# import dynamic.mini_frame  服务器应该独立的，不应该固定 使用的框架
import sys
class WSGIServer(object):
    def __init__(self, port, app, static_path):
        # 1. 创建套接字
        self.tcp_server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.tcp_server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        # 2. 绑定
        self.tcp_server_socket.bind(("", port))
        # 3. 变为监听套接字
        self.tcp_server_socket.listen(128)
        self.application = app
        self.static_path = static_path
    def service_client(self, new_socket):
        """为这个客户端返回数据"""
        # 1. 接收浏览器发送过来的请求 ，即http请求  
        # GET / HTTP/1.1
        # .....
        request = new_socket.recv(1024).decode("utf-8")
        # print(">>>"*50)
        # print(request)
        request_lines = request.splitlines()
        print("")
        print(">"*20)
        print(request_lines)
        # GET /index.html HTTP/1.1
        # get post put del
        file_name = ""
        ret = re.match(r"[^/]+(/[^ ]*)", request_lines[0])
        if ret:
            file_name = ret.group(1)
            # print("*"*50, file_name)
            if file_name == "/":
                file_name = "/index.html"
        # 2. 返回http格式的数据，给浏览器
        # 2.1 如果请求的资源不是以.py结尾，那么就认为是静态资源（html/css/js/png，jpg等）
        if not file_name.endswith(".py"):
            try:
                f = open(self.static_path + file_name, "rb")
            except:
                response = "HTTP/1.1 404 NOT FOUND\r\n"
                response += "\r\n"
                response += "------file not found-----"
                new_socket.send(response.encode("utf-8"))
            else:
                html_content = f.read()
                f.close()
                # 2.1 准备发送给浏览器的数据---header
                response = "HTTP/1.1 200 OK\r\n"
                response += "\r\n"
                # 2.2 准备发送给浏览器的数据---boy
                # response += "hahahhah"
                # 将response header发送给浏览器
                new_socket.send(response.encode("utf-8"))
                # 将response ic.mini_frame.applicationbody发送给浏览器
                new_socket.send(html_content)
        else:
            # 2.2 如果是以.py结尾，那么就认为是动态资源的请求
            env = dict()  # 这个字典中存放的是web服务器要传递给 web框架的数据信息
            env['PATH_INFO'] = file_name
            # {"PATH_INFO": "/index.py"}
            # body = dynamic.mini_frame.application(env, self.set_response_header)
            body = self.application(env, self.set_response_header)
            header = "HTTP/1.1 %s\r\n" % self.status
            for temp in self.headers:
                header += "%s:%s\r\n" % (temp[0], temp[1])
            header += "\r\n"
            response = header+body
            # 发送response给浏览器
            new_socket.send(response.encode("utf-8"))
        # 关闭套接
        new_socket.close()
    def set_response_header(self, status, headers):
        self.status = status
        self.headers = [("server", "mini_web v8.8")]
        self.headers += headers
    def run_forever(self):
        """用来完成整体的控制"""
        while True:
            # 4. 等待新客户端的链接
            new_socket, client_addr = self.tcp_server_socket.accept()
            # 5. 为这个客户端服务
            p = multiprocessing.Process(target=self.service_client, args=(new_socket,))
            p.start()
            new_socket.close()
        # 关闭监听套接字
        self.tcp_server_socket.close()
def main():
    """控制整体，创建一个web 服务器对象，然后调用这个对象的run_forever方法运行"""
    if len(sys.argv) == 3:
        try:  # 将端口和框架文件提出来
            port = int(sys.argv[1])  # 7890
            frame_app_name = sys.argv[2]  # mini_frame:application
        except Exception as ret:
            print("端口输入错误。。。。。")
            return  # return 空 结束函数
    else:
        print("请按照以下方式运行:")
        print("python3 xxxx.py 7890 mini_frame:application")
        return
    # mini_frame:application
    ret = re.match(r"([^:]+):(.*)", frame_app_name)
    if ret:
        frame_name = ret.group(1)  # mini_frame
        app_name = ret.group(2)  # application
    else:
        print("请按照以下方式运行:")
        print("python3 xxxx.py 7890 mini_frame:application")
        return
    with open("./web_server.conf") as f:  # conf 为配置文件
        conf_info = eval(f.read())  # eval 将配置变为字典
    # 此时 conf_info是一个字典里面的数据为：
    # {
    #     "static_path":"./static",
    #     "dynamic_path":"./dynamic"
    # }
    sys.path.append(conf_info['dynamic_path'])  # 添加找模块的路径
    # import frame_name ---> 这样写会找frame_name.py
    frame = __import__(frame_name)  # 返回值标记这 导入的这个模板    找变量名的值对应的模块
    app = getattr(frame, app_name)  # 此时app就指向了 dynamic/mini_frame模块中的application这个函数
    # print(app)
    wsgi_server = WSGIServer(port, app, conf_info['static_path'])
    wsgi_server.run_forever()
if __name__ == "__main__":
    main()
```

实现在 WSGI 文件夹下，上面为centos中，win10需要修改细节

### `sys.argv` 









类中使用 self 存变量，不会随方法的调用而结束



闭包不只有函数，还有代码

nonlocal    类似 global

闭包 单独的空间  相当于实例     数据是独有的    全局变量方式 是共享的

类中有无用的 魔法方法



#### 装饰器



只能在之前 或者之后 加功能

将原来函数的引用当作实参传递给闭包，



08-通一个装饰器对多个函数进行装饰      一个装饰器可以对多个函数进行装饰

08会创建多个闭包    每装一次，一个闭包



装饰器在调用函数之前，已经被python解释器执行了



拆包传

 11只需要将返回的结果再次返回就可以了

通用：装饰器   接收不定长，拆包传参数，调用原函数后返回

原函数无返回值 是 None



多个装饰器可以对一个函数进行装饰

先装下面的，后装上面的       下面是函数才可以装  所以后面的先装   图

执行的时候正常 上到下



类的还可以 .静态方法 等做装饰器







带有参数的装饰器

调用 set_func 并且将 1 当作实参传递，

用上一步调用的返回值 当作装饰器对test1函数进行装饰      代码实现    再嵌套一层函数

路由

在 10 的基础上

去掉 if  根据请求，自动调

先用字典     全局变量定义  大写 或者 g_

使用装饰器自动填充字典     装饰器先执行了  在调用前

字典中的index 指向的原来的函数（装饰器传入时参数，其指向原函数）   而原来函数名index指向了闭包      图

对02 而言 用不到index指向闭包，闭包指向原函数  的过程  装饰器里面没用到     装饰器目前只是为了添加字典，



路由： 根据不同请求，调用不同内容

  伪静态、静态和动态的区别

伪静态  实现





面向切面  通过装饰器加功能

通过这个过程理解 Flask 



return 类名（）   代表什么   返回一个实例对象的引用

return 函数名  函数的引用   函数名() 返回函数的返回值

# TODO:

服务器那 后几个复现     2 的问题解决

file 部分 博客  看 wb  rb

写实拷贝  创建子进程时 会发生什么





















- 所谓`进程`指的是：运行的程序以及运行时用到的资源这个整体称之为进程（在讲解多任务编程时进行详细讲解）
- 所谓`进程间通信`指的是：运行的程序之间的数据共享
```

```